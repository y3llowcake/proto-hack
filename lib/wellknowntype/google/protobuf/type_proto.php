<?hh // strict
namespace google\protobuf;

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: google/protobuf/type.proto

newtype Syntax_enum_t as int = int;
abstract class Syntax {
  const Syntax_enum_t SYNTAX_PROTO2 = 0;
  const Syntax_enum_t SYNTAX_PROTO3 = 1;
  private static dict<int, string> $itos = dict[
    0 => 'SYNTAX_PROTO2',
    1 => 'SYNTAX_PROTO3',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'SYNTAX_PROTO2' => 0,
    'SYNTAX_PROTO3' => 1,
  ];
  public static function FromMixed(mixed $m): Syntax_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): Syntax_enum_t {
    return $i;
  }
}

class Type implements \Protobuf\Message {
  public string $name;
  public vec<\google\protobuf\Field> $fields;
  public vec<string> $oneofs;
  public vec<\google\protobuf\Option> $options;
  public ?\google\protobuf\SourceContext $source_context;
  public \google\protobuf\Syntax_enum_t $syntax;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'fields' => vec<\google\protobuf\Field>,
    ?'oneofs' => vec<string>,
    ?'options' => vec<\google\protobuf\Option>,
    ?'source_context' => ?\google\protobuf\SourceContext,
    ?'syntax' => \google\protobuf\Syntax_enum_t,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->fields = $s['fields'] ?? vec[];
    $this->oneofs = $s['oneofs'] ?? vec[];
    $this->options = $s['options'] ?? vec[];
    $this->source_context = $s['source_context'] ?? null;
    $this->syntax = $s['syntax'] ?? \google\protobuf\Syntax::FromInt(0);
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.Type";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $obj = new \google\protobuf\Field();
          $obj->MergeFrom($d->readDecoder());
          $this->fields []= $obj;
          break;
        case 3:
          $this->oneofs []= $d->readString();
          break;
        case 4:
          $obj = new \google\protobuf\Option();
          $obj->MergeFrom($d->readDecoder());
          $this->options []= $obj;
          break;
        case 5:
          if ($this->source_context == null) $this->source_context = new \google\protobuf\SourceContext();
          $this->source_context->MergeFrom($d->readDecoder());
          break;
        case 6:
          $this->syntax = \google\protobuf\Syntax::FromInt($d->readVarint());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->fields as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    foreach ($this->oneofs as $elem) {
      $e->writeTag(3, 2);
      $e->writeString($elem);
    }
    foreach ($this->options as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    $msg = $this->source_context;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 5);
    }
    if ($this->syntax !== \google\protobuf\Syntax::FromInt(0)) {
      $e->writeTag(6, 0);
      $e->writeVarint($this->syntax);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeMessageList('fields', 'fields', $this->fields);
    $e->writePrimitiveList('oneofs', 'oneofs', $this->oneofs);
    $e->writeMessageList('options', 'options', $this->options);
    $e->writeMessage('source_context', 'sourceContext', $this->source_context, false);
    $e->writeEnum('syntax', 'syntax', \google\protobuf\Syntax::ToStringDict(), $this->syntax, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'fields':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Field();
            $obj->MergeJsonFrom($vv);
            $this->fields []= $obj;
          }
          break;
        case 'oneofs':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->oneofs []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'options':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Option();
            $obj->MergeJsonFrom($vv);
            $this->options []= $obj;
          }
          break;
        case 'source_context': case 'sourceContext':
          if ($v === null) break;
          if ($this->source_context == null) $this->source_context = new \google\protobuf\SourceContext();
          $this->source_context->MergeJsonFrom($v);
          break;
        case 'syntax':
          $this->syntax = \google\protobuf\Syntax::FromMixed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is Type)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    foreach ($o->fields as $v) {
      $nv = new \google\protobuf\Field();
      $nv->CopyFrom($v);
      $this->fields []= $nv;
    }
    $this->oneofs = $o->oneofs;
    foreach ($o->options as $v) {
      $nv = new \google\protobuf\Option();
      $nv->CopyFrom($v);
      $this->options []= $nv;
    }
    $tmp = $o->source_context;
    if ($tmp !== null) {
      $nv = new \google\protobuf\SourceContext();
      $nv->CopyFrom($tmp);
      $this->source_context = $nv;
    }
    $this->syntax = $o->syntax;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype Field_Kind_enum_t as int = int;
abstract class Field_Kind {
  const Field_Kind_enum_t TYPE_UNKNOWN = 0;
  const Field_Kind_enum_t TYPE_DOUBLE = 1;
  const Field_Kind_enum_t TYPE_FLOAT = 2;
  const Field_Kind_enum_t TYPE_INT64 = 3;
  const Field_Kind_enum_t TYPE_UINT64 = 4;
  const Field_Kind_enum_t TYPE_INT32 = 5;
  const Field_Kind_enum_t TYPE_FIXED64 = 6;
  const Field_Kind_enum_t TYPE_FIXED32 = 7;
  const Field_Kind_enum_t TYPE_BOOL = 8;
  const Field_Kind_enum_t TYPE_STRING = 9;
  const Field_Kind_enum_t TYPE_GROUP = 10;
  const Field_Kind_enum_t TYPE_MESSAGE = 11;
  const Field_Kind_enum_t TYPE_BYTES = 12;
  const Field_Kind_enum_t TYPE_UINT32 = 13;
  const Field_Kind_enum_t TYPE_ENUM = 14;
  const Field_Kind_enum_t TYPE_SFIXED32 = 15;
  const Field_Kind_enum_t TYPE_SFIXED64 = 16;
  const Field_Kind_enum_t TYPE_SINT32 = 17;
  const Field_Kind_enum_t TYPE_SINT64 = 18;
  private static dict<int, string> $itos = dict[
    0 => 'TYPE_UNKNOWN',
    1 => 'TYPE_DOUBLE',
    2 => 'TYPE_FLOAT',
    3 => 'TYPE_INT64',
    4 => 'TYPE_UINT64',
    5 => 'TYPE_INT32',
    6 => 'TYPE_FIXED64',
    7 => 'TYPE_FIXED32',
    8 => 'TYPE_BOOL',
    9 => 'TYPE_STRING',
    10 => 'TYPE_GROUP',
    11 => 'TYPE_MESSAGE',
    12 => 'TYPE_BYTES',
    13 => 'TYPE_UINT32',
    14 => 'TYPE_ENUM',
    15 => 'TYPE_SFIXED32',
    16 => 'TYPE_SFIXED64',
    17 => 'TYPE_SINT32',
    18 => 'TYPE_SINT64',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'TYPE_UNKNOWN' => 0,
    'TYPE_DOUBLE' => 1,
    'TYPE_FLOAT' => 2,
    'TYPE_INT64' => 3,
    'TYPE_UINT64' => 4,
    'TYPE_INT32' => 5,
    'TYPE_FIXED64' => 6,
    'TYPE_FIXED32' => 7,
    'TYPE_BOOL' => 8,
    'TYPE_STRING' => 9,
    'TYPE_GROUP' => 10,
    'TYPE_MESSAGE' => 11,
    'TYPE_BYTES' => 12,
    'TYPE_UINT32' => 13,
    'TYPE_ENUM' => 14,
    'TYPE_SFIXED32' => 15,
    'TYPE_SFIXED64' => 16,
    'TYPE_SINT32' => 17,
    'TYPE_SINT64' => 18,
  ];
  public static function FromMixed(mixed $m): Field_Kind_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): Field_Kind_enum_t {
    return $i;
  }
}

newtype Field_Cardinality_enum_t as int = int;
abstract class Field_Cardinality {
  const Field_Cardinality_enum_t CARDINALITY_UNKNOWN = 0;
  const Field_Cardinality_enum_t CARDINALITY_OPTIONAL = 1;
  const Field_Cardinality_enum_t CARDINALITY_REQUIRED = 2;
  const Field_Cardinality_enum_t CARDINALITY_REPEATED = 3;
  private static dict<int, string> $itos = dict[
    0 => 'CARDINALITY_UNKNOWN',
    1 => 'CARDINALITY_OPTIONAL',
    2 => 'CARDINALITY_REQUIRED',
    3 => 'CARDINALITY_REPEATED',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'CARDINALITY_UNKNOWN' => 0,
    'CARDINALITY_OPTIONAL' => 1,
    'CARDINALITY_REQUIRED' => 2,
    'CARDINALITY_REPEATED' => 3,
  ];
  public static function FromMixed(mixed $m): Field_Cardinality_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): Field_Cardinality_enum_t {
    return $i;
  }
}

class Field implements \Protobuf\Message {
  public \google\protobuf\Field_Kind_enum_t $kind;
  public \google\protobuf\Field_Cardinality_enum_t $cardinality;
  public int $number;
  public string $name;
  public string $type_url;
  public int $oneof_index;
  public bool $packed;
  public vec<\google\protobuf\Option> $options;
  public string $json_name;
  public string $default_value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'kind' => \google\protobuf\Field_Kind_enum_t,
    ?'cardinality' => \google\protobuf\Field_Cardinality_enum_t,
    ?'number' => int,
    ?'name' => string,
    ?'type_url' => string,
    ?'oneof_index' => int,
    ?'packed' => bool,
    ?'options' => vec<\google\protobuf\Option>,
    ?'json_name' => string,
    ?'default_value' => string,
  ) $s = shape()) {
    $this->kind = $s['kind'] ?? \google\protobuf\Field_Kind::FromInt(0);
    $this->cardinality = $s['cardinality'] ?? \google\protobuf\Field_Cardinality::FromInt(0);
    $this->number = $s['number'] ?? 0;
    $this->name = $s['name'] ?? '';
    $this->type_url = $s['type_url'] ?? '';
    $this->oneof_index = $s['oneof_index'] ?? 0;
    $this->packed = $s['packed'] ?? false;
    $this->options = $s['options'] ?? vec[];
    $this->json_name = $s['json_name'] ?? '';
    $this->default_value = $s['default_value'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.Field";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->kind = \google\protobuf\Field_Kind::FromInt($d->readVarint());
          break;
        case 2:
          $this->cardinality = \google\protobuf\Field_Cardinality::FromInt($d->readVarint());
          break;
        case 3:
          $this->number = $d->readVarint32Signed();
          break;
        case 4:
          $this->name = $d->readString();
          break;
        case 6:
          $this->type_url = $d->readString();
          break;
        case 7:
          $this->oneof_index = $d->readVarint32Signed();
          break;
        case 8:
          $this->packed = $d->readBool();
          break;
        case 9:
          $obj = new \google\protobuf\Option();
          $obj->MergeFrom($d->readDecoder());
          $this->options []= $obj;
          break;
        case 10:
          $this->json_name = $d->readString();
          break;
        case 11:
          $this->default_value = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->kind !== \google\protobuf\Field_Kind::FromInt(0)) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->kind);
    }
    if ($this->cardinality !== \google\protobuf\Field_Cardinality::FromInt(0)) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->cardinality);
    }
    if ($this->number !== 0) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->number);
    }
    if ($this->name !== '') {
      $e->writeTag(4, 2);
      $e->writeString($this->name);
    }
    if ($this->type_url !== '') {
      $e->writeTag(6, 2);
      $e->writeString($this->type_url);
    }
    if ($this->oneof_index !== 0) {
      $e->writeTag(7, 0);
      $e->writeVarint($this->oneof_index);
    }
    if ($this->packed !== false) {
      $e->writeTag(8, 0);
      $e->writeBool($this->packed);
    }
    foreach ($this->options as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 9);
    }
    if ($this->json_name !== '') {
      $e->writeTag(10, 2);
      $e->writeString($this->json_name);
    }
    if ($this->default_value !== '') {
      $e->writeTag(11, 2);
      $e->writeString($this->default_value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeEnum('kind', 'kind', \google\protobuf\Field_Kind::ToStringDict(), $this->kind, false);
    $e->writeEnum('cardinality', 'cardinality', \google\protobuf\Field_Cardinality::ToStringDict(), $this->cardinality, false);
    $e->writeInt32('number', 'number', $this->number, false);
    $e->writeString('name', 'name', $this->name, false);
    $e->writeString('type_url', 'typeUrl', $this->type_url, false);
    $e->writeInt32('oneof_index', 'oneofIndex', $this->oneof_index, false);
    $e->writeBool('packed', 'packed', $this->packed, false);
    $e->writeMessageList('options', 'options', $this->options);
    $e->writeString('json_name', 'jsonName', $this->json_name, false);
    $e->writeString('default_value', 'defaultValue', $this->default_value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'kind':
          $this->kind = \google\protobuf\Field_Kind::FromMixed($v);
          break;
        case 'cardinality':
          $this->cardinality = \google\protobuf\Field_Cardinality::FromMixed($v);
          break;
        case 'number':
          $this->number = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'type_url': case 'typeUrl':
          $this->type_url = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'oneof_index': case 'oneofIndex':
          $this->oneof_index = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'packed':
          $this->packed = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'options':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Option();
            $obj->MergeJsonFrom($vv);
            $this->options []= $obj;
          }
          break;
        case 'json_name': case 'jsonName':
          $this->json_name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'default_value': case 'defaultValue':
          $this->default_value = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is Field)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->kind = $o->kind;
    $this->cardinality = $o->cardinality;
    $this->number = $o->number;
    $this->name = $o->name;
    $this->type_url = $o->type_url;
    $this->oneof_index = $o->oneof_index;
    $this->packed = $o->packed;
    foreach ($o->options as $v) {
      $nv = new \google\protobuf\Option();
      $nv->CopyFrom($v);
      $this->options []= $nv;
    }
    $this->json_name = $o->json_name;
    $this->default_value = $o->default_value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class pb_Enum implements \Protobuf\Message {
  public string $name;
  public vec<\google\protobuf\EnumValue> $enumvalue;
  public vec<\google\protobuf\Option> $options;
  public ?\google\protobuf\SourceContext $source_context;
  public \google\protobuf\Syntax_enum_t $syntax;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'enumvalue' => vec<\google\protobuf\EnumValue>,
    ?'options' => vec<\google\protobuf\Option>,
    ?'source_context' => ?\google\protobuf\SourceContext,
    ?'syntax' => \google\protobuf\Syntax_enum_t,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->enumvalue = $s['enumvalue'] ?? vec[];
    $this->options = $s['options'] ?? vec[];
    $this->source_context = $s['source_context'] ?? null;
    $this->syntax = $s['syntax'] ?? \google\protobuf\Syntax::FromInt(0);
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.Enum";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $obj = new \google\protobuf\EnumValue();
          $obj->MergeFrom($d->readDecoder());
          $this->enumvalue []= $obj;
          break;
        case 3:
          $obj = new \google\protobuf\Option();
          $obj->MergeFrom($d->readDecoder());
          $this->options []= $obj;
          break;
        case 4:
          if ($this->source_context == null) $this->source_context = new \google\protobuf\SourceContext();
          $this->source_context->MergeFrom($d->readDecoder());
          break;
        case 5:
          $this->syntax = \google\protobuf\Syntax::FromInt($d->readVarint());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->enumvalue as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    foreach ($this->options as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
    $msg = $this->source_context;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    if ($this->syntax !== \google\protobuf\Syntax::FromInt(0)) {
      $e->writeTag(5, 0);
      $e->writeVarint($this->syntax);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeMessageList('enumvalue', 'enumvalue', $this->enumvalue);
    $e->writeMessageList('options', 'options', $this->options);
    $e->writeMessage('source_context', 'sourceContext', $this->source_context, false);
    $e->writeEnum('syntax', 'syntax', \google\protobuf\Syntax::ToStringDict(), $this->syntax, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'enumvalue':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumValue();
            $obj->MergeJsonFrom($vv);
            $this->enumvalue []= $obj;
          }
          break;
        case 'options':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Option();
            $obj->MergeJsonFrom($vv);
            $this->options []= $obj;
          }
          break;
        case 'source_context': case 'sourceContext':
          if ($v === null) break;
          if ($this->source_context == null) $this->source_context = new \google\protobuf\SourceContext();
          $this->source_context->MergeJsonFrom($v);
          break;
        case 'syntax':
          $this->syntax = \google\protobuf\Syntax::FromMixed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is pb_Enum)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    foreach ($o->enumvalue as $v) {
      $nv = new \google\protobuf\EnumValue();
      $nv->CopyFrom($v);
      $this->enumvalue []= $nv;
    }
    foreach ($o->options as $v) {
      $nv = new \google\protobuf\Option();
      $nv->CopyFrom($v);
      $this->options []= $nv;
    }
    $tmp = $o->source_context;
    if ($tmp !== null) {
      $nv = new \google\protobuf\SourceContext();
      $nv->CopyFrom($tmp);
      $this->source_context = $nv;
    }
    $this->syntax = $o->syntax;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumValue implements \Protobuf\Message {
  public string $name;
  public int $number;
  public vec<\google\protobuf\Option> $options;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'number' => int,
    ?'options' => vec<\google\protobuf\Option>,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->number = $s['number'] ?? 0;
    $this->options = $s['options'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.EnumValue";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $this->number = $d->readVarint32Signed();
          break;
        case 3:
          $obj = new \google\protobuf\Option();
          $obj->MergeFrom($d->readDecoder());
          $this->options []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->number !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->number);
    }
    foreach ($this->options as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeInt32('number', 'number', $this->number, false);
    $e->writeMessageList('options', 'options', $this->options);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'number':
          $this->number = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'options':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Option();
            $obj->MergeJsonFrom($vv);
            $this->options []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumValue)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    $this->number = $o->number;
    foreach ($o->options as $v) {
      $nv = new \google\protobuf\Option();
      $nv->CopyFrom($v);
      $this->options []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class Option implements \Protobuf\Message {
  public string $name;
  public ?\google\protobuf\Any $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'value' => ?\google\protobuf\Any,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->value = $s['value'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.Option";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          if ($this->value == null) $this->value = new \google\protobuf\Any();
          $this->value->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    $msg = $this->value;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeMessage('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          if ($v === null) break;
          if ($this->value == null) $this->value = new \google\protobuf\Any();
          $this->value->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is Option)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    $tmp = $o->value;
    if ($tmp !== null) {
      $nv = new \google\protobuf\Any();
      $nv->CopyFrom($tmp);
      $this->value = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}


class XXX_FileDescriptor_google_protobuf_type__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'google/protobuf/type.proto';
  const string RAW =
  'eNqkVd2O2kYUjo3x4sPCTiZR4mykFNFeoEg1KqxWvTWLl1pLbHcwTbY3yAteRNaMEbbbRX'
  .'2GvkQve92H6CP1rtWMwZifSmlz5/Od73znZ45n4HwahtPAby6WYRzeJffNeLXwNW7hs9Sn'
  .'bXznr/bJHl2l3vOv9l1RmCzH/mgc0th/jFNW/VcRJHe18DEGiXpzXxVqQkMh/BtrIN/P/G'
  .'ASqWKt0Ci3Xmh7+bVr5iZrFn4Bckj98D5SC7VCQyFrC38DJ+EinoU0UiUu9PJAyOZ+suFh'
  .'A6q79arFmtAot94cRA447SplkUqUN3ET5GhFY+9RlWtCo3ok8YC7yZpW/0OGIm8KN0F6mN'
  .'EJH0i19fp469rNjE4IJ+IulMfecjKjXjCLV6rI4+r/Ene1ZZJ8GJshTeZ3/lIt1IRGkayt'
  .'7Hyk3Pm8ghJbjlGyDHh/Cjlh9nAZ4C+gzIc/mtGJ/6iecC3gkMkQlmfhjR/8iVqqCY0SWV'
  .'v5s1I+8axeg/IxCumI1we8jhIDLFbjl1CZ+PdeEsSjn7wg8dUyJ5yuwR8YVv9TBIlNEiM4'
  .'dW8dYzS0biz7vYWe4DMoc6RrDzt9Awm4CsCB676tu0jMbNNyLy9QIQsYpoCUJ7RbqJjluD'
  .'Y/GN3LCyTvIu0WOsEVUDjSse0+KmWaA5eYVg8pmWaP2EMHQabwzhgM9J6Byhmjc+saA3S6'
  .'U1a7hSpZCsMavkNV/BQqaYpNEWd70OUFQttCUpWnO8DlBcL1GMq53cIv4dmVTrqmpfdN9z'
  .'Y3VxWe5x2245q2pfeRsO8hxvdDkxhdJB56HEN3jS4q1P8WQDJoMj96jXwLik+TeXr86U1y'
  .'frBULJovA9mS88tY+N8Xh/R5F0fx0y6Oj6BkLRydwvbHFnd+7P/eY/07kFPoaKK3UNyMmj'
  .'X+/EBOpyuSUt5qIKd9sGUb3Fqu/mHkENu1W+jJPtRGQucXeDYO5/uKHYU9IQ6zHOHHr9fe'
  .'aRh4dKqFy+nuWxY1H2j4M+Xfi7u/BOE3sdBzOr+Lb3ppoLMp9L0fBDeMy+SjO5nLtP8JAA'
  .'D//7RnFH0';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    return (string)\gzuncompress(\base64_decode(self::RAW));
  }
}
