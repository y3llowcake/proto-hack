<?hh // strict
namespace google\protobuf;

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: test/descriptor.proto

class FileDescriptorSet implements \Protobuf\Message {
  public vec<\google\protobuf\FileDescriptorProto> $file;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'file' => vec<\google\protobuf\FileDescriptorProto>,
  ) $s = shape()) {
    $this->file = $s['file'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.FileDescriptorSet";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\FileDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->file []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->file as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('file', 'file', $this->file);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'file':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FileDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->file []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FileDescriptorSet)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->file as $v) {
      $nv = new \google\protobuf\FileDescriptorProto();
      $nv->CopyFrom($v);
      $this->file []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class FileDescriptorProto implements \Protobuf\Message {
  public string $name;
  public string $package;
  public vec<string> $dependency;
  public vec<int> $public_dependency;
  public vec<int> $weak_dependency;
  public vec<\google\protobuf\DescriptorProto> $message_type;
  public vec<\google\protobuf\EnumDescriptorProto> $enum_type;
  public vec<\google\protobuf\ServiceDescriptorProto> $service;
  public vec<\google\protobuf\FieldDescriptorProto> $extension;
  public ?\google\protobuf\FileOptions $options;
  public ?\google\protobuf\SourceCodeInfo $source_code_info;
  public string $syntax;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'package' => string,
    ?'dependency' => vec<string>,
    ?'public_dependency' => vec<int>,
    ?'weak_dependency' => vec<int>,
    ?'message_type' => vec<\google\protobuf\DescriptorProto>,
    ?'enum_type' => vec<\google\protobuf\EnumDescriptorProto>,
    ?'service' => vec<\google\protobuf\ServiceDescriptorProto>,
    ?'extension' => vec<\google\protobuf\FieldDescriptorProto>,
    ?'options' => ?\google\protobuf\FileOptions,
    ?'source_code_info' => ?\google\protobuf\SourceCodeInfo,
    ?'syntax' => string,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->package = $s['package'] ?? '';
    $this->dependency = $s['dependency'] ?? vec[];
    $this->public_dependency = $s['public_dependency'] ?? vec[];
    $this->weak_dependency = $s['weak_dependency'] ?? vec[];
    $this->message_type = $s['message_type'] ?? vec[];
    $this->enum_type = $s['enum_type'] ?? vec[];
    $this->service = $s['service'] ?? vec[];
    $this->extension = $s['extension'] ?? vec[];
    $this->options = $s['options'] ?? null;
    $this->source_code_info = $s['source_code_info'] ?? null;
    $this->syntax = $s['syntax'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.FileDescriptorProto";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $this->package = $d->readString();
          break;
        case 3:
          $this->dependency []= $d->readString();
          break;
        case 4:
          $obj = new \google\protobuf\DescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->message_type []= $obj;
          break;
        case 5:
          $obj = new \google\protobuf\EnumDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->enum_type []= $obj;
          break;
        case 6:
          $obj = new \google\protobuf\ServiceDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->service []= $obj;
          break;
        case 7:
          $obj = new \google\protobuf\FieldDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->extension []= $obj;
          break;
        case 8:
          if ($this->options == null) $this->options = new \google\protobuf\FileOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 9:
          if ($this->source_code_info == null) $this->source_code_info = new \google\protobuf\SourceCodeInfo();
          $this->source_code_info->MergeFrom($d->readDecoder());
          break;
        case 10:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->public_dependency []= $packed->readVarint32Signed();
            }
          } else {
            $this->public_dependency []= $d->readVarint32Signed();
          }
          break;
        case 11:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->weak_dependency []= $packed->readVarint32Signed();
            }
          } else {
            $this->weak_dependency []= $d->readVarint32Signed();
          }
          break;
        case 12:
          $this->syntax = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->package !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->package);
    }
    foreach ($this->dependency as $elem) {
      $e->writeTag(3, 2);
      $e->writeString($elem);
    }
    foreach ($this->message_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    foreach ($this->enum_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 5);
    }
    foreach ($this->service as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 6);
    }
    foreach ($this->extension as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 7);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 8);
    }
    $msg = $this->source_code_info;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 9);
    }
    foreach ($this->public_dependency as $elem) {
      $e->writeTag(10, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->weak_dependency as $elem) {
      $e->writeTag(11, 0);
      $e->writeVarint($elem);
    }
    if ($this->syntax !== '') {
      $e->writeTag(12, 2);
      $e->writeString($this->syntax);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeString('package', 'package', $this->package, false);
    $e->writePrimitiveList('dependency', 'dependency', $this->dependency);
    $e->writeMessageList('message_type', 'messageType', $this->message_type);
    $e->writeMessageList('enum_type', 'enumType', $this->enum_type);
    $e->writeMessageList('service', 'service', $this->service);
    $e->writeMessageList('extension', 'extension', $this->extension);
    $e->writeMessage('options', 'options', $this->options, false);
    $e->writeMessage('source_code_info', 'sourceCodeInfo', $this->source_code_info, false);
    $e->writePrimitiveList('public_dependency', 'publicDependency', $this->public_dependency);
    $e->writePrimitiveList('weak_dependency', 'weakDependency', $this->weak_dependency);
    $e->writeString('syntax', 'syntax', $this->syntax, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'package':
          $this->package = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'dependency':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->dependency []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'message_type': case 'messageType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->message_type []= $obj;
          }
          break;
        case 'enum_type': case 'enumType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->enum_type []= $obj;
          }
          break;
        case 'service':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\ServiceDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->service []= $obj;
          }
          break;
        case 'extension':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->extension []= $obj;
          }
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\FileOptions();
          $this->options->MergeJsonFrom($v);
          break;
        case 'source_code_info': case 'sourceCodeInfo':
          if ($v === null) break;
          if ($this->source_code_info == null) $this->source_code_info = new \google\protobuf\SourceCodeInfo();
          $this->source_code_info->MergeJsonFrom($v);
          break;
        case 'public_dependency': case 'publicDependency':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->public_dependency []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'weak_dependency': case 'weakDependency':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->weak_dependency []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'syntax':
          $this->syntax = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FileDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    $this->package = $o->package;
    $this->dependency = $o->dependency;
    foreach ($o->message_type as $v) {
      $nv = new \google\protobuf\DescriptorProto();
      $nv->CopyFrom($v);
      $this->message_type []= $nv;
    }
    foreach ($o->enum_type as $v) {
      $nv = new \google\protobuf\EnumDescriptorProto();
      $nv->CopyFrom($v);
      $this->enum_type []= $nv;
    }
    foreach ($o->service as $v) {
      $nv = new \google\protobuf\ServiceDescriptorProto();
      $nv->CopyFrom($v);
      $this->service []= $nv;
    }
    foreach ($o->extension as $v) {
      $nv = new \google\protobuf\FieldDescriptorProto();
      $nv->CopyFrom($v);
      $this->extension []= $nv;
    }
    $tmp = $o->options;
    if ($tmp !== null) {
      $nv = new \google\protobuf\FileOptions();
      $nv->CopyFrom($tmp);
      $this->options = $nv;
    }
    $tmp = $o->source_code_info;
    if ($tmp !== null) {
      $nv = new \google\protobuf\SourceCodeInfo();
      $nv->CopyFrom($tmp);
      $this->source_code_info = $nv;
    }
    $this->public_dependency = $o->public_dependency;
    $this->weak_dependency = $o->weak_dependency;
    $this->syntax = $o->syntax;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class DescriptorProto_ExtensionRange implements \Protobuf\Message {
  public int $start;
  public int $end;
  public ?\google\protobuf\ExtensionRangeOptions $options;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'start' => int,
    ?'end' => int,
    ?'options' => ?\google\protobuf\ExtensionRangeOptions,
  ) $s = shape()) {
    $this->start = $s['start'] ?? 0;
    $this->end = $s['end'] ?? 0;
    $this->options = $s['options'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.DescriptorProto.ExtensionRange";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->start = $d->readVarint32Signed();
          break;
        case 2:
          $this->end = $d->readVarint32Signed();
          break;
        case 3:
          if ($this->options == null) $this->options = new \google\protobuf\ExtensionRangeOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->start !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->start);
    }
    if ($this->end !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->end);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('start', 'start', $this->start, false);
    $e->writeInt32('end', 'end', $this->end, false);
    $e->writeMessage('options', 'options', $this->options, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'start':
          $this->start = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\ExtensionRangeOptions();
          $this->options->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is DescriptorProto_ExtensionRange)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->start = $o->start;
    $this->end = $o->end;
    $tmp = $o->options;
    if ($tmp !== null) {
      $nv = new \google\protobuf\ExtensionRangeOptions();
      $nv->CopyFrom($tmp);
      $this->options = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class DescriptorProto_ReservedRange implements \Protobuf\Message {
  public int $start;
  public int $end;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'start' => int,
    ?'end' => int,
  ) $s = shape()) {
    $this->start = $s['start'] ?? 0;
    $this->end = $s['end'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.DescriptorProto.ReservedRange";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->start = $d->readVarint32Signed();
          break;
        case 2:
          $this->end = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->start !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->start);
    }
    if ($this->end !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->end);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('start', 'start', $this->start, false);
    $e->writeInt32('end', 'end', $this->end, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'start':
          $this->start = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is DescriptorProto_ReservedRange)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->start = $o->start;
    $this->end = $o->end;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class DescriptorProto implements \Protobuf\Message {
  public string $name;
  public vec<\google\protobuf\FieldDescriptorProto> $field;
  public vec<\google\protobuf\FieldDescriptorProto> $extension;
  public vec<\google\protobuf\DescriptorProto> $nested_type;
  public vec<\google\protobuf\EnumDescriptorProto> $enum_type;
  public vec<\google\protobuf\DescriptorProto_ExtensionRange> $extension_range;
  public vec<\google\protobuf\OneofDescriptorProto> $oneof_decl;
  public ?\google\protobuf\MessageOptions $options;
  public vec<\google\protobuf\DescriptorProto_ReservedRange> $reserved_range;
  public vec<string> $reserved_name;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'field' => vec<\google\protobuf\FieldDescriptorProto>,
    ?'extension' => vec<\google\protobuf\FieldDescriptorProto>,
    ?'nested_type' => vec<\google\protobuf\DescriptorProto>,
    ?'enum_type' => vec<\google\protobuf\EnumDescriptorProto>,
    ?'extension_range' => vec<\google\protobuf\DescriptorProto_ExtensionRange>,
    ?'oneof_decl' => vec<\google\protobuf\OneofDescriptorProto>,
    ?'options' => ?\google\protobuf\MessageOptions,
    ?'reserved_range' => vec<\google\protobuf\DescriptorProto_ReservedRange>,
    ?'reserved_name' => vec<string>,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->field = $s['field'] ?? vec[];
    $this->extension = $s['extension'] ?? vec[];
    $this->nested_type = $s['nested_type'] ?? vec[];
    $this->enum_type = $s['enum_type'] ?? vec[];
    $this->extension_range = $s['extension_range'] ?? vec[];
    $this->oneof_decl = $s['oneof_decl'] ?? vec[];
    $this->options = $s['options'] ?? null;
    $this->reserved_range = $s['reserved_range'] ?? vec[];
    $this->reserved_name = $s['reserved_name'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.DescriptorProto";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $obj = new \google\protobuf\FieldDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->field []= $obj;
          break;
        case 3:
          $obj = new \google\protobuf\DescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->nested_type []= $obj;
          break;
        case 4:
          $obj = new \google\protobuf\EnumDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->enum_type []= $obj;
          break;
        case 5:
          $obj = new \google\protobuf\DescriptorProto_ExtensionRange();
          $obj->MergeFrom($d->readDecoder());
          $this->extension_range []= $obj;
          break;
        case 6:
          $obj = new \google\protobuf\FieldDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->extension []= $obj;
          break;
        case 7:
          if ($this->options == null) $this->options = new \google\protobuf\MessageOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 8:
          $obj = new \google\protobuf\OneofDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->oneof_decl []= $obj;
          break;
        case 9:
          $obj = new \google\protobuf\DescriptorProto_ReservedRange();
          $obj->MergeFrom($d->readDecoder());
          $this->reserved_range []= $obj;
          break;
        case 10:
          $this->reserved_name []= $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->field as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    foreach ($this->nested_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
    foreach ($this->enum_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    foreach ($this->extension_range as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 5);
    }
    foreach ($this->extension as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 6);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 7);
    }
    foreach ($this->oneof_decl as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 8);
    }
    foreach ($this->reserved_range as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 9);
    }
    foreach ($this->reserved_name as $elem) {
      $e->writeTag(10, 2);
      $e->writeString($elem);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeMessageList('field', 'field', $this->field);
    $e->writeMessageList('nested_type', 'nestedType', $this->nested_type);
    $e->writeMessageList('enum_type', 'enumType', $this->enum_type);
    $e->writeMessageList('extension_range', 'extensionRange', $this->extension_range);
    $e->writeMessageList('extension', 'extension', $this->extension);
    $e->writeMessage('options', 'options', $this->options, false);
    $e->writeMessageList('oneof_decl', 'oneofDecl', $this->oneof_decl);
    $e->writeMessageList('reserved_range', 'reservedRange', $this->reserved_range);
    $e->writePrimitiveList('reserved_name', 'reservedName', $this->reserved_name);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'field':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->field []= $obj;
          }
          break;
        case 'nested_type': case 'nestedType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->nested_type []= $obj;
          }
          break;
        case 'enum_type': case 'enumType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->enum_type []= $obj;
          }
          break;
        case 'extension_range': case 'extensionRange':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto_ExtensionRange();
            $obj->MergeJsonFrom($vv);
            $this->extension_range []= $obj;
          }
          break;
        case 'extension':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->extension []= $obj;
          }
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\MessageOptions();
          $this->options->MergeJsonFrom($v);
          break;
        case 'oneof_decl': case 'oneofDecl':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\OneofDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->oneof_decl []= $obj;
          }
          break;
        case 'reserved_range': case 'reservedRange':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto_ReservedRange();
            $obj->MergeJsonFrom($vv);
            $this->reserved_range []= $obj;
          }
          break;
        case 'reserved_name': case 'reservedName':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->reserved_name []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is DescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    foreach ($o->field as $v) {
      $nv = new \google\protobuf\FieldDescriptorProto();
      $nv->CopyFrom($v);
      $this->field []= $nv;
    }
    foreach ($o->nested_type as $v) {
      $nv = new \google\protobuf\DescriptorProto();
      $nv->CopyFrom($v);
      $this->nested_type []= $nv;
    }
    foreach ($o->enum_type as $v) {
      $nv = new \google\protobuf\EnumDescriptorProto();
      $nv->CopyFrom($v);
      $this->enum_type []= $nv;
    }
    foreach ($o->extension_range as $v) {
      $nv = new \google\protobuf\DescriptorProto_ExtensionRange();
      $nv->CopyFrom($v);
      $this->extension_range []= $nv;
    }
    foreach ($o->extension as $v) {
      $nv = new \google\protobuf\FieldDescriptorProto();
      $nv->CopyFrom($v);
      $this->extension []= $nv;
    }
    $tmp = $o->options;
    if ($tmp !== null) {
      $nv = new \google\protobuf\MessageOptions();
      $nv->CopyFrom($tmp);
      $this->options = $nv;
    }
    foreach ($o->oneof_decl as $v) {
      $nv = new \google\protobuf\OneofDescriptorProto();
      $nv->CopyFrom($v);
      $this->oneof_decl []= $nv;
    }
    foreach ($o->reserved_range as $v) {
      $nv = new \google\protobuf\DescriptorProto_ReservedRange();
      $nv->CopyFrom($v);
      $this->reserved_range []= $nv;
    }
    $this->reserved_name = $o->reserved_name;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class ExtensionRangeOptions implements \Protobuf\Message {
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.ExtensionRangeOptions";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ExtensionRangeOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype FieldDescriptorProto_Type_enum_t as int = int;
abstract class FieldDescriptorProto_Type {
  const FieldDescriptorProto_Type_enum_t TYPE_DOUBLE = 1;
  const FieldDescriptorProto_Type_enum_t TYPE_FLOAT = 2;
  const FieldDescriptorProto_Type_enum_t TYPE_INT64 = 3;
  const FieldDescriptorProto_Type_enum_t TYPE_UINT64 = 4;
  const FieldDescriptorProto_Type_enum_t TYPE_INT32 = 5;
  const FieldDescriptorProto_Type_enum_t TYPE_FIXED64 = 6;
  const FieldDescriptorProto_Type_enum_t TYPE_FIXED32 = 7;
  const FieldDescriptorProto_Type_enum_t TYPE_BOOL = 8;
  const FieldDescriptorProto_Type_enum_t TYPE_STRING = 9;
  const FieldDescriptorProto_Type_enum_t TYPE_GROUP = 10;
  const FieldDescriptorProto_Type_enum_t TYPE_MESSAGE = 11;
  const FieldDescriptorProto_Type_enum_t TYPE_BYTES = 12;
  const FieldDescriptorProto_Type_enum_t TYPE_UINT32 = 13;
  const FieldDescriptorProto_Type_enum_t TYPE_ENUM = 14;
  const FieldDescriptorProto_Type_enum_t TYPE_SFIXED32 = 15;
  const FieldDescriptorProto_Type_enum_t TYPE_SFIXED64 = 16;
  const FieldDescriptorProto_Type_enum_t TYPE_SINT32 = 17;
  const FieldDescriptorProto_Type_enum_t TYPE_SINT64 = 18;
  private static dict<int, string> $itos = dict[
    1 => 'TYPE_DOUBLE',
    2 => 'TYPE_FLOAT',
    3 => 'TYPE_INT64',
    4 => 'TYPE_UINT64',
    5 => 'TYPE_INT32',
    6 => 'TYPE_FIXED64',
    7 => 'TYPE_FIXED32',
    8 => 'TYPE_BOOL',
    9 => 'TYPE_STRING',
    10 => 'TYPE_GROUP',
    11 => 'TYPE_MESSAGE',
    12 => 'TYPE_BYTES',
    13 => 'TYPE_UINT32',
    14 => 'TYPE_ENUM',
    15 => 'TYPE_SFIXED32',
    16 => 'TYPE_SFIXED64',
    17 => 'TYPE_SINT32',
    18 => 'TYPE_SINT64',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'TYPE_DOUBLE' => 1,
    'TYPE_FLOAT' => 2,
    'TYPE_INT64' => 3,
    'TYPE_UINT64' => 4,
    'TYPE_INT32' => 5,
    'TYPE_FIXED64' => 6,
    'TYPE_FIXED32' => 7,
    'TYPE_BOOL' => 8,
    'TYPE_STRING' => 9,
    'TYPE_GROUP' => 10,
    'TYPE_MESSAGE' => 11,
    'TYPE_BYTES' => 12,
    'TYPE_UINT32' => 13,
    'TYPE_ENUM' => 14,
    'TYPE_SFIXED32' => 15,
    'TYPE_SFIXED64' => 16,
    'TYPE_SINT32' => 17,
    'TYPE_SINT64' => 18,
  ];
  public static function FromMixed(mixed $m): FieldDescriptorProto_Type_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FieldDescriptorProto_Type_enum_t {
    return $i;
  }
}

newtype FieldDescriptorProto_Label_enum_t as int = int;
abstract class FieldDescriptorProto_Label {
  const FieldDescriptorProto_Label_enum_t LABEL_OPTIONAL = 1;
  const FieldDescriptorProto_Label_enum_t LABEL_REQUIRED = 2;
  const FieldDescriptorProto_Label_enum_t LABEL_REPEATED = 3;
  private static dict<int, string> $itos = dict[
    1 => 'LABEL_OPTIONAL',
    2 => 'LABEL_REQUIRED',
    3 => 'LABEL_REPEATED',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'LABEL_OPTIONAL' => 1,
    'LABEL_REQUIRED' => 2,
    'LABEL_REPEATED' => 3,
  ];
  public static function FromMixed(mixed $m): FieldDescriptorProto_Label_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FieldDescriptorProto_Label_enum_t {
    return $i;
  }
}

class FieldDescriptorProto implements \Protobuf\Message {
  public string $name;
  public int $number;
  public \google\protobuf\FieldDescriptorProto_Label_enum_t $label;
  public \google\protobuf\FieldDescriptorProto_Type_enum_t $type;
  public string $type_name;
  public string $extendee;
  public string $default_value;
  public int $oneof_index;
  public string $json_name;
  public ?\google\protobuf\FieldOptions $options;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'number' => int,
    ?'label' => \google\protobuf\FieldDescriptorProto_Label_enum_t,
    ?'type' => \google\protobuf\FieldDescriptorProto_Type_enum_t,
    ?'type_name' => string,
    ?'extendee' => string,
    ?'default_value' => string,
    ?'oneof_index' => int,
    ?'json_name' => string,
    ?'options' => ?\google\protobuf\FieldOptions,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->number = $s['number'] ?? 0;
    $this->label = $s['label'] ?? \google\protobuf\FieldDescriptorProto_Label::FromInt(0);
    $this->type = $s['type'] ?? \google\protobuf\FieldDescriptorProto_Type::FromInt(0);
    $this->type_name = $s['type_name'] ?? '';
    $this->extendee = $s['extendee'] ?? '';
    $this->default_value = $s['default_value'] ?? '';
    $this->oneof_index = $s['oneof_index'] ?? 0;
    $this->json_name = $s['json_name'] ?? '';
    $this->options = $s['options'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.FieldDescriptorProto";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $this->extendee = $d->readString();
          break;
        case 3:
          $this->number = $d->readVarint32Signed();
          break;
        case 4:
          $this->label = \google\protobuf\FieldDescriptorProto_Label::FromInt($d->readVarint());
          break;
        case 5:
          $this->type = \google\protobuf\FieldDescriptorProto_Type::FromInt($d->readVarint());
          break;
        case 6:
          $this->type_name = $d->readString();
          break;
        case 7:
          $this->default_value = $d->readString();
          break;
        case 8:
          if ($this->options == null) $this->options = new \google\protobuf\FieldOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 9:
          $this->oneof_index = $d->readVarint32Signed();
          break;
        case 10:
          $this->json_name = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->extendee !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->extendee);
    }
    if ($this->number !== 0) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->number);
    }
    if ($this->label !== \google\protobuf\FieldDescriptorProto_Label::FromInt(0)) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->label);
    }
    if ($this->type !== \google\protobuf\FieldDescriptorProto_Type::FromInt(0)) {
      $e->writeTag(5, 0);
      $e->writeVarint($this->type);
    }
    if ($this->type_name !== '') {
      $e->writeTag(6, 2);
      $e->writeString($this->type_name);
    }
    if ($this->default_value !== '') {
      $e->writeTag(7, 2);
      $e->writeString($this->default_value);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 8);
    }
    if ($this->oneof_index !== 0) {
      $e->writeTag(9, 0);
      $e->writeVarint($this->oneof_index);
    }
    if ($this->json_name !== '') {
      $e->writeTag(10, 2);
      $e->writeString($this->json_name);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeString('extendee', 'extendee', $this->extendee, false);
    $e->writeInt32('number', 'number', $this->number, false);
    $e->writeEnum('label', 'label', \google\protobuf\FieldDescriptorProto_Label::ToStringDict(), $this->label, false);
    $e->writeEnum('type', 'type', \google\protobuf\FieldDescriptorProto_Type::ToStringDict(), $this->type, false);
    $e->writeString('type_name', 'typeName', $this->type_name, false);
    $e->writeString('default_value', 'defaultValue', $this->default_value, false);
    $e->writeMessage('options', 'options', $this->options, false);
    $e->writeInt32('oneof_index', 'oneofIndex', $this->oneof_index, false);
    $e->writeString('json_name', 'jsonName', $this->json_name, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'extendee':
          $this->extendee = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'number':
          $this->number = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'label':
          $this->label = \google\protobuf\FieldDescriptorProto_Label::FromMixed($v);
          break;
        case 'type':
          $this->type = \google\protobuf\FieldDescriptorProto_Type::FromMixed($v);
          break;
        case 'type_name': case 'typeName':
          $this->type_name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'default_value': case 'defaultValue':
          $this->default_value = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\FieldOptions();
          $this->options->MergeJsonFrom($v);
          break;
        case 'oneof_index': case 'oneofIndex':
          $this->oneof_index = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'json_name': case 'jsonName':
          $this->json_name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FieldDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    $this->extendee = $o->extendee;
    $this->number = $o->number;
    $this->label = $o->label;
    $this->type = $o->type;
    $this->type_name = $o->type_name;
    $this->default_value = $o->default_value;
    $tmp = $o->options;
    if ($tmp !== null) {
      $nv = new \google\protobuf\FieldOptions();
      $nv->CopyFrom($tmp);
      $this->options = $nv;
    }
    $this->oneof_index = $o->oneof_index;
    $this->json_name = $o->json_name;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class OneofDescriptorProto implements \Protobuf\Message {
  public string $name;
  public ?\google\protobuf\OneofOptions $options;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'options' => ?\google\protobuf\OneofOptions,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->options = $s['options'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.OneofDescriptorProto";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          if ($this->options == null) $this->options = new \google\protobuf\OneofOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeMessage('options', 'options', $this->options, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\OneofOptions();
          $this->options->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is OneofDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    $tmp = $o->options;
    if ($tmp !== null) {
      $nv = new \google\protobuf\OneofOptions();
      $nv->CopyFrom($tmp);
      $this->options = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumDescriptorProto_EnumReservedRange implements \Protobuf\Message {
  public int $start;
  public int $end;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'start' => int,
    ?'end' => int,
  ) $s = shape()) {
    $this->start = $s['start'] ?? 0;
    $this->end = $s['end'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.EnumDescriptorProto.EnumReservedRange";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->start = $d->readVarint32Signed();
          break;
        case 2:
          $this->end = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->start !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->start);
    }
    if ($this->end !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->end);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('start', 'start', $this->start, false);
    $e->writeInt32('end', 'end', $this->end, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'start':
          $this->start = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumDescriptorProto_EnumReservedRange)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->start = $o->start;
    $this->end = $o->end;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumDescriptorProto implements \Protobuf\Message {
  public string $name;
  public vec<\google\protobuf\EnumValueDescriptorProto> $value;
  public ?\google\protobuf\EnumOptions $options;
  public vec<\google\protobuf\EnumDescriptorProto_EnumReservedRange> $reserved_range;
  public vec<string> $reserved_name;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'value' => vec<\google\protobuf\EnumValueDescriptorProto>,
    ?'options' => ?\google\protobuf\EnumOptions,
    ?'reserved_range' => vec<\google\protobuf\EnumDescriptorProto_EnumReservedRange>,
    ?'reserved_name' => vec<string>,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->value = $s['value'] ?? vec[];
    $this->options = $s['options'] ?? null;
    $this->reserved_range = $s['reserved_range'] ?? vec[];
    $this->reserved_name = $s['reserved_name'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.EnumDescriptorProto";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $obj = new \google\protobuf\EnumValueDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->value []= $obj;
          break;
        case 3:
          if ($this->options == null) $this->options = new \google\protobuf\EnumOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 4:
          $obj = new \google\protobuf\EnumDescriptorProto_EnumReservedRange();
          $obj->MergeFrom($d->readDecoder());
          $this->reserved_range []= $obj;
          break;
        case 5:
          $this->reserved_name []= $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->value as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
    foreach ($this->reserved_range as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    foreach ($this->reserved_name as $elem) {
      $e->writeTag(5, 2);
      $e->writeString($elem);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeMessageList('value', 'value', $this->value);
    $e->writeMessage('options', 'options', $this->options, false);
    $e->writeMessageList('reserved_range', 'reservedRange', $this->reserved_range);
    $e->writePrimitiveList('reserved_name', 'reservedName', $this->reserved_name);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumValueDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->value []= $obj;
          }
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\EnumOptions();
          $this->options->MergeJsonFrom($v);
          break;
        case 'reserved_range': case 'reservedRange':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumDescriptorProto_EnumReservedRange();
            $obj->MergeJsonFrom($vv);
            $this->reserved_range []= $obj;
          }
          break;
        case 'reserved_name': case 'reservedName':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->reserved_name []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    foreach ($o->value as $v) {
      $nv = new \google\protobuf\EnumValueDescriptorProto();
      $nv->CopyFrom($v);
      $this->value []= $nv;
    }
    $tmp = $o->options;
    if ($tmp !== null) {
      $nv = new \google\protobuf\EnumOptions();
      $nv->CopyFrom($tmp);
      $this->options = $nv;
    }
    foreach ($o->reserved_range as $v) {
      $nv = new \google\protobuf\EnumDescriptorProto_EnumReservedRange();
      $nv->CopyFrom($v);
      $this->reserved_range []= $nv;
    }
    $this->reserved_name = $o->reserved_name;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumValueDescriptorProto implements \Protobuf\Message {
  public string $name;
  public int $number;
  public ?\google\protobuf\EnumValueOptions $options;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'number' => int,
    ?'options' => ?\google\protobuf\EnumValueOptions,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->number = $s['number'] ?? 0;
    $this->options = $s['options'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.EnumValueDescriptorProto";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $this->number = $d->readVarint32Signed();
          break;
        case 3:
          if ($this->options == null) $this->options = new \google\protobuf\EnumValueOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->number !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->number);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeInt32('number', 'number', $this->number, false);
    $e->writeMessage('options', 'options', $this->options, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'number':
          $this->number = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\EnumValueOptions();
          $this->options->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumValueDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    $this->number = $o->number;
    $tmp = $o->options;
    if ($tmp !== null) {
      $nv = new \google\protobuf\EnumValueOptions();
      $nv->CopyFrom($tmp);
      $this->options = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class ServiceDescriptorProto implements \Protobuf\Message {
  public string $name;
  public vec<\google\protobuf\MethodDescriptorProto> $method;
  public ?\google\protobuf\ServiceOptions $options;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'method' => vec<\google\protobuf\MethodDescriptorProto>,
    ?'options' => ?\google\protobuf\ServiceOptions,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->method = $s['method'] ?? vec[];
    $this->options = $s['options'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.ServiceDescriptorProto";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $obj = new \google\protobuf\MethodDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->method []= $obj;
          break;
        case 3:
          if ($this->options == null) $this->options = new \google\protobuf\ServiceOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->method as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeMessageList('method', 'method', $this->method);
    $e->writeMessage('options', 'options', $this->options, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'method':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\MethodDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->method []= $obj;
          }
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\ServiceOptions();
          $this->options->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ServiceDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    foreach ($o->method as $v) {
      $nv = new \google\protobuf\MethodDescriptorProto();
      $nv->CopyFrom($v);
      $this->method []= $nv;
    }
    $tmp = $o->options;
    if ($tmp !== null) {
      $nv = new \google\protobuf\ServiceOptions();
      $nv->CopyFrom($tmp);
      $this->options = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class MethodDescriptorProto implements \Protobuf\Message {
  public string $name;
  public string $input_type;
  public string $output_type;
  public ?\google\protobuf\MethodOptions $options;
  public bool $client_streaming;
  public bool $server_streaming;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'input_type' => string,
    ?'output_type' => string,
    ?'options' => ?\google\protobuf\MethodOptions,
    ?'client_streaming' => bool,
    ?'server_streaming' => bool,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->input_type = $s['input_type'] ?? '';
    $this->output_type = $s['output_type'] ?? '';
    $this->options = $s['options'] ?? null;
    $this->client_streaming = $s['client_streaming'] ?? false;
    $this->server_streaming = $s['server_streaming'] ?? false;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.MethodDescriptorProto";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $this->input_type = $d->readString();
          break;
        case 3:
          $this->output_type = $d->readString();
          break;
        case 4:
          if ($this->options == null) $this->options = new \google\protobuf\MethodOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 5:
          $this->client_streaming = $d->readBool();
          break;
        case 6:
          $this->server_streaming = $d->readBool();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->input_type !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->input_type);
    }
    if ($this->output_type !== '') {
      $e->writeTag(3, 2);
      $e->writeString($this->output_type);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    if ($this->client_streaming !== false) {
      $e->writeTag(5, 0);
      $e->writeBool($this->client_streaming);
    }
    if ($this->server_streaming !== false) {
      $e->writeTag(6, 0);
      $e->writeBool($this->server_streaming);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeString('input_type', 'inputType', $this->input_type, false);
    $e->writeString('output_type', 'outputType', $this->output_type, false);
    $e->writeMessage('options', 'options', $this->options, false);
    $e->writeBool('client_streaming', 'clientStreaming', $this->client_streaming, false);
    $e->writeBool('server_streaming', 'serverStreaming', $this->server_streaming, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'input_type': case 'inputType':
          $this->input_type = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'output_type': case 'outputType':
          $this->output_type = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\MethodOptions();
          $this->options->MergeJsonFrom($v);
          break;
        case 'client_streaming': case 'clientStreaming':
          $this->client_streaming = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'server_streaming': case 'serverStreaming':
          $this->server_streaming = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is MethodDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    $this->input_type = $o->input_type;
    $this->output_type = $o->output_type;
    $tmp = $o->options;
    if ($tmp !== null) {
      $nv = new \google\protobuf\MethodOptions();
      $nv->CopyFrom($tmp);
      $this->options = $nv;
    }
    $this->client_streaming = $o->client_streaming;
    $this->server_streaming = $o->server_streaming;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype FileOptions_OptimizeMode_enum_t as int = int;
abstract class FileOptions_OptimizeMode {
  const FileOptions_OptimizeMode_enum_t SPEED = 1;
  const FileOptions_OptimizeMode_enum_t CODE_SIZE = 2;
  const FileOptions_OptimizeMode_enum_t LITE_RUNTIME = 3;
  private static dict<int, string> $itos = dict[
    1 => 'SPEED',
    2 => 'CODE_SIZE',
    3 => 'LITE_RUNTIME',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'SPEED' => 1,
    'CODE_SIZE' => 2,
    'LITE_RUNTIME' => 3,
  ];
  public static function FromMixed(mixed $m): FileOptions_OptimizeMode_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FileOptions_OptimizeMode_enum_t {
    return $i;
  }
}

class FileOptions implements \Protobuf\Message {
  public string $java_package;
  public string $java_outer_classname;
  public bool $java_multiple_files;
  public bool $java_generate_equals_and_hash;
  public bool $java_string_check_utf8;
  public \google\protobuf\FileOptions_OptimizeMode_enum_t $optimize_for;
  public string $go_package;
  public bool $cc_generic_services;
  public bool $java_generic_services;
  public bool $py_generic_services;
  public bool $php_generic_services;
  public bool $deprecated;
  public bool $cc_enable_arenas;
  public string $objc_class_prefix;
  public string $csharp_namespace;
  public string $swift_prefix;
  public string $php_class_prefix;
  public string $php_namespace;
  public string $php_metadata_namespace;
  public string $ruby_package;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'java_package' => string,
    ?'java_outer_classname' => string,
    ?'java_multiple_files' => bool,
    ?'java_generate_equals_and_hash' => bool,
    ?'java_string_check_utf8' => bool,
    ?'optimize_for' => \google\protobuf\FileOptions_OptimizeMode_enum_t,
    ?'go_package' => string,
    ?'cc_generic_services' => bool,
    ?'java_generic_services' => bool,
    ?'py_generic_services' => bool,
    ?'php_generic_services' => bool,
    ?'deprecated' => bool,
    ?'cc_enable_arenas' => bool,
    ?'objc_class_prefix' => string,
    ?'csharp_namespace' => string,
    ?'swift_prefix' => string,
    ?'php_class_prefix' => string,
    ?'php_namespace' => string,
    ?'php_metadata_namespace' => string,
    ?'ruby_package' => string,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    $this->java_package = $s['java_package'] ?? '';
    $this->java_outer_classname = $s['java_outer_classname'] ?? '';
    $this->java_multiple_files = $s['java_multiple_files'] ?? false;
    $this->java_generate_equals_and_hash = $s['java_generate_equals_and_hash'] ?? false;
    $this->java_string_check_utf8 = $s['java_string_check_utf8'] ?? false;
    $this->optimize_for = $s['optimize_for'] ?? \google\protobuf\FileOptions_OptimizeMode::FromInt(0);
    $this->go_package = $s['go_package'] ?? '';
    $this->cc_generic_services = $s['cc_generic_services'] ?? false;
    $this->java_generic_services = $s['java_generic_services'] ?? false;
    $this->py_generic_services = $s['py_generic_services'] ?? false;
    $this->php_generic_services = $s['php_generic_services'] ?? false;
    $this->deprecated = $s['deprecated'] ?? false;
    $this->cc_enable_arenas = $s['cc_enable_arenas'] ?? false;
    $this->objc_class_prefix = $s['objc_class_prefix'] ?? '';
    $this->csharp_namespace = $s['csharp_namespace'] ?? '';
    $this->swift_prefix = $s['swift_prefix'] ?? '';
    $this->php_class_prefix = $s['php_class_prefix'] ?? '';
    $this->php_namespace = $s['php_namespace'] ?? '';
    $this->php_metadata_namespace = $s['php_metadata_namespace'] ?? '';
    $this->ruby_package = $s['ruby_package'] ?? '';
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.FileOptions";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->java_package = $d->readString();
          break;
        case 8:
          $this->java_outer_classname = $d->readString();
          break;
        case 9:
          $this->optimize_for = \google\protobuf\FileOptions_OptimizeMode::FromInt($d->readVarint());
          break;
        case 10:
          $this->java_multiple_files = $d->readBool();
          break;
        case 11:
          $this->go_package = $d->readString();
          break;
        case 16:
          $this->cc_generic_services = $d->readBool();
          break;
        case 17:
          $this->java_generic_services = $d->readBool();
          break;
        case 18:
          $this->py_generic_services = $d->readBool();
          break;
        case 20:
          $this->java_generate_equals_and_hash = $d->readBool();
          break;
        case 23:
          $this->deprecated = $d->readBool();
          break;
        case 27:
          $this->java_string_check_utf8 = $d->readBool();
          break;
        case 31:
          $this->cc_enable_arenas = $d->readBool();
          break;
        case 36:
          $this->objc_class_prefix = $d->readString();
          break;
        case 37:
          $this->csharp_namespace = $d->readString();
          break;
        case 39:
          $this->swift_prefix = $d->readString();
          break;
        case 40:
          $this->php_class_prefix = $d->readString();
          break;
        case 41:
          $this->php_namespace = $d->readString();
          break;
        case 42:
          $this->php_generic_services = $d->readBool();
          break;
        case 44:
          $this->php_metadata_namespace = $d->readString();
          break;
        case 45:
          $this->ruby_package = $d->readString();
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->java_package !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->java_package);
    }
    if ($this->java_outer_classname !== '') {
      $e->writeTag(8, 2);
      $e->writeString($this->java_outer_classname);
    }
    if ($this->optimize_for !== \google\protobuf\FileOptions_OptimizeMode::FromInt(0)) {
      $e->writeTag(9, 0);
      $e->writeVarint($this->optimize_for);
    }
    if ($this->java_multiple_files !== false) {
      $e->writeTag(10, 0);
      $e->writeBool($this->java_multiple_files);
    }
    if ($this->go_package !== '') {
      $e->writeTag(11, 2);
      $e->writeString($this->go_package);
    }
    if ($this->cc_generic_services !== false) {
      $e->writeTag(16, 0);
      $e->writeBool($this->cc_generic_services);
    }
    if ($this->java_generic_services !== false) {
      $e->writeTag(17, 0);
      $e->writeBool($this->java_generic_services);
    }
    if ($this->py_generic_services !== false) {
      $e->writeTag(18, 0);
      $e->writeBool($this->py_generic_services);
    }
    if ($this->java_generate_equals_and_hash !== false) {
      $e->writeTag(20, 0);
      $e->writeBool($this->java_generate_equals_and_hash);
    }
    if ($this->deprecated !== false) {
      $e->writeTag(23, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->java_string_check_utf8 !== false) {
      $e->writeTag(27, 0);
      $e->writeBool($this->java_string_check_utf8);
    }
    if ($this->cc_enable_arenas !== false) {
      $e->writeTag(31, 0);
      $e->writeBool($this->cc_enable_arenas);
    }
    if ($this->objc_class_prefix !== '') {
      $e->writeTag(36, 2);
      $e->writeString($this->objc_class_prefix);
    }
    if ($this->csharp_namespace !== '') {
      $e->writeTag(37, 2);
      $e->writeString($this->csharp_namespace);
    }
    if ($this->swift_prefix !== '') {
      $e->writeTag(39, 2);
      $e->writeString($this->swift_prefix);
    }
    if ($this->php_class_prefix !== '') {
      $e->writeTag(40, 2);
      $e->writeString($this->php_class_prefix);
    }
    if ($this->php_namespace !== '') {
      $e->writeTag(41, 2);
      $e->writeString($this->php_namespace);
    }
    if ($this->php_generic_services !== false) {
      $e->writeTag(42, 0);
      $e->writeBool($this->php_generic_services);
    }
    if ($this->php_metadata_namespace !== '') {
      $e->writeTag(44, 2);
      $e->writeString($this->php_metadata_namespace);
    }
    if ($this->ruby_package !== '') {
      $e->writeTag(45, 2);
      $e->writeString($this->ruby_package);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('java_package', 'javaPackage', $this->java_package, false);
    $e->writeString('java_outer_classname', 'javaOuterClassname', $this->java_outer_classname, false);
    $e->writeEnum('optimize_for', 'optimizeFor', \google\protobuf\FileOptions_OptimizeMode::ToStringDict(), $this->optimize_for, false);
    $e->writeBool('java_multiple_files', 'javaMultipleFiles', $this->java_multiple_files, false);
    $e->writeString('go_package', 'goPackage', $this->go_package, false);
    $e->writeBool('cc_generic_services', 'ccGenericServices', $this->cc_generic_services, false);
    $e->writeBool('java_generic_services', 'javaGenericServices', $this->java_generic_services, false);
    $e->writeBool('py_generic_services', 'pyGenericServices', $this->py_generic_services, false);
    $e->writeBool('java_generate_equals_and_hash', 'javaGenerateEqualsAndHash', $this->java_generate_equals_and_hash, false);
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeBool('java_string_check_utf8', 'javaStringCheckUtf8', $this->java_string_check_utf8, false);
    $e->writeBool('cc_enable_arenas', 'ccEnableArenas', $this->cc_enable_arenas, false);
    $e->writeString('objc_class_prefix', 'objcClassPrefix', $this->objc_class_prefix, false);
    $e->writeString('csharp_namespace', 'csharpNamespace', $this->csharp_namespace, false);
    $e->writeString('swift_prefix', 'swiftPrefix', $this->swift_prefix, false);
    $e->writeString('php_class_prefix', 'phpClassPrefix', $this->php_class_prefix, false);
    $e->writeString('php_namespace', 'phpNamespace', $this->php_namespace, false);
    $e->writeBool('php_generic_services', 'phpGenericServices', $this->php_generic_services, false);
    $e->writeString('php_metadata_namespace', 'phpMetadataNamespace', $this->php_metadata_namespace, false);
    $e->writeString('ruby_package', 'rubyPackage', $this->ruby_package, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'java_package': case 'javaPackage':
          $this->java_package = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'java_outer_classname': case 'javaOuterClassname':
          $this->java_outer_classname = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'optimize_for': case 'optimizeFor':
          $this->optimize_for = \google\protobuf\FileOptions_OptimizeMode::FromMixed($v);
          break;
        case 'java_multiple_files': case 'javaMultipleFiles':
          $this->java_multiple_files = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'go_package': case 'goPackage':
          $this->go_package = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'cc_generic_services': case 'ccGenericServices':
          $this->cc_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'java_generic_services': case 'javaGenericServices':
          $this->java_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'py_generic_services': case 'pyGenericServices':
          $this->py_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'java_generate_equals_and_hash': case 'javaGenerateEqualsAndHash':
          $this->java_generate_equals_and_hash = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'java_string_check_utf8': case 'javaStringCheckUtf8':
          $this->java_string_check_utf8 = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'cc_enable_arenas': case 'ccEnableArenas':
          $this->cc_enable_arenas = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'objc_class_prefix': case 'objcClassPrefix':
          $this->objc_class_prefix = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'csharp_namespace': case 'csharpNamespace':
          $this->csharp_namespace = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'swift_prefix': case 'swiftPrefix':
          $this->swift_prefix = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'php_class_prefix': case 'phpClassPrefix':
          $this->php_class_prefix = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'php_namespace': case 'phpNamespace':
          $this->php_namespace = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'php_generic_services': case 'phpGenericServices':
          $this->php_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'php_metadata_namespace': case 'phpMetadataNamespace':
          $this->php_metadata_namespace = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'ruby_package': case 'rubyPackage':
          $this->ruby_package = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FileOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->java_package = $o->java_package;
    $this->java_outer_classname = $o->java_outer_classname;
    $this->optimize_for = $o->optimize_for;
    $this->java_multiple_files = $o->java_multiple_files;
    $this->go_package = $o->go_package;
    $this->cc_generic_services = $o->cc_generic_services;
    $this->java_generic_services = $o->java_generic_services;
    $this->py_generic_services = $o->py_generic_services;
    $this->java_generate_equals_and_hash = $o->java_generate_equals_and_hash;
    $this->deprecated = $o->deprecated;
    $this->java_string_check_utf8 = $o->java_string_check_utf8;
    $this->cc_enable_arenas = $o->cc_enable_arenas;
    $this->objc_class_prefix = $o->objc_class_prefix;
    $this->csharp_namespace = $o->csharp_namespace;
    $this->swift_prefix = $o->swift_prefix;
    $this->php_class_prefix = $o->php_class_prefix;
    $this->php_namespace = $o->php_namespace;
    $this->php_generic_services = $o->php_generic_services;
    $this->php_metadata_namespace = $o->php_metadata_namespace;
    $this->ruby_package = $o->ruby_package;
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class MessageOptions implements \Protobuf\Message {
  public bool $message_set_wire_format;
  public bool $no_standard_descriptor_accessor;
  public bool $deprecated;
  public bool $map_entry;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'message_set_wire_format' => bool,
    ?'no_standard_descriptor_accessor' => bool,
    ?'deprecated' => bool,
    ?'map_entry' => bool,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    $this->message_set_wire_format = $s['message_set_wire_format'] ?? false;
    $this->no_standard_descriptor_accessor = $s['no_standard_descriptor_accessor'] ?? false;
    $this->deprecated = $s['deprecated'] ?? false;
    $this->map_entry = $s['map_entry'] ?? false;
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.MessageOptions";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->message_set_wire_format = $d->readBool();
          break;
        case 2:
          $this->no_standard_descriptor_accessor = $d->readBool();
          break;
        case 3:
          $this->deprecated = $d->readBool();
          break;
        case 7:
          $this->map_entry = $d->readBool();
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->message_set_wire_format !== false) {
      $e->writeTag(1, 0);
      $e->writeBool($this->message_set_wire_format);
    }
    if ($this->no_standard_descriptor_accessor !== false) {
      $e->writeTag(2, 0);
      $e->writeBool($this->no_standard_descriptor_accessor);
    }
    if ($this->deprecated !== false) {
      $e->writeTag(3, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->map_entry !== false) {
      $e->writeTag(7, 0);
      $e->writeBool($this->map_entry);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('message_set_wire_format', 'messageSetWireFormat', $this->message_set_wire_format, false);
    $e->writeBool('no_standard_descriptor_accessor', 'noStandardDescriptorAccessor', $this->no_standard_descriptor_accessor, false);
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeBool('map_entry', 'mapEntry', $this->map_entry, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'message_set_wire_format': case 'messageSetWireFormat':
          $this->message_set_wire_format = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'no_standard_descriptor_accessor': case 'noStandardDescriptorAccessor':
          $this->no_standard_descriptor_accessor = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'map_entry': case 'mapEntry':
          $this->map_entry = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is MessageOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->message_set_wire_format = $o->message_set_wire_format;
    $this->no_standard_descriptor_accessor = $o->no_standard_descriptor_accessor;
    $this->deprecated = $o->deprecated;
    $this->map_entry = $o->map_entry;
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype FieldOptions_CType_enum_t as int = int;
abstract class FieldOptions_CType {
  const FieldOptions_CType_enum_t STRING = 0;
  const FieldOptions_CType_enum_t CORD = 1;
  const FieldOptions_CType_enum_t STRING_PIECE = 2;
  private static dict<int, string> $itos = dict[
    0 => 'STRING',
    1 => 'CORD',
    2 => 'STRING_PIECE',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'STRING' => 0,
    'CORD' => 1,
    'STRING_PIECE' => 2,
  ];
  public static function FromMixed(mixed $m): FieldOptions_CType_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FieldOptions_CType_enum_t {
    return $i;
  }
}

newtype FieldOptions_JSType_enum_t as int = int;
abstract class FieldOptions_JSType {
  const FieldOptions_JSType_enum_t JS_NORMAL = 0;
  const FieldOptions_JSType_enum_t JS_STRING = 1;
  const FieldOptions_JSType_enum_t JS_NUMBER = 2;
  private static dict<int, string> $itos = dict[
    0 => 'JS_NORMAL',
    1 => 'JS_STRING',
    2 => 'JS_NUMBER',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'JS_NORMAL' => 0,
    'JS_STRING' => 1,
    'JS_NUMBER' => 2,
  ];
  public static function FromMixed(mixed $m): FieldOptions_JSType_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FieldOptions_JSType_enum_t {
    return $i;
  }
}

class FieldOptions implements \Protobuf\Message {
  public \google\protobuf\FieldOptions_CType_enum_t $ctype;
  public bool $packed;
  public \google\protobuf\FieldOptions_JSType_enum_t $jstype;
  public bool $lazy;
  public bool $deprecated;
  public bool $weak;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'ctype' => \google\protobuf\FieldOptions_CType_enum_t,
    ?'packed' => bool,
    ?'jstype' => \google\protobuf\FieldOptions_JSType_enum_t,
    ?'lazy' => bool,
    ?'deprecated' => bool,
    ?'weak' => bool,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    $this->ctype = $s['ctype'] ?? \google\protobuf\FieldOptions_CType::FromInt(0);
    $this->packed = $s['packed'] ?? false;
    $this->jstype = $s['jstype'] ?? \google\protobuf\FieldOptions_JSType::FromInt(0);
    $this->lazy = $s['lazy'] ?? false;
    $this->deprecated = $s['deprecated'] ?? false;
    $this->weak = $s['weak'] ?? false;
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.FieldOptions";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->ctype = \google\protobuf\FieldOptions_CType::FromInt($d->readVarint());
          break;
        case 2:
          $this->packed = $d->readBool();
          break;
        case 3:
          $this->deprecated = $d->readBool();
          break;
        case 5:
          $this->lazy = $d->readBool();
          break;
        case 6:
          $this->jstype = \google\protobuf\FieldOptions_JSType::FromInt($d->readVarint());
          break;
        case 10:
          $this->weak = $d->readBool();
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->ctype !== \google\protobuf\FieldOptions_CType::FromInt(0)) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->ctype);
    }
    if ($this->packed !== false) {
      $e->writeTag(2, 0);
      $e->writeBool($this->packed);
    }
    if ($this->deprecated !== false) {
      $e->writeTag(3, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->lazy !== false) {
      $e->writeTag(5, 0);
      $e->writeBool($this->lazy);
    }
    if ($this->jstype !== \google\protobuf\FieldOptions_JSType::FromInt(0)) {
      $e->writeTag(6, 0);
      $e->writeVarint($this->jstype);
    }
    if ($this->weak !== false) {
      $e->writeTag(10, 0);
      $e->writeBool($this->weak);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeEnum('ctype', 'ctype', \google\protobuf\FieldOptions_CType::ToStringDict(), $this->ctype, false);
    $e->writeBool('packed', 'packed', $this->packed, false);
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeBool('lazy', 'lazy', $this->lazy, false);
    $e->writeEnum('jstype', 'jstype', \google\protobuf\FieldOptions_JSType::ToStringDict(), $this->jstype, false);
    $e->writeBool('weak', 'weak', $this->weak, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'ctype':
          $this->ctype = \google\protobuf\FieldOptions_CType::FromMixed($v);
          break;
        case 'packed':
          $this->packed = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'lazy':
          $this->lazy = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'jstype':
          $this->jstype = \google\protobuf\FieldOptions_JSType::FromMixed($v);
          break;
        case 'weak':
          $this->weak = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FieldOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->ctype = $o->ctype;
    $this->packed = $o->packed;
    $this->deprecated = $o->deprecated;
    $this->lazy = $o->lazy;
    $this->jstype = $o->jstype;
    $this->weak = $o->weak;
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class OneofOptions implements \Protobuf\Message {
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.OneofOptions";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is OneofOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumOptions implements \Protobuf\Message {
  public bool $allow_alias;
  public bool $deprecated;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'allow_alias' => bool,
    ?'deprecated' => bool,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    $this->allow_alias = $s['allow_alias'] ?? false;
    $this->deprecated = $s['deprecated'] ?? false;
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.EnumOptions";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 2:
          $this->allow_alias = $d->readBool();
          break;
        case 3:
          $this->deprecated = $d->readBool();
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->allow_alias !== false) {
      $e->writeTag(2, 0);
      $e->writeBool($this->allow_alias);
    }
    if ($this->deprecated !== false) {
      $e->writeTag(3, 0);
      $e->writeBool($this->deprecated);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('allow_alias', 'allowAlias', $this->allow_alias, false);
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'allow_alias': case 'allowAlias':
          $this->allow_alias = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->allow_alias = $o->allow_alias;
    $this->deprecated = $o->deprecated;
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumValueOptions implements \Protobuf\Message {
  public bool $deprecated;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'deprecated' => bool,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    $this->deprecated = $s['deprecated'] ?? false;
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.EnumValueOptions";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->deprecated = $d->readBool();
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->deprecated !== false) {
      $e->writeTag(1, 0);
      $e->writeBool($this->deprecated);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumValueOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->deprecated = $o->deprecated;
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class ServiceOptions implements \Protobuf\Message {
  public bool $deprecated;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'deprecated' => bool,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    $this->deprecated = $s['deprecated'] ?? false;
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.ServiceOptions";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 33:
          $this->deprecated = $d->readBool();
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->deprecated !== false) {
      $e->writeTag(33, 0);
      $e->writeBool($this->deprecated);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ServiceOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->deprecated = $o->deprecated;
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype MethodOptions_IdempotencyLevel_enum_t as int = int;
abstract class MethodOptions_IdempotencyLevel {
  const MethodOptions_IdempotencyLevel_enum_t IDEMPOTENCY_UNKNOWN = 0;
  const MethodOptions_IdempotencyLevel_enum_t NO_SIDE_EFFECTS = 1;
  const MethodOptions_IdempotencyLevel_enum_t IDEMPOTENT = 2;
  private static dict<int, string> $itos = dict[
    0 => 'IDEMPOTENCY_UNKNOWN',
    1 => 'NO_SIDE_EFFECTS',
    2 => 'IDEMPOTENT',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'IDEMPOTENCY_UNKNOWN' => 0,
    'NO_SIDE_EFFECTS' => 1,
    'IDEMPOTENT' => 2,
  ];
  public static function FromMixed(mixed $m): MethodOptions_IdempotencyLevel_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): MethodOptions_IdempotencyLevel_enum_t {
    return $i;
  }
}

class MethodOptions implements \Protobuf\Message {
  public bool $deprecated;
  public \google\protobuf\MethodOptions_IdempotencyLevel_enum_t $idempotency_level;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'deprecated' => bool,
    ?'idempotency_level' => \google\protobuf\MethodOptions_IdempotencyLevel_enum_t,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    $this->deprecated = $s['deprecated'] ?? false;
    $this->idempotency_level = $s['idempotency_level'] ?? \google\protobuf\MethodOptions_IdempotencyLevel::FromInt(0);
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.MethodOptions";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 33:
          $this->deprecated = $d->readBool();
          break;
        case 34:
          $this->idempotency_level = \google\protobuf\MethodOptions_IdempotencyLevel::FromInt($d->readVarint());
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->deprecated !== false) {
      $e->writeTag(33, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->idempotency_level !== \google\protobuf\MethodOptions_IdempotencyLevel::FromInt(0)) {
      $e->writeTag(34, 0);
      $e->writeVarint($this->idempotency_level);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeEnum('idempotency_level', 'idempotencyLevel', \google\protobuf\MethodOptions_IdempotencyLevel::ToStringDict(), $this->idempotency_level, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'idempotency_level': case 'idempotencyLevel':
          $this->idempotency_level = \google\protobuf\MethodOptions_IdempotencyLevel::FromMixed($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is MethodOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->deprecated = $o->deprecated;
    $this->idempotency_level = $o->idempotency_level;
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class UninterpretedOption_NamePart implements \Protobuf\Message {
  public string $name_part;
  public bool $is_extension;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name_part' => string,
    ?'is_extension' => bool,
  ) $s = shape()) {
    $this->name_part = $s['name_part'] ?? '';
    $this->is_extension = $s['is_extension'] ?? false;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.UninterpretedOption.NamePart";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name_part = $d->readString();
          break;
        case 2:
          $this->is_extension = $d->readBool();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name_part !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name_part);
    }
    if ($this->is_extension !== false) {
      $e->writeTag(2, 0);
      $e->writeBool($this->is_extension);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name_part', 'namePart', $this->name_part, false);
    $e->writeBool('is_extension', 'isExtension', $this->is_extension, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name_part': case 'namePart':
          $this->name_part = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'is_extension': case 'isExtension':
          $this->is_extension = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is UninterpretedOption_NamePart)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name_part = $o->name_part;
    $this->is_extension = $o->is_extension;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class UninterpretedOption implements \Protobuf\Message {
  public vec<\google\protobuf\UninterpretedOption_NamePart> $name;
  public string $identifier_value;
  public int $positive_int_value;
  public int $negative_int_value;
  public float $double_value;
  public string $string_value;
  public string $aggregate_value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => vec<\google\protobuf\UninterpretedOption_NamePart>,
    ?'identifier_value' => string,
    ?'positive_int_value' => int,
    ?'negative_int_value' => int,
    ?'double_value' => float,
    ?'string_value' => string,
    ?'aggregate_value' => string,
  ) $s = shape()) {
    $this->name = $s['name'] ?? vec[];
    $this->identifier_value = $s['identifier_value'] ?? '';
    $this->positive_int_value = $s['positive_int_value'] ?? 0;
    $this->negative_int_value = $s['negative_int_value'] ?? 0;
    $this->double_value = $s['double_value'] ?? 0.0;
    $this->string_value = $s['string_value'] ?? '';
    $this->aggregate_value = $s['aggregate_value'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.UninterpretedOption";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 2:
          $obj = new \google\protobuf\UninterpretedOption_NamePart();
          $obj->MergeFrom($d->readDecoder());
          $this->name []= $obj;
          break;
        case 3:
          $this->identifier_value = $d->readString();
          break;
        case 4:
          $this->positive_int_value = $d->readVarint();
          break;
        case 5:
          $this->negative_int_value = $d->readVarint();
          break;
        case 6:
          $this->double_value = $d->readDouble();
          break;
        case 7:
          $this->string_value = $d->readString();
          break;
        case 8:
          $this->aggregate_value = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->name as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    if ($this->identifier_value !== '') {
      $e->writeTag(3, 2);
      $e->writeString($this->identifier_value);
    }
    if ($this->positive_int_value !== 0) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->positive_int_value);
    }
    if ($this->negative_int_value !== 0) {
      $e->writeTag(5, 0);
      $e->writeVarint($this->negative_int_value);
    }
    if ($this->double_value !== 0.0) {
      $e->writeTag(6, 1);
      $e->writeDouble($this->double_value);
    }
    if ($this->string_value !== '') {
      $e->writeTag(7, 2);
      $e->writeString($this->string_value);
    }
    if ($this->aggregate_value !== '') {
      $e->writeTag(8, 2);
      $e->writeString($this->aggregate_value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('name', 'name', $this->name);
    $e->writeString('identifier_value', 'identifierValue', $this->identifier_value, false);
    $e->writeInt64Unsigned('positive_int_value', 'positiveIntValue', $this->positive_int_value, false);
    $e->writeInt64Signed('negative_int_value', 'negativeIntValue', $this->negative_int_value, false);
    $e->writeFloat('double_value', 'doubleValue', $this->double_value, false);
    $e->writeBytes('string_value', 'stringValue', $this->string_value, false);
    $e->writeString('aggregate_value', 'aggregateValue', $this->aggregate_value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption_NamePart();
            $obj->MergeJsonFrom($vv);
            $this->name []= $obj;
          }
          break;
        case 'identifier_value': case 'identifierValue':
          $this->identifier_value = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'positive_int_value': case 'positiveIntValue':
          $this->positive_int_value = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'negative_int_value': case 'negativeIntValue':
          $this->negative_int_value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'double_value': case 'doubleValue':
          $this->double_value = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        case 'string_value': case 'stringValue':
          $this->string_value = \Protobuf\Internal\JsonDecoder::readBytes($v);
          break;
        case 'aggregate_value': case 'aggregateValue':
          $this->aggregate_value = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is UninterpretedOption)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->name as $v) {
      $nv = new \google\protobuf\UninterpretedOption_NamePart();
      $nv->CopyFrom($v);
      $this->name []= $nv;
    }
    $this->identifier_value = $o->identifier_value;
    $this->positive_int_value = $o->positive_int_value;
    $this->negative_int_value = $o->negative_int_value;
    $this->double_value = $o->double_value;
    $this->string_value = $o->string_value;
    $this->aggregate_value = $o->aggregate_value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class SourceCodeInfo_Location implements \Protobuf\Message {
  public vec<int> $path;
  public vec<int> $span;
  public string $leading_comments;
  public string $trailing_comments;
  public vec<string> $leading_detached_comments;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'path' => vec<int>,
    ?'span' => vec<int>,
    ?'leading_comments' => string,
    ?'trailing_comments' => string,
    ?'leading_detached_comments' => vec<string>,
  ) $s = shape()) {
    $this->path = $s['path'] ?? vec[];
    $this->span = $s['span'] ?? vec[];
    $this->leading_comments = $s['leading_comments'] ?? '';
    $this->trailing_comments = $s['trailing_comments'] ?? '';
    $this->leading_detached_comments = $s['leading_detached_comments'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.SourceCodeInfo.Location";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->path []= $packed->readVarint32Signed();
            }
          } else {
            $this->path []= $d->readVarint32Signed();
          }
          break;
        case 2:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->span []= $packed->readVarint32Signed();
            }
          } else {
            $this->span []= $d->readVarint32Signed();
          }
          break;
        case 3:
          $this->leading_comments = $d->readString();
          break;
        case 4:
          $this->trailing_comments = $d->readString();
          break;
        case 6:
          $this->leading_detached_comments []= $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->path as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 1);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->span as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 2);
    if ($this->leading_comments !== '') {
      $e->writeTag(3, 2);
      $e->writeString($this->leading_comments);
    }
    if ($this->trailing_comments !== '') {
      $e->writeTag(4, 2);
      $e->writeString($this->trailing_comments);
    }
    foreach ($this->leading_detached_comments as $elem) {
      $e->writeTag(6, 2);
      $e->writeString($elem);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writePrimitiveList('path', 'path', $this->path);
    $e->writePrimitiveList('span', 'span', $this->span);
    $e->writeString('leading_comments', 'leadingComments', $this->leading_comments, false);
    $e->writeString('trailing_comments', 'trailingComments', $this->trailing_comments, false);
    $e->writePrimitiveList('leading_detached_comments', 'leadingDetachedComments', $this->leading_detached_comments);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'path':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->path []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'span':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->span []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'leading_comments': case 'leadingComments':
          $this->leading_comments = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'trailing_comments': case 'trailingComments':
          $this->trailing_comments = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'leading_detached_comments': case 'leadingDetachedComments':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->leading_detached_comments []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is SourceCodeInfo_Location)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->path = $o->path;
    $this->span = $o->span;
    $this->leading_comments = $o->leading_comments;
    $this->trailing_comments = $o->trailing_comments;
    $this->leading_detached_comments = $o->leading_detached_comments;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class SourceCodeInfo implements \Protobuf\Message {
  public vec<\google\protobuf\SourceCodeInfo_Location> $location;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'location' => vec<\google\protobuf\SourceCodeInfo_Location>,
  ) $s = shape()) {
    $this->location = $s['location'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.SourceCodeInfo";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\SourceCodeInfo_Location();
          $obj->MergeFrom($d->readDecoder());
          $this->location []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->location as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('location', 'location', $this->location);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'location':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\SourceCodeInfo_Location();
            $obj->MergeJsonFrom($vv);
            $this->location []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is SourceCodeInfo)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->location as $v) {
      $nv = new \google\protobuf\SourceCodeInfo_Location();
      $nv->CopyFrom($v);
      $this->location []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class GeneratedCodeInfo_Annotation implements \Protobuf\Message {
  public vec<int> $path;
  public string $source_file;
  public int $begin;
  public int $end;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'path' => vec<int>,
    ?'source_file' => string,
    ?'begin' => int,
    ?'end' => int,
  ) $s = shape()) {
    $this->path = $s['path'] ?? vec[];
    $this->source_file = $s['source_file'] ?? '';
    $this->begin = $s['begin'] ?? 0;
    $this->end = $s['end'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.GeneratedCodeInfo.Annotation";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->path []= $packed->readVarint32Signed();
            }
          } else {
            $this->path []= $d->readVarint32Signed();
          }
          break;
        case 2:
          $this->source_file = $d->readString();
          break;
        case 3:
          $this->begin = $d->readVarint32Signed();
          break;
        case 4:
          $this->end = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->path as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 1);
    if ($this->source_file !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->source_file);
    }
    if ($this->begin !== 0) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->begin);
    }
    if ($this->end !== 0) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->end);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writePrimitiveList('path', 'path', $this->path);
    $e->writeString('source_file', 'sourceFile', $this->source_file, false);
    $e->writeInt32('begin', 'begin', $this->begin, false);
    $e->writeInt32('end', 'end', $this->end, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'path':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->path []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'source_file': case 'sourceFile':
          $this->source_file = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'begin':
          $this->begin = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is GeneratedCodeInfo_Annotation)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->path = $o->path;
    $this->source_file = $o->source_file;
    $this->begin = $o->begin;
    $this->end = $o->end;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class GeneratedCodeInfo implements \Protobuf\Message {
  public vec<\google\protobuf\GeneratedCodeInfo_Annotation> $annotation;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'annotation' => vec<\google\protobuf\GeneratedCodeInfo_Annotation>,
  ) $s = shape()) {
    $this->annotation = $s['annotation'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.GeneratedCodeInfo";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\GeneratedCodeInfo_Annotation();
          $obj->MergeFrom($d->readDecoder());
          $this->annotation []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->annotation as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('annotation', 'annotation', $this->annotation);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'annotation':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\GeneratedCodeInfo_Annotation();
            $obj->MergeJsonFrom($vv);
            $this->annotation []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is GeneratedCodeInfo)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->annotation as $v) {
      $nv = new \google\protobuf\GeneratedCodeInfo_Annotation();
      $nv->CopyFrom($v);
      $this->annotation []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}


class XXX_FileDescriptor_test_descriptor__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'test/descriptor.proto';
  const string RAW =
  'eNrEWd2O28YVDvW30pFWOzu7tunNj9fKj9dOrA0c23HWRVqtRG/k7koqpW1+gIKYJUcSbY'
  .'pkSMr2Br0w0KteFehVURS96E2APkCB3vUJCuQNirZA+wi9LGaGpEhJG28CJLmS5jvfOXPm'
  .'zJmZM0O4EFA/2DWor3umGzhe3fWcwMFrI8cZWVS0TqbD2hGsPzAt2oqJfRrge5AbmhaVpe'
  .'3sTvnWG/U5pXpao8dglWvU/p2DjSVSjCFnkwmzKO2UVP4fy7DiEv0xGVE5w+GoiV8DMKhL'
  .'bYPa+qmc3c7ulNQEgt+GdXd6Ypm6lqDBdnYnryIhaM3I12DtKSWPk9Qyp1YZnCA2oTKhvk'
  .'9GVAtOXSrn+Oi3F0Y/P/JyqDU4dSluQIna04mwkD8jfoo9ncxbKTK10MSKT70npk7lAjdw'
  .'bcFAX8jnbUR6uAkl+iygtm86trzCjby5ZBapZcybmOnhu7DiuIHp2L5c3JZ2yrdeWZoIXc'
  .'FRIzJuA/KdqadTTXcMqpn20JFL3MCVxYFwYtMxaNseOmrVT7XxRSj4p3ZAnskVniFhq/bX'
  .'AqydJ8XuQ37IRilnvkkMhE46iIVvGcQGlG3qB9QQGZE9Z06BUFpMqdy3SqlPYC12SfOIPY'
  .'pyc/dFntSVSE9lamqVptq4BeDY1BlqBtUtuXhGlLqMshAlR6C6hT+YpdrKGZlyJBbZQrYd'
  .'Q9WjLO+pEY6sxJ2ov3BkaqgmBrbqJZv4dYgBjacV8F2oEoEdMqFbX0A1HR68CXk/IF7Asz'
  .'CvigZGkKW2wXe5vMr+4p/MBpzlA35rcUZTlufHvfU+rKYGcN6ua7+EC0tN409gc2qbdkA9'
  .'16MsY0VX8n9Wzsi54yRbWFE3povgjVLxvyvo+fPnzzO13xVgc9maWbp8L0LBnk5OqMeDlF'
  .'fDFm5A3iIn1JJz29JO9dbb51qV9UOmogpN/CHkwi2aWbhxPgtsLalcD78MJfYrcqPAfS4y'
  .'gOUF3oIiXyYGjY62uM0Sy6BDMrUC7QmxppQnfEmthODPGYavQFmsKtM26DO+e+ZVsdDaDG'
  .'HdP/IdO0pN3gUDePfvz2/cry4f3nxO1f6SgRzfL9agPPi0p2it7vH+oYIkXAXgwIPDbmOA'
  .'MnG73RncvY2yscKxAHJJwnu3UB4jqAgD7U+U1t3bqJBG3ruFVvAqlDiy3+0eomJssz9Q25'
  .'0DVIptHqjd4x6C2MKR0u83DhRUjhn7nw6UPqqk3HrvFlqNu1A6x0eoitdhVXQRObE2B929'
  .'jdDMEWFlPQXcvY1wrQl5nl0YQ/Wwsa8cat3eoN3tNA6RNMNU5WfHbVVpoUwS6ymNgdJC2Z'
  .'oOm8v2yaUrIzHFmTOmmNtamOJ/ZWBjyVmxtJMfQ16kqDg9ry89dHjCLpygXC9ZQWTPqCCY'
  .'iYU9/RcLe7o49u6e59jj2Dfb2/NL9vb7sL5g6Nx77K8kkM8Kzgt2ukxqp7s/H8GrZ0/Cwl'
  .'x/KcHF5ZXiUh8+hMKEBmMnqpbeWnIGM/H8ZIdayUM8e1a5J7xZ8PTXGbiw1PhSR18FMG13'
  .'GoiKSGywJY7wzYttntMglme5HATECfdmjua4o6+dMdKFxHwXkG6Z1A40P/AomZj2iJ8gxb'
  .'38kFg+VdeEuB9JmQZPIC+hUUhpCHGsUfttCcqJuhpfhcoj8oRo0V1JRKLMsF54X3oXNjnF'
  .'mQbU03SL+D4PWpFTMZN1magZSfAd2OAak6kVmK5FNXZ78/lJEnu2zhhHIYF55OMWvMrVRt'
  .'SmHgmoRj+fEsvXiG1oY+KP5U1mYD8jS+plRjwIeQqnNWzjI+KP8R5c5Fb8wDPtkaaPqf5Y'
  .'mwbDe/LLyf65h33OaTLKcTC8h/tQYZMxMb+g2tDx+NFYXbI1JSJY74YKR45B9/L9nqK01H'
  .'Jk5YHjsYQaOXGAyyKhRk4U3juwoetizKauhXcsX0apYOn6gSCEOe7jD+DCLFhJxfWFUc6r'
  .'3oEN93RREad6dE/n1d6HTXfsLurdSOphd+zOK77JL9we1UlADflSkp4Q4F1Auq5Rm5xYVC'
  .'MetYkvX0mSq7qucGmDC/ENWHdOHukiJTXXo0PzmfwGj+8aE/CE7HEYXwek+2PiuXxP9l2i'
  .'U/lNQRV4J4LZkvCfmsMgsnhNLAmOhdZ2ALFQpDre4bSqO3aT/b4Oq4w56/S6KMjccaLH23'
  .'CRkSY0IAYJSIL9DmezuB+FwpSf3vTkNM6sm8JPhkW59Z0V3bU9qCQTH5dApD6SWBXU7LZY'
  .'/fKZgjKsjjpsDxRNPe4M2kcKyiYK9oe54lvoWu2rDFTTNzD8I7gUPZf4NNCemh5fkRMiTs'
  .'c4JzZDVp8GH5seW28TEuBDuGI7mh8Q2yCeoc0eqjSi69T3HXESxlZesZ1+SJ4dEY2QOpe/'
  .'2bPy92UoTYirUTvwTnndXVSLE+IqrP29XH8e5opFVHqYK5YQ1P6ZhUqyDmfXGp0fWRLf1F'
  .'7/2qq93mRn2V5BVMeq0GR1BEs2KqqRohq28AEUHvncdoHbfuPrbT/sc+Olh32t01WPGodq'
  .'qI4vQ84iX5ymTz0OnXcSLkPuKSWP02cNh77DxbALeR4vDBBGDL2Ei5BrdlW2IBBUBKr12k'
  .'pTQZnaHSiIILDFEocBvRQ2QxtSJD0+2ldUlElPdQ7laz5UkoX493PJ/psE5URhzSoiYlnO'
  .'U41YJvHD1AAONRhy3qn7npZIHhVqf5QAzVe2c25KP6SbtT9IUE2Xs3PuXf1B3ftHBlZTRe'
  .'x5vfsc1k2DTlwnoLZ+qln0CbXkGt80dr++TK63Z3qHTG1vo91SjnrdgdJpfqodd37a6X7c'
  .'UZE5R/sOl30P0LxT+BIscwu9hDdgrdPV+u2WoikPHijNQV88fMTsQWqB136fhY0lnuBGeG'
  .'URt6ib5/G+zmqGHvGC8IZzHViU7MAcmtQL34nEPWZthounoncAu45vBuYTqpl29KjE7jU5'
  .'FUWSth3EbJuOyBybbeZZFUWSmH0VKoYzZcWe4LGzQ1LLAospYRk/e82qqGWBCco1WCOjkc'
  .'eMR4bExaQaw5y49RCKURzYUc0iobnitp3ZKalFOxJehYrpa7PH+cx2Zqeolk0/ftisfZmB'
  .'avrjAm5B0XJ0wlNLfNnaecH3iPphyFdjza2/S1CMYHwRci4Jxtxcfj+DJJW3Ge67xOYpEO'
  .'KszebVosTgtx5nMqF24EfzGuLNEMZvw3rgEdNKcXOciyJBTN6Dy5FdgwZEH1NjplTgrxuX'
  .'QkIrlEe6ta8kWI/uaUYcrCMAYttOkAzXYiov6NUbsZKaMLA1AZhJzgzbFSiHX47450dxsw'
  .'cBsQsd3oT8CR2ZdvgeLBrR+0sufn/Z/40EG7ozmfd3H809L/gfSZ99ODKD8fSkrjuT3ZFj'
  .'EXu0G/HFH/3miNo3R07ia+r92d//SdKfMtmD3v6fM1sHorteFB6VDi2qsyH/PwAA//+rYG'
  .'HB';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    return (string)\gzuncompress(\base64_decode(self::RAW));
  }
}
