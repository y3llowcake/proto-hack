<?hh // strict
namespace conformance;

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: external/com_google_protobuf/conformance/conformance.proto

newtype WireFormat_enum_t as int = int;
abstract class WireFormat {
  const WireFormat_enum_t UNSPECIFIED = 0;
  const WireFormat_enum_t PROTOBUF = 1;
  const WireFormat_enum_t JSON = 2;
  const WireFormat_enum_t JSPB = 3;
  const WireFormat_enum_t TEXT_FORMAT = 4;
  private static dict<int, string> $itos = dict[
    0 => 'UNSPECIFIED',
    1 => 'PROTOBUF',
    2 => 'JSON',
    3 => 'JSPB',
    4 => 'TEXT_FORMAT',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'UNSPECIFIED' => 0,
    'PROTOBUF' => 1,
    'JSON' => 2,
    'JSPB' => 3,
    'TEXT_FORMAT' => 4,
  ];
  public static function FromMixed(mixed $m): WireFormat_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): WireFormat_enum_t {
    return $i;
  }
}

newtype TestCategory_enum_t as int = int;
abstract class TestCategory {
  const TestCategory_enum_t UNSPECIFIED_TEST = 0;
  const TestCategory_enum_t BINARY_TEST = 1;
  const TestCategory_enum_t JSON_TEST = 2;
  const TestCategory_enum_t JSON_IGNORE_UNKNOWN_PARSING_TEST = 3;
  const TestCategory_enum_t JSPB_TEST = 4;
  const TestCategory_enum_t TEXT_FORMAT_TEST = 5;
  private static dict<int, string> $itos = dict[
    0 => 'UNSPECIFIED_TEST',
    1 => 'BINARY_TEST',
    2 => 'JSON_TEST',
    3 => 'JSON_IGNORE_UNKNOWN_PARSING_TEST',
    4 => 'JSPB_TEST',
    5 => 'TEXT_FORMAT_TEST',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'UNSPECIFIED_TEST' => 0,
    'BINARY_TEST' => 1,
    'JSON_TEST' => 2,
    'JSON_IGNORE_UNKNOWN_PARSING_TEST' => 3,
    'JSPB_TEST' => 4,
    'TEXT_FORMAT_TEST' => 5,
  ];
  public static function FromMixed(mixed $m): TestCategory_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): TestCategory_enum_t {
    return $i;
  }
}

class FailureSet implements \Protobuf\Message {
  public vec<string> $failure;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'failure' => vec<string>,
  ) $s = shape()) {
    $this->failure = $s['failure'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "conformance.FailureSet";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->failure []= $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->failure as $elem) {
      $e->writeTag(1, 2);
      $e->writeString($elem);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writePrimitiveList('failure', 'failure', $this->failure);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'failure':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->failure []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FailureSet)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->failure = $o->failure;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

enum ConformanceRequest_payload_oneof_t: int {
  NOT_SET = 0;
  protobuf_payload = 1;
  json_payload = 2;
  jspb_payload = 7;
  text_payload = 8;
}

interface ConformanceRequest_payload {
  public function WhichOneof(): ConformanceRequest_payload_oneof_t;
  public function WriteTo(\Protobuf\Internal\Encoder $e): void;
  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void;
  public function Copy(): ConformanceRequest_payload;
}

class ConformanceRequest_payload_NOT_SET implements ConformanceRequest_payload {
  public function WhichOneof(): ConformanceRequest_payload_oneof_t {
    return ConformanceRequest_payload_oneof_t::NOT_SET;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {}

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {}

  public function Copy(): ConformanceRequest_payload { return $this; }
}

class ConformanceRequest_protobuf_payload implements ConformanceRequest_payload {
  public function __construct(public string $protobuf_payload) {}

  public function WhichOneof(): ConformanceRequest_payload_oneof_t {
    return ConformanceRequest_payload_oneof_t::protobuf_payload;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(1, 2);;
    $e->writeString($this->protobuf_payload);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBytes('protobuf_payload', 'protobufPayload', $this->protobuf_payload, true);
  }

  public function Copy(): ConformanceRequest_payload {
    return new ConformanceRequest_protobuf_payload($this->protobuf_payload);
  }
}

class ConformanceRequest_json_payload implements ConformanceRequest_payload {
  public function __construct(public string $json_payload) {}

  public function WhichOneof(): ConformanceRequest_payload_oneof_t {
    return ConformanceRequest_payload_oneof_t::json_payload;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(2, 2);;
    $e->writeString($this->json_payload);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('json_payload', 'jsonPayload', $this->json_payload, true);
  }

  public function Copy(): ConformanceRequest_payload {
    return new ConformanceRequest_json_payload($this->json_payload);
  }
}

class ConformanceRequest_jspb_payload implements ConformanceRequest_payload {
  public function __construct(public string $jspb_payload) {}

  public function WhichOneof(): ConformanceRequest_payload_oneof_t {
    return ConformanceRequest_payload_oneof_t::jspb_payload;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(7, 2);;
    $e->writeString($this->jspb_payload);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('jspb_payload', 'jspbPayload', $this->jspb_payload, true);
  }

  public function Copy(): ConformanceRequest_payload {
    return new ConformanceRequest_jspb_payload($this->jspb_payload);
  }
}

class ConformanceRequest_text_payload implements ConformanceRequest_payload {
  public function __construct(public string $text_payload) {}

  public function WhichOneof(): ConformanceRequest_payload_oneof_t {
    return ConformanceRequest_payload_oneof_t::text_payload;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(8, 2);;
    $e->writeString($this->text_payload);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('text_payload', 'textPayload', $this->text_payload, true);
  }

  public function Copy(): ConformanceRequest_payload {
    return new ConformanceRequest_text_payload($this->text_payload);
  }
}

class ConformanceRequest implements \Protobuf\Message {
  public \conformance\WireFormat_enum_t $requested_output_format;
  public string $message_type;
  public \conformance\TestCategory_enum_t $test_category;
  public ?\conformance\JspbEncodingConfig $jspb_encoding_options;
  public bool $print_unknown_fields;
  public ConformanceRequest_payload $payload;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'requested_output_format' => \conformance\WireFormat_enum_t,
    ?'message_type' => string,
    ?'test_category' => \conformance\TestCategory_enum_t,
    ?'jspb_encoding_options' => ?\conformance\JspbEncodingConfig,
    ?'print_unknown_fields' => bool,
    ?'payload' => ConformanceRequest_payload,
  ) $s = shape()) {
    $this->requested_output_format = $s['requested_output_format'] ?? \conformance\WireFormat::FromInt(0);
    $this->message_type = $s['message_type'] ?? '';
    $this->test_category = $s['test_category'] ?? \conformance\TestCategory::FromInt(0);
    $this->jspb_encoding_options = $s['jspb_encoding_options'] ?? null;
    $this->print_unknown_fields = $s['print_unknown_fields'] ?? false;
    $this->payload = $s['payload'] ?? new ConformanceRequest_payload_NOT_SET();
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "conformance.ConformanceRequest";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->payload = new ConformanceRequest_protobuf_payload($d->readString());
          break;
        case 2:
          $this->payload = new ConformanceRequest_json_payload($d->readString());
          break;
        case 3:
          $this->requested_output_format = \conformance\WireFormat::FromInt($d->readVarint());
          break;
        case 4:
          $this->message_type = $d->readString();
          break;
        case 5:
          $this->test_category = \conformance\TestCategory::FromInt($d->readVarint());
          break;
        case 6:
          if ($this->jspb_encoding_options == null) $this->jspb_encoding_options = new \conformance\JspbEncodingConfig();
          $this->jspb_encoding_options->MergeFrom($d->readDecoder());
          break;
        case 7:
          $this->payload = new ConformanceRequest_jspb_payload($d->readString());
          break;
        case 8:
          $this->payload = new ConformanceRequest_text_payload($d->readString());
          break;
        case 9:
          $this->print_unknown_fields = $d->readBool();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->requested_output_format !== \conformance\WireFormat::FromInt(0)) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->requested_output_format);
    }
    if ($this->message_type !== '') {
      $e->writeTag(4, 2);
      $e->writeString($this->message_type);
    }
    if ($this->test_category !== \conformance\TestCategory::FromInt(0)) {
      $e->writeTag(5, 0);
      $e->writeVarint($this->test_category);
    }
    $msg = $this->jspb_encoding_options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 6);
    }
    if ($this->print_unknown_fields !== false) {
      $e->writeTag(9, 0);
      $e->writeBool($this->print_unknown_fields);
    }
    $this->payload->WriteTo($e);
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeEnum('requested_output_format', 'requestedOutputFormat', \conformance\WireFormat::ToStringDict(), $this->requested_output_format, false);
    $e->writeString('message_type', 'messageType', $this->message_type, false);
    $e->writeEnum('test_category', 'testCategory', \conformance\TestCategory::ToStringDict(), $this->test_category, false);
    $e->writeMessage('jspb_encoding_options', 'jspbEncodingOptions', $this->jspb_encoding_options, false);
    $e->writeBool('print_unknown_fields', 'printUnknownFields', $this->print_unknown_fields, false);
    $this->payload->WriteJsonTo($e);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'protobuf_payload': case 'protobufPayload':
          $this->payload = new ConformanceRequest_protobuf_payload(\Protobuf\Internal\JsonDecoder::readBytes($v));
          break;
        case 'json_payload': case 'jsonPayload':
          $this->payload = new ConformanceRequest_json_payload(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'requested_output_format': case 'requestedOutputFormat':
          $this->requested_output_format = \conformance\WireFormat::FromMixed($v);
          break;
        case 'message_type': case 'messageType':
          $this->message_type = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'test_category': case 'testCategory':
          $this->test_category = \conformance\TestCategory::FromMixed($v);
          break;
        case 'jspb_encoding_options': case 'jspbEncodingOptions':
          if ($v === null) break;
          if ($this->jspb_encoding_options == null) $this->jspb_encoding_options = new \conformance\JspbEncodingConfig();
          $this->jspb_encoding_options->MergeJsonFrom($v);
          break;
        case 'jspb_payload': case 'jspbPayload':
          $this->payload = new ConformanceRequest_jspb_payload(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'text_payload': case 'textPayload':
          $this->payload = new ConformanceRequest_text_payload(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'print_unknown_fields': case 'printUnknownFields':
          $this->print_unknown_fields = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ConformanceRequest)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->requested_output_format = $o->requested_output_format;
    $this->message_type = $o->message_type;
    $this->test_category = $o->test_category;
    $tmp = $o->jspb_encoding_options;
    if ($tmp !== null) {
      $nv = new \conformance\JspbEncodingConfig();
      $nv->CopyFrom($tmp);
      $this->jspb_encoding_options = $nv;
    }
    $this->print_unknown_fields = $o->print_unknown_fields;
    $this->payload = $o->payload->Copy();
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

enum ConformanceResponse_result_oneof_t: int {
  NOT_SET = 0;
  parse_error = 1;
  serialize_error = 6;
  runtime_error = 2;
  protobuf_payload = 3;
  json_payload = 4;
  skipped = 5;
  jspb_payload = 7;
  text_payload = 8;
}

interface ConformanceResponse_result {
  public function WhichOneof(): ConformanceResponse_result_oneof_t;
  public function WriteTo(\Protobuf\Internal\Encoder $e): void;
  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void;
  public function Copy(): ConformanceResponse_result;
}

class ConformanceResponse_result_NOT_SET implements ConformanceResponse_result {
  public function WhichOneof(): ConformanceResponse_result_oneof_t {
    return ConformanceResponse_result_oneof_t::NOT_SET;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {}

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {}

  public function Copy(): ConformanceResponse_result { return $this; }
}

class ConformanceResponse_parse_error implements ConformanceResponse_result {
  public function __construct(public string $parse_error) {}

  public function WhichOneof(): ConformanceResponse_result_oneof_t {
    return ConformanceResponse_result_oneof_t::parse_error;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(1, 2);;
    $e->writeString($this->parse_error);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('parse_error', 'parseError', $this->parse_error, true);
  }

  public function Copy(): ConformanceResponse_result {
    return new ConformanceResponse_parse_error($this->parse_error);
  }
}

class ConformanceResponse_serialize_error implements ConformanceResponse_result {
  public function __construct(public string $serialize_error) {}

  public function WhichOneof(): ConformanceResponse_result_oneof_t {
    return ConformanceResponse_result_oneof_t::serialize_error;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(6, 2);;
    $e->writeString($this->serialize_error);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('serialize_error', 'serializeError', $this->serialize_error, true);
  }

  public function Copy(): ConformanceResponse_result {
    return new ConformanceResponse_serialize_error($this->serialize_error);
  }
}

class ConformanceResponse_runtime_error implements ConformanceResponse_result {
  public function __construct(public string $runtime_error) {}

  public function WhichOneof(): ConformanceResponse_result_oneof_t {
    return ConformanceResponse_result_oneof_t::runtime_error;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(2, 2);;
    $e->writeString($this->runtime_error);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('runtime_error', 'runtimeError', $this->runtime_error, true);
  }

  public function Copy(): ConformanceResponse_result {
    return new ConformanceResponse_runtime_error($this->runtime_error);
  }
}

class ConformanceResponse_protobuf_payload implements ConformanceResponse_result {
  public function __construct(public string $protobuf_payload) {}

  public function WhichOneof(): ConformanceResponse_result_oneof_t {
    return ConformanceResponse_result_oneof_t::protobuf_payload;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(3, 2);;
    $e->writeString($this->protobuf_payload);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBytes('protobuf_payload', 'protobufPayload', $this->protobuf_payload, true);
  }

  public function Copy(): ConformanceResponse_result {
    return new ConformanceResponse_protobuf_payload($this->protobuf_payload);
  }
}

class ConformanceResponse_json_payload implements ConformanceResponse_result {
  public function __construct(public string $json_payload) {}

  public function WhichOneof(): ConformanceResponse_result_oneof_t {
    return ConformanceResponse_result_oneof_t::json_payload;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(4, 2);;
    $e->writeString($this->json_payload);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('json_payload', 'jsonPayload', $this->json_payload, true);
  }

  public function Copy(): ConformanceResponse_result {
    return new ConformanceResponse_json_payload($this->json_payload);
  }
}

class ConformanceResponse_skipped implements ConformanceResponse_result {
  public function __construct(public string $skipped) {}

  public function WhichOneof(): ConformanceResponse_result_oneof_t {
    return ConformanceResponse_result_oneof_t::skipped;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(5, 2);;
    $e->writeString($this->skipped);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('skipped', 'skipped', $this->skipped, true);
  }

  public function Copy(): ConformanceResponse_result {
    return new ConformanceResponse_skipped($this->skipped);
  }
}

class ConformanceResponse_jspb_payload implements ConformanceResponse_result {
  public function __construct(public string $jspb_payload) {}

  public function WhichOneof(): ConformanceResponse_result_oneof_t {
    return ConformanceResponse_result_oneof_t::jspb_payload;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(7, 2);;
    $e->writeString($this->jspb_payload);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('jspb_payload', 'jspbPayload', $this->jspb_payload, true);
  }

  public function Copy(): ConformanceResponse_result {
    return new ConformanceResponse_jspb_payload($this->jspb_payload);
  }
}

class ConformanceResponse_text_payload implements ConformanceResponse_result {
  public function __construct(public string $text_payload) {}

  public function WhichOneof(): ConformanceResponse_result_oneof_t {
    return ConformanceResponse_result_oneof_t::text_payload;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(8, 2);;
    $e->writeString($this->text_payload);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('text_payload', 'textPayload', $this->text_payload, true);
  }

  public function Copy(): ConformanceResponse_result {
    return new ConformanceResponse_text_payload($this->text_payload);
  }
}

class ConformanceResponse implements \Protobuf\Message {
  public ConformanceResponse_result $result;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'result' => ConformanceResponse_result,
  ) $s = shape()) {
    $this->result = $s['result'] ?? new ConformanceResponse_result_NOT_SET();
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "conformance.ConformanceResponse";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->result = new ConformanceResponse_parse_error($d->readString());
          break;
        case 2:
          $this->result = new ConformanceResponse_runtime_error($d->readString());
          break;
        case 3:
          $this->result = new ConformanceResponse_protobuf_payload($d->readString());
          break;
        case 4:
          $this->result = new ConformanceResponse_json_payload($d->readString());
          break;
        case 5:
          $this->result = new ConformanceResponse_skipped($d->readString());
          break;
        case 6:
          $this->result = new ConformanceResponse_serialize_error($d->readString());
          break;
        case 7:
          $this->result = new ConformanceResponse_jspb_payload($d->readString());
          break;
        case 8:
          $this->result = new ConformanceResponse_text_payload($d->readString());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $this->result->WriteTo($e);
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $this->result->WriteJsonTo($e);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'parse_error': case 'parseError':
          $this->result = new ConformanceResponse_parse_error(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'runtime_error': case 'runtimeError':
          $this->result = new ConformanceResponse_runtime_error(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'protobuf_payload': case 'protobufPayload':
          $this->result = new ConformanceResponse_protobuf_payload(\Protobuf\Internal\JsonDecoder::readBytes($v));
          break;
        case 'json_payload': case 'jsonPayload':
          $this->result = new ConformanceResponse_json_payload(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'skipped':
          $this->result = new ConformanceResponse_skipped(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'serialize_error': case 'serializeError':
          $this->result = new ConformanceResponse_serialize_error(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'jspb_payload': case 'jspbPayload':
          $this->result = new ConformanceResponse_jspb_payload(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'text_payload': case 'textPayload':
          $this->result = new ConformanceResponse_text_payload(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ConformanceResponse)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->result = $o->result->Copy();
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class JspbEncodingConfig implements \Protobuf\Message {
  public bool $use_jspb_array_any_format;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'use_jspb_array_any_format' => bool,
  ) $s = shape()) {
    $this->use_jspb_array_any_format = $s['use_jspb_array_any_format'] ?? false;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "conformance.JspbEncodingConfig";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->use_jspb_array_any_format = $d->readBool();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->use_jspb_array_any_format !== false) {
      $e->writeTag(1, 0);
      $e->writeBool($this->use_jspb_array_any_format);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('use_jspb_array_any_format', 'useJspbArrayAnyFormat', $this->use_jspb_array_any_format, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'use_jspb_array_any_format': case 'useJspbArrayAnyFormat':
          $this->use_jspb_array_any_format = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is JspbEncodingConfig)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->use_jspb_array_any_format = $o->use_jspb_array_any_format;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}


class XXX_FileDescriptor_external_com_google_protobuf_conformance_conformance__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'external/com_google_protobuf/conformance/conformance.proto';
  const string RAW =
  'eNqslM9u2koUxjEQ/hxIYk0SxbmbEO4fcVOJVOmm6qISpJCQqjYyRmlXIwMDcgIz7sxYjf'
  .'sSfbE+T9eVZzAxahZddOfzfb8zZ/D5MLwhj5Jw6i8vpmyFF4wtlgSHnEk2ieYXU0bnjK98'
  .'OiXZ57YCUC0jNf8D6PvBMuJkRCSyoDzXlWU0Cq2qm5bNHwVAV099LvkcESHRCzDTqTj04y'
  .'XzZ5bRMFr1m5y7nzpDbaC/oX4vGN2A+YbRqt7k3FqibkHhZAOVn6BwkoEkeZQbqJJCiZpC'
  .'DhxzfU0ywyySYSSxur+0Cg2jtXd53M6+nLuAk76y3aNNn6PatIzOoL4iQvgLgmUcEquYTH'
  .'Vra82LQ4Lewq4kQuKpL8mC8djaUZNOtiZ5RMirNeDWZaZCIzhSv57QKZsFdIFZKANGhVVq'
  .'GK3a5enWObcinPTWYLKbYOEe3Gc0R/eil3AY8oBKHNEHyr5QPA/IciasasNoVVykvLG2+s'
  .'rpVqG8frXN73k42Fq8CBkVBJ1BLfS5IJhwzrhaerIBUGIv0dD/sC8ID/xl8DXFSmtsb2No'
  .'9F/Y5RGVwSoF02zU17LGnotb4XfjVnwubn9BWTwEYUhmalWJnwp/LordCpQ4EdFSNm1Av6'
  .'4NvYaTSBCspvmc+zH2aZyG1VBrOooESTo7id2hsc7k+RDgKbhoH2pjezTsXQ36g947M4fq'
  .'UBm6jud0x33TQBUo3o4c28zrp2HXLCQtXu+jh/uO+6HjmcXzbwbUswlFh2BmDsVeb+SZua'
  .'SvO7A77ictGGgXqsnhusyjf6ChysG17bg9PLbf286djYcddzSwrzVV0E3Dri6LyajMZbS6'
  .'0z2D0ylbtfVXrp2uOftXmJSU+upnAAAA//+w3JXY';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    return (string)\gzuncompress(\base64_decode(self::RAW));
  }
}
