<?hh // strict
namespace protobuf_test_messages\proto3;

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: google/protobuf/test_messages_proto3.proto

newtype ForeignEnum_enum_t as int = int;
abstract class ForeignEnum {
  const ForeignEnum_enum_t FOREIGN_FOO = 0;
  const ForeignEnum_enum_t FOREIGN_BAR = 1;
  const ForeignEnum_enum_t FOREIGN_BAZ = 2;
  private static dict<int, string> $itos = dict[
    0 => 'FOREIGN_FOO',
    1 => 'FOREIGN_BAR',
    2 => 'FOREIGN_BAZ',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'FOREIGN_FOO' => 0,
    'FOREIGN_BAR' => 1,
    'FOREIGN_BAZ' => 2,
  ];
  public static function FromMixed(mixed $m): ForeignEnum_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): ForeignEnum_enum_t {
    return $i;
  }
}

newtype TestAllTypesProto3_NestedEnum_enum_t as int = int;
abstract class TestAllTypesProto3_NestedEnum {
  const TestAllTypesProto3_NestedEnum_enum_t FOO = 0;
  const TestAllTypesProto3_NestedEnum_enum_t BAR = 1;
  const TestAllTypesProto3_NestedEnum_enum_t BAZ = 2;
  const TestAllTypesProto3_NestedEnum_enum_t NEG = -1;
  private static dict<int, string> $itos = dict[
    0 => 'FOO',
    1 => 'BAR',
    2 => 'BAZ',
    -1 => 'NEG',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'FOO' => 0,
    'BAR' => 1,
    'BAZ' => 2,
    'NEG' => -1,
  ];
  public static function FromMixed(mixed $m): TestAllTypesProto3_NestedEnum_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): TestAllTypesProto3_NestedEnum_enum_t {
    return $i;
  }
}

newtype TestAllTypesProto3_AliasedEnum_enum_t as int = int;
abstract class TestAllTypesProto3_AliasedEnum {
  const TestAllTypesProto3_AliasedEnum_enum_t ALIAS_FOO = 0;
  const TestAllTypesProto3_AliasedEnum_enum_t ALIAS_BAR = 1;
  const TestAllTypesProto3_AliasedEnum_enum_t ALIAS_BAZ = 2;
  const TestAllTypesProto3_AliasedEnum_enum_t QUX = 2;
  const TestAllTypesProto3_AliasedEnum_enum_t qux = 2;
  const TestAllTypesProto3_AliasedEnum_enum_t bAz = 2;
  private static dict<int, string> $itos = dict[
    0 => 'ALIAS_FOO',
    1 => 'ALIAS_BAR',
    2 => 'ALIAS_BAZ',
    2 => 'QUX',
    2 => 'qux',
    2 => 'bAz',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'ALIAS_FOO' => 0,
    'ALIAS_BAR' => 1,
    'ALIAS_BAZ' => 2,
    'QUX' => 2,
    'qux' => 2,
    'bAz' => 2,
  ];
  public static function FromMixed(mixed $m): TestAllTypesProto3_AliasedEnum_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): TestAllTypesProto3_AliasedEnum_enum_t {
    return $i;
  }
}

enum TestAllTypesProto3_oneof_field_oneof_t: int {
  NOT_SET = 0;
  oneof_uint32 = 111;
  oneof_nested_message = 112;
  oneof_string = 113;
  oneof_bytes = 114;
  oneof_bool = 115;
  oneof_uint64 = 116;
  oneof_float = 117;
  oneof_double = 118;
  oneof_enum = 119;
  oneof_null_value = 120;
}

interface TestAllTypesProto3_oneof_field {
  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t;
  public function WriteTo(\Protobuf\Internal\Encoder $e): void;
  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void;
  public function Copy(): TestAllTypesProto3_oneof_field;
}

class TestAllTypesProto3_oneof_field_NOT_SET implements TestAllTypesProto3_oneof_field {
  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::NOT_SET;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {}

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {}

  public function Copy(): TestAllTypesProto3_oneof_field { return $this; }
}

class TestAllTypesProto3_oneof_uint32 implements TestAllTypesProto3_oneof_field {
  public function __construct(public int $oneof_uint32) {}

  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::oneof_uint32;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(111, 0);;
    $e->writeVarint($this->oneof_uint32);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('oneof_uint32', 'oneofUint32', $this->oneof_uint32, true);
  }

  public function Copy(): TestAllTypesProto3_oneof_field {
    return new TestAllTypesProto3_oneof_uint32($this->oneof_uint32);
  }
}

class TestAllTypesProto3_oneof_nested_message implements TestAllTypesProto3_oneof_field {
  public function __construct(public \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage $oneof_nested_message) {}

  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::oneof_nested_message;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $nested = new \Protobuf\Internal\Encoder();
    $this->oneof_nested_message->WriteTo($nested);
    $e->writeEncoder($nested, 112);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessage('oneof_nested_message', 'oneofNestedMessage', $this->oneof_nested_message, true);
  }

  public function Copy(): TestAllTypesProto3_oneof_field {
    $nv = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
    $nv->CopyFrom($this->oneof_nested_message);
    return new TestAllTypesProto3_oneof_nested_message($nv);
  }
}

class TestAllTypesProto3_oneof_string implements TestAllTypesProto3_oneof_field {
  public function __construct(public string $oneof_string) {}

  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::oneof_string;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(113, 2);;
    $e->writeString($this->oneof_string);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('oneof_string', 'oneofString', $this->oneof_string, true);
  }

  public function Copy(): TestAllTypesProto3_oneof_field {
    return new TestAllTypesProto3_oneof_string($this->oneof_string);
  }
}

class TestAllTypesProto3_oneof_bytes implements TestAllTypesProto3_oneof_field {
  public function __construct(public string $oneof_bytes) {}

  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::oneof_bytes;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(114, 2);;
    $e->writeString($this->oneof_bytes);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBytes('oneof_bytes', 'oneofBytes', $this->oneof_bytes, true);
  }

  public function Copy(): TestAllTypesProto3_oneof_field {
    return new TestAllTypesProto3_oneof_bytes($this->oneof_bytes);
  }
}

class TestAllTypesProto3_oneof_bool implements TestAllTypesProto3_oneof_field {
  public function __construct(public bool $oneof_bool) {}

  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::oneof_bool;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(115, 0);;
    $e->writeBool($this->oneof_bool);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('oneof_bool', 'oneofBool', $this->oneof_bool, true);
  }

  public function Copy(): TestAllTypesProto3_oneof_field {
    return new TestAllTypesProto3_oneof_bool($this->oneof_bool);
  }
}

class TestAllTypesProto3_oneof_uint64 implements TestAllTypesProto3_oneof_field {
  public function __construct(public int $oneof_uint64) {}

  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::oneof_uint64;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(116, 0);;
    $e->writeVarint($this->oneof_uint64);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Unsigned('oneof_uint64', 'oneofUint64', $this->oneof_uint64, true);
  }

  public function Copy(): TestAllTypesProto3_oneof_field {
    return new TestAllTypesProto3_oneof_uint64($this->oneof_uint64);
  }
}

class TestAllTypesProto3_oneof_float implements TestAllTypesProto3_oneof_field {
  public function __construct(public float $oneof_float) {}

  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::oneof_float;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(117, 5);;
    $e->writeFloat($this->oneof_float);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeFloat('oneof_float', 'oneofFloat', $this->oneof_float, true);
  }

  public function Copy(): TestAllTypesProto3_oneof_field {
    return new TestAllTypesProto3_oneof_float($this->oneof_float);
  }
}

class TestAllTypesProto3_oneof_double implements TestAllTypesProto3_oneof_field {
  public function __construct(public float $oneof_double) {}

  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::oneof_double;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(118, 1);;
    $e->writeDouble($this->oneof_double);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeFloat('oneof_double', 'oneofDouble', $this->oneof_double, true);
  }

  public function Copy(): TestAllTypesProto3_oneof_field {
    return new TestAllTypesProto3_oneof_double($this->oneof_double);
  }
}

class TestAllTypesProto3_oneof_enum implements TestAllTypesProto3_oneof_field {
  public function __construct(public \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t $oneof_enum) {}

  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::oneof_enum;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(119, 0);;
    $e->writeVarint($this->oneof_enum);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeEnum('oneof_enum', 'oneofEnum', \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::ToStringDict(), $this->oneof_enum, true);
  }

  public function Copy(): TestAllTypesProto3_oneof_field {
    return new TestAllTypesProto3_oneof_enum($this->oneof_enum);
  }
}

class TestAllTypesProto3_oneof_null_value implements TestAllTypesProto3_oneof_field {
  public function __construct(public \google\protobuf\NullValue_enum_t $oneof_null_value) {}

  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::oneof_null_value;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(120, 0);;
    $e->writeVarint($this->oneof_null_value);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeEnum('oneof_null_value', 'oneofNullValue', \google\protobuf\NullValue::ToStringDict(), $this->oneof_null_value, true);
  }

  public function Copy(): TestAllTypesProto3_oneof_field {
    return new TestAllTypesProto3_oneof_null_value($this->oneof_null_value);
  }
}

class TestAllTypesProto3_NestedMessage implements \Protobuf\Message {
  public int $a;
  public ?\protobuf_test_messages\proto3\TestAllTypesProto3 $corecursive;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'a' => int,
    ?'corecursive' => ?\protobuf_test_messages\proto3\TestAllTypesProto3,
  ) $s = shape()) {
    $this->a = $s['a'] ?? 0;
    $this->corecursive = $s['corecursive'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.NestedMessage";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->a = $d->readVarint32Signed();
          break;
        case 2:
          if ($this->corecursive == null) $this->corecursive = new \protobuf_test_messages\proto3\TestAllTypesProto3();
          $this->corecursive->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->a !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->a);
    }
    $msg = $this->corecursive;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('a', 'a', $this->a, false);
    $e->writeMessage('corecursive', 'corecursive', $this->corecursive, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'a':
          $this->a = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'corecursive':
          if ($v === null) break;
          if ($this->corecursive == null) $this->corecursive = new \protobuf_test_messages\proto3\TestAllTypesProto3();
          $this->corecursive->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_NestedMessage)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->a = $o->a;
    $tmp = $o->corecursive;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto3\TestAllTypesProto3();
      $nv->CopyFrom($tmp);
      $this->corecursive = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapInt32Int32Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapInt32Int32Entry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32Signed();
          break;
        case 2:
          $this->value = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeInt32('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapInt32Int32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapInt64Int64Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapInt64Int64Entry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint();
          break;
        case 2:
          $this->value = $d->readVarint();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Signed('key', 'key', $this->key, false);
    $e->writeInt64Signed('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapInt64Int64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapUint32Uint32Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapUint32Uint32Entry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32();
          break;
        case 2:
          $this->value = $d->readVarint32();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeInt32('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapUint32Uint32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapUint64Uint64Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapUint64Uint64Entry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint();
          break;
        case 2:
          $this->value = $d->readVarint();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Unsigned('key', 'key', $this->key, false);
    $e->writeInt64Unsigned('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapUint64Uint64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapSint32Sint32Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapSint32Sint32Entry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarintZigZag32();
          break;
        case 2:
          $this->value = $d->readVarintZigZag32();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarintZigZag32($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarintZigZag32($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeInt32('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapSint32Sint32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapSint64Sint64Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapSint64Sint64Entry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarintZigZag64();
          break;
        case 2:
          $this->value = $d->readVarintZigZag64();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarintZigZag64($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarintZigZag64($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Signed('key', 'key', $this->key, false);
    $e->writeInt64Signed('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapSint64Sint64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapFixed32Fixed32Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapFixed32Fixed32Entry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readLittleEndianInt32Unsigned();
          break;
        case 2:
          $this->value = $d->readLittleEndianInt32Unsigned();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 5);
      $e->writeLittleEndianInt32Unsigned($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 5);
      $e->writeLittleEndianInt32Unsigned($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeInt32('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapFixed32Fixed32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapFixed64Fixed64Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapFixed64Fixed64Entry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readLittleEndianInt64();
          break;
        case 2:
          $this->value = $d->readLittleEndianInt64();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 1);
      $e->writeLittleEndianInt64($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 1);
      $e->writeLittleEndianInt64($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Unsigned('key', 'key', $this->key, false);
    $e->writeInt64Unsigned('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapFixed64Fixed64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapSfixed32Sfixed32Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapSfixed32Sfixed32Entry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readLittleEndianInt32Signed();
          break;
        case 2:
          $this->value = $d->readLittleEndianInt32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 5);
      $e->writeLittleEndianInt32Signed($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 5);
      $e->writeLittleEndianInt32Signed($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeInt32('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapSfixed32Sfixed32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapSfixed64Sfixed64Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapSfixed64Sfixed64Entry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readLittleEndianInt64();
          break;
        case 2:
          $this->value = $d->readLittleEndianInt64();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 1);
      $e->writeLittleEndianInt64($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 1);
      $e->writeLittleEndianInt64($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Signed('key', 'key', $this->key, false);
    $e->writeInt64Signed('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapSfixed64Sfixed64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapInt32FloatEntry implements \Protobuf\Message {
  public int $key;
  public float $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => float,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0.0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapInt32FloatEntry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32Signed();
          break;
        case 2:
          $this->value = $d->readFloat();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0.0) {
      $e->writeTag(2, 5);
      $e->writeFloat($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeFloat('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapInt32FloatEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapInt32DoubleEntry implements \Protobuf\Message {
  public int $key;
  public float $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => float,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0.0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapInt32DoubleEntry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32Signed();
          break;
        case 2:
          $this->value = $d->readDouble();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0.0) {
      $e->writeTag(2, 1);
      $e->writeDouble($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeFloat('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapInt32DoubleEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapBoolBoolEntry implements \Protobuf\Message {
  public bool $key;
  public bool $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => bool,
    ?'value' => bool,
  ) $s = shape()) {
    $this->key = $s['key'] ?? false;
    $this->value = $s['value'] ?? false;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapBoolBoolEntry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readBool();
          break;
        case 2:
          $this->value = $d->readBool();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== false) {
      $e->writeTag(1, 0);
      $e->writeBool($this->key);
    }
    if ($this->value !== false) {
      $e->writeTag(2, 0);
      $e->writeBool($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('key', 'key', $this->key, false);
    $e->writeBool('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapBoolBoolEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapStringStringEntry implements \Protobuf\Message {
  public string $key;
  public string $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => string,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapStringStringEntry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          $this->value = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    if ($this->value !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeString('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapStringStringEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapStringBytesEntry implements \Protobuf\Message {
  public string $key;
  public string $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => string,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapStringBytesEntry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          $this->value = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    if ($this->value !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeBytes('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readBytes($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapStringBytesEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapStringNestedMessageEntry implements \Protobuf\Message {
  public string $key;
  public ?\protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => ?\protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapStringNestedMessageEntry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          if ($this->value == null) $this->value = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
          $this->value->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    $msg = $this->value;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeMessage('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          if ($v === null) break;
          if ($this->value == null) $this->value = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
          $this->value->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapStringNestedMessageEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $tmp = $o->value;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
      $nv->CopyFrom($tmp);
      $this->value = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapStringForeignMessageEntry implements \Protobuf\Message {
  public string $key;
  public ?\protobuf_test_messages\proto3\ForeignMessage $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => ?\protobuf_test_messages\proto3\ForeignMessage,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapStringForeignMessageEntry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          if ($this->value == null) $this->value = new \protobuf_test_messages\proto3\ForeignMessage();
          $this->value->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    $msg = $this->value;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeMessage('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          if ($v === null) break;
          if ($this->value == null) $this->value = new \protobuf_test_messages\proto3\ForeignMessage();
          $this->value->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapStringForeignMessageEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $tmp = $o->value;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto3\ForeignMessage();
      $nv->CopyFrom($tmp);
      $this->value = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapStringNestedEnumEntry implements \Protobuf\Message {
  public string $key;
  public \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt(0);
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapStringNestedEnumEntry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          $this->value = \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt($d->readVarint());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    if ($this->value !== \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt(0)) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeEnum('value', 'value', \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::ToStringDict(), $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          $this->value = \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromMixed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapStringNestedEnumEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapStringForeignEnumEntry implements \Protobuf\Message {
  public string $key;
  public \protobuf_test_messages\proto3\ForeignEnum_enum_t $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => \protobuf_test_messages\proto3\ForeignEnum_enum_t,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? \protobuf_test_messages\proto3\ForeignEnum::FromInt(0);
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapStringForeignEnumEntry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          $this->value = \protobuf_test_messages\proto3\ForeignEnum::FromInt($d->readVarint());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    if ($this->value !== \protobuf_test_messages\proto3\ForeignEnum::FromInt(0)) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeEnum('value', 'value', \protobuf_test_messages\proto3\ForeignEnum::ToStringDict(), $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          $this->value = \protobuf_test_messages\proto3\ForeignEnum::FromMixed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapStringForeignEnumEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3 implements \Protobuf\Message {
  public int $optional_int32;
  public int $optional_int64;
  public int $optional_uint32;
  public int $optional_uint64;
  public int $optional_sint32;
  public int $optional_sint64;
  public int $optional_fixed32;
  public int $optional_fixed64;
  public int $optional_sfixed32;
  public int $optional_sfixed64;
  public float $optional_float;
  public float $optional_double;
  public bool $optional_bool;
  public string $optional_string;
  public string $optional_bytes;
  public ?\protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage $optional_nested_message;
  public ?\protobuf_test_messages\proto3\ForeignMessage $optional_foreign_message;
  public \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t $optional_nested_enum;
  public \protobuf_test_messages\proto3\ForeignEnum_enum_t $optional_foreign_enum;
  public \protobuf_test_messages\proto3\TestAllTypesProto3_AliasedEnum_enum_t $optional_aliased_enum;
  public string $optional_string_piece;
  public string $optional_cord;
  public ?\protobuf_test_messages\proto3\TestAllTypesProto3 $recursive_message;
  public vec<int> $repeated_int32;
  public vec<int> $repeated_int64;
  public vec<int> $repeated_uint32;
  public vec<int> $repeated_uint64;
  public vec<int> $repeated_sint32;
  public vec<int> $repeated_sint64;
  public vec<int> $repeated_fixed32;
  public vec<int> $repeated_fixed64;
  public vec<int> $repeated_sfixed32;
  public vec<int> $repeated_sfixed64;
  public vec<float> $repeated_float;
  public vec<float> $repeated_double;
  public vec<bool> $repeated_bool;
  public vec<string> $repeated_string;
  public vec<string> $repeated_bytes;
  public vec<\protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage> $repeated_nested_message;
  public vec<\protobuf_test_messages\proto3\ForeignMessage> $repeated_foreign_message;
  public vec<\protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t> $repeated_nested_enum;
  public vec<\protobuf_test_messages\proto3\ForeignEnum_enum_t> $repeated_foreign_enum;
  public vec<string> $repeated_string_piece;
  public vec<string> $repeated_cord;
  public vec<int> $packed_int32;
  public vec<int> $packed_int64;
  public vec<int> $packed_uint32;
  public vec<int> $packed_uint64;
  public vec<int> $packed_sint32;
  public vec<int> $packed_sint64;
  public vec<int> $packed_fixed32;
  public vec<int> $packed_fixed64;
  public vec<int> $packed_sfixed32;
  public vec<int> $packed_sfixed64;
  public vec<float> $packed_float;
  public vec<float> $packed_double;
  public vec<bool> $packed_bool;
  public vec<\protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t> $packed_nested_enum;
  public vec<int> $unpacked_int32;
  public vec<int> $unpacked_int64;
  public vec<int> $unpacked_uint32;
  public vec<int> $unpacked_uint64;
  public vec<int> $unpacked_sint32;
  public vec<int> $unpacked_sint64;
  public vec<int> $unpacked_fixed32;
  public vec<int> $unpacked_fixed64;
  public vec<int> $unpacked_sfixed32;
  public vec<int> $unpacked_sfixed64;
  public vec<float> $unpacked_float;
  public vec<float> $unpacked_double;
  public vec<bool> $unpacked_bool;
  public vec<\protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t> $unpacked_nested_enum;
  public dict<int, int> $map_int32_int32;
  public dict<int, int> $map_int64_int64;
  public dict<int, int> $map_uint32_uint32;
  public dict<int, int> $map_uint64_uint64;
  public dict<int, int> $map_sint32_sint32;
  public dict<int, int> $map_sint64_sint64;
  public dict<int, int> $map_fixed32_fixed32;
  public dict<int, int> $map_fixed64_fixed64;
  public dict<int, int> $map_sfixed32_sfixed32;
  public dict<int, int> $map_sfixed64_sfixed64;
  public dict<int, float> $map_int32_float;
  public dict<int, float> $map_int32_double;
  public dict<\Protobuf\Internal\bool_map_key_t, bool> $map_bool_bool;
  public dict<string, string> $map_string_string;
  public dict<string, string> $map_string_bytes;
  public dict<string, \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage> $map_string_nested_message;
  public dict<string, \protobuf_test_messages\proto3\ForeignMessage> $map_string_foreign_message;
  public dict<string, \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t> $map_string_nested_enum;
  public dict<string, \protobuf_test_messages\proto3\ForeignEnum_enum_t> $map_string_foreign_enum;
  public ?\google\protobuf\BoolValue $optional_bool_wrapper;
  public ?\google\protobuf\Int32Value $optional_int32_wrapper;
  public ?\google\protobuf\Int64Value $optional_int64_wrapper;
  public ?\google\protobuf\UInt32Value $optional_uint32_wrapper;
  public ?\google\protobuf\UInt64Value $optional_uint64_wrapper;
  public ?\google\protobuf\FloatValue $optional_float_wrapper;
  public ?\google\protobuf\DoubleValue $optional_double_wrapper;
  public ?\google\protobuf\StringValue $optional_string_wrapper;
  public ?\google\protobuf\BytesValue $optional_bytes_wrapper;
  public vec<\google\protobuf\BoolValue> $repeated_bool_wrapper;
  public vec<\google\protobuf\Int32Value> $repeated_int32_wrapper;
  public vec<\google\protobuf\Int64Value> $repeated_int64_wrapper;
  public vec<\google\protobuf\UInt32Value> $repeated_uint32_wrapper;
  public vec<\google\protobuf\UInt64Value> $repeated_uint64_wrapper;
  public vec<\google\protobuf\FloatValue> $repeated_float_wrapper;
  public vec<\google\protobuf\DoubleValue> $repeated_double_wrapper;
  public vec<\google\protobuf\StringValue> $repeated_string_wrapper;
  public vec<\google\protobuf\BytesValue> $repeated_bytes_wrapper;
  public ?\google\protobuf\Duration $optional_duration;
  public ?\google\protobuf\Timestamp $optional_timestamp;
  public ?\google\protobuf\FieldMask $optional_field_mask;
  public ?\google\protobuf\Struct $optional_struct;
  public ?\google\protobuf\Any $optional_any;
  public ?\google\protobuf\Value $optional_value;
  public \google\protobuf\NullValue_enum_t $optional_null_value;
  public vec<\google\protobuf\Duration> $repeated_duration;
  public vec<\google\protobuf\Timestamp> $repeated_timestamp;
  public vec<\google\protobuf\FieldMask> $repeated_fieldmask;
  public vec<\google\protobuf\Struct> $repeated_struct;
  public vec<\google\protobuf\Any> $repeated_any;
  public vec<\google\protobuf\Value> $repeated_value;
  public vec<\google\protobuf\ListValue> $repeated_list_value;
  public int $fieldname1;
  public int $field_name2;
  public int $_field_name3;
  public int $field__name4_;
  public int $field0name5;
  public int $field_0_name6;
  public int $fieldName7;
  public int $FieldName8;
  public int $field_Name9;
  public int $Field_Name10;
  public int $FIELD_NAME11;
  public int $FIELD_name12;
  public int $__field_name13;
  public int $__Field_name14;
  public int $field__name15;
  public int $field__Name16;
  public int $field_name17__;
  public int $Field_name18__;
  public TestAllTypesProto3_oneof_field $oneof_field;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'optional_int32' => int,
    ?'optional_int64' => int,
    ?'optional_uint32' => int,
    ?'optional_uint64' => int,
    ?'optional_sint32' => int,
    ?'optional_sint64' => int,
    ?'optional_fixed32' => int,
    ?'optional_fixed64' => int,
    ?'optional_sfixed32' => int,
    ?'optional_sfixed64' => int,
    ?'optional_float' => float,
    ?'optional_double' => float,
    ?'optional_bool' => bool,
    ?'optional_string' => string,
    ?'optional_bytes' => string,
    ?'optional_nested_message' => ?\protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage,
    ?'optional_foreign_message' => ?\protobuf_test_messages\proto3\ForeignMessage,
    ?'optional_nested_enum' => \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t,
    ?'optional_foreign_enum' => \protobuf_test_messages\proto3\ForeignEnum_enum_t,
    ?'optional_aliased_enum' => \protobuf_test_messages\proto3\TestAllTypesProto3_AliasedEnum_enum_t,
    ?'optional_string_piece' => string,
    ?'optional_cord' => string,
    ?'recursive_message' => ?\protobuf_test_messages\proto3\TestAllTypesProto3,
    ?'repeated_int32' => vec<int>,
    ?'repeated_int64' => vec<int>,
    ?'repeated_uint32' => vec<int>,
    ?'repeated_uint64' => vec<int>,
    ?'repeated_sint32' => vec<int>,
    ?'repeated_sint64' => vec<int>,
    ?'repeated_fixed32' => vec<int>,
    ?'repeated_fixed64' => vec<int>,
    ?'repeated_sfixed32' => vec<int>,
    ?'repeated_sfixed64' => vec<int>,
    ?'repeated_float' => vec<float>,
    ?'repeated_double' => vec<float>,
    ?'repeated_bool' => vec<bool>,
    ?'repeated_string' => vec<string>,
    ?'repeated_bytes' => vec<string>,
    ?'repeated_nested_message' => vec<\protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage>,
    ?'repeated_foreign_message' => vec<\protobuf_test_messages\proto3\ForeignMessage>,
    ?'repeated_nested_enum' => vec<\protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t>,
    ?'repeated_foreign_enum' => vec<\protobuf_test_messages\proto3\ForeignEnum_enum_t>,
    ?'repeated_string_piece' => vec<string>,
    ?'repeated_cord' => vec<string>,
    ?'packed_int32' => vec<int>,
    ?'packed_int64' => vec<int>,
    ?'packed_uint32' => vec<int>,
    ?'packed_uint64' => vec<int>,
    ?'packed_sint32' => vec<int>,
    ?'packed_sint64' => vec<int>,
    ?'packed_fixed32' => vec<int>,
    ?'packed_fixed64' => vec<int>,
    ?'packed_sfixed32' => vec<int>,
    ?'packed_sfixed64' => vec<int>,
    ?'packed_float' => vec<float>,
    ?'packed_double' => vec<float>,
    ?'packed_bool' => vec<bool>,
    ?'packed_nested_enum' => vec<\protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t>,
    ?'unpacked_int32' => vec<int>,
    ?'unpacked_int64' => vec<int>,
    ?'unpacked_uint32' => vec<int>,
    ?'unpacked_uint64' => vec<int>,
    ?'unpacked_sint32' => vec<int>,
    ?'unpacked_sint64' => vec<int>,
    ?'unpacked_fixed32' => vec<int>,
    ?'unpacked_fixed64' => vec<int>,
    ?'unpacked_sfixed32' => vec<int>,
    ?'unpacked_sfixed64' => vec<int>,
    ?'unpacked_float' => vec<float>,
    ?'unpacked_double' => vec<float>,
    ?'unpacked_bool' => vec<bool>,
    ?'unpacked_nested_enum' => vec<\protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t>,
    ?'map_int32_int32' => dict<int, int>,
    ?'map_int64_int64' => dict<int, int>,
    ?'map_uint32_uint32' => dict<int, int>,
    ?'map_uint64_uint64' => dict<int, int>,
    ?'map_sint32_sint32' => dict<int, int>,
    ?'map_sint64_sint64' => dict<int, int>,
    ?'map_fixed32_fixed32' => dict<int, int>,
    ?'map_fixed64_fixed64' => dict<int, int>,
    ?'map_sfixed32_sfixed32' => dict<int, int>,
    ?'map_sfixed64_sfixed64' => dict<int, int>,
    ?'map_int32_float' => dict<int, float>,
    ?'map_int32_double' => dict<int, float>,
    ?'map_bool_bool' => dict<\Protobuf\Internal\bool_map_key_t, bool>,
    ?'map_string_string' => dict<string, string>,
    ?'map_string_bytes' => dict<string, string>,
    ?'map_string_nested_message' => dict<string, \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage>,
    ?'map_string_foreign_message' => dict<string, \protobuf_test_messages\proto3\ForeignMessage>,
    ?'map_string_nested_enum' => dict<string, \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t>,
    ?'map_string_foreign_enum' => dict<string, \protobuf_test_messages\proto3\ForeignEnum_enum_t>,
    ?'optional_bool_wrapper' => ?\google\protobuf\BoolValue,
    ?'optional_int32_wrapper' => ?\google\protobuf\Int32Value,
    ?'optional_int64_wrapper' => ?\google\protobuf\Int64Value,
    ?'optional_uint32_wrapper' => ?\google\protobuf\UInt32Value,
    ?'optional_uint64_wrapper' => ?\google\protobuf\UInt64Value,
    ?'optional_float_wrapper' => ?\google\protobuf\FloatValue,
    ?'optional_double_wrapper' => ?\google\protobuf\DoubleValue,
    ?'optional_string_wrapper' => ?\google\protobuf\StringValue,
    ?'optional_bytes_wrapper' => ?\google\protobuf\BytesValue,
    ?'repeated_bool_wrapper' => vec<\google\protobuf\BoolValue>,
    ?'repeated_int32_wrapper' => vec<\google\protobuf\Int32Value>,
    ?'repeated_int64_wrapper' => vec<\google\protobuf\Int64Value>,
    ?'repeated_uint32_wrapper' => vec<\google\protobuf\UInt32Value>,
    ?'repeated_uint64_wrapper' => vec<\google\protobuf\UInt64Value>,
    ?'repeated_float_wrapper' => vec<\google\protobuf\FloatValue>,
    ?'repeated_double_wrapper' => vec<\google\protobuf\DoubleValue>,
    ?'repeated_string_wrapper' => vec<\google\protobuf\StringValue>,
    ?'repeated_bytes_wrapper' => vec<\google\protobuf\BytesValue>,
    ?'optional_duration' => ?\google\protobuf\Duration,
    ?'optional_timestamp' => ?\google\protobuf\Timestamp,
    ?'optional_field_mask' => ?\google\protobuf\FieldMask,
    ?'optional_struct' => ?\google\protobuf\Struct,
    ?'optional_any' => ?\google\protobuf\Any,
    ?'optional_value' => ?\google\protobuf\Value,
    ?'optional_null_value' => \google\protobuf\NullValue_enum_t,
    ?'repeated_duration' => vec<\google\protobuf\Duration>,
    ?'repeated_timestamp' => vec<\google\protobuf\Timestamp>,
    ?'repeated_fieldmask' => vec<\google\protobuf\FieldMask>,
    ?'repeated_struct' => vec<\google\protobuf\Struct>,
    ?'repeated_any' => vec<\google\protobuf\Any>,
    ?'repeated_value' => vec<\google\protobuf\Value>,
    ?'repeated_list_value' => vec<\google\protobuf\ListValue>,
    ?'fieldname1' => int,
    ?'field_name2' => int,
    ?'_field_name3' => int,
    ?'field__name4_' => int,
    ?'field0name5' => int,
    ?'field_0_name6' => int,
    ?'fieldName7' => int,
    ?'FieldName8' => int,
    ?'field_Name9' => int,
    ?'Field_Name10' => int,
    ?'FIELD_NAME11' => int,
    ?'FIELD_name12' => int,
    ?'__field_name13' => int,
    ?'__Field_name14' => int,
    ?'field__name15' => int,
    ?'field__Name16' => int,
    ?'field_name17__' => int,
    ?'Field_name18__' => int,
    ?'oneof_field' => TestAllTypesProto3_oneof_field,
  ) $s = shape()) {
    $this->optional_int32 = $s['optional_int32'] ?? 0;
    $this->optional_int64 = $s['optional_int64'] ?? 0;
    $this->optional_uint32 = $s['optional_uint32'] ?? 0;
    $this->optional_uint64 = $s['optional_uint64'] ?? 0;
    $this->optional_sint32 = $s['optional_sint32'] ?? 0;
    $this->optional_sint64 = $s['optional_sint64'] ?? 0;
    $this->optional_fixed32 = $s['optional_fixed32'] ?? 0;
    $this->optional_fixed64 = $s['optional_fixed64'] ?? 0;
    $this->optional_sfixed32 = $s['optional_sfixed32'] ?? 0;
    $this->optional_sfixed64 = $s['optional_sfixed64'] ?? 0;
    $this->optional_float = $s['optional_float'] ?? 0.0;
    $this->optional_double = $s['optional_double'] ?? 0.0;
    $this->optional_bool = $s['optional_bool'] ?? false;
    $this->optional_string = $s['optional_string'] ?? '';
    $this->optional_bytes = $s['optional_bytes'] ?? '';
    $this->optional_nested_message = $s['optional_nested_message'] ?? null;
    $this->optional_foreign_message = $s['optional_foreign_message'] ?? null;
    $this->optional_nested_enum = $s['optional_nested_enum'] ?? \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt(0);
    $this->optional_foreign_enum = $s['optional_foreign_enum'] ?? \protobuf_test_messages\proto3\ForeignEnum::FromInt(0);
    $this->optional_aliased_enum = $s['optional_aliased_enum'] ?? \protobuf_test_messages\proto3\TestAllTypesProto3_AliasedEnum::FromInt(0);
    $this->optional_string_piece = $s['optional_string_piece'] ?? '';
    $this->optional_cord = $s['optional_cord'] ?? '';
    $this->recursive_message = $s['recursive_message'] ?? null;
    $this->repeated_int32 = $s['repeated_int32'] ?? vec[];
    $this->repeated_int64 = $s['repeated_int64'] ?? vec[];
    $this->repeated_uint32 = $s['repeated_uint32'] ?? vec[];
    $this->repeated_uint64 = $s['repeated_uint64'] ?? vec[];
    $this->repeated_sint32 = $s['repeated_sint32'] ?? vec[];
    $this->repeated_sint64 = $s['repeated_sint64'] ?? vec[];
    $this->repeated_fixed32 = $s['repeated_fixed32'] ?? vec[];
    $this->repeated_fixed64 = $s['repeated_fixed64'] ?? vec[];
    $this->repeated_sfixed32 = $s['repeated_sfixed32'] ?? vec[];
    $this->repeated_sfixed64 = $s['repeated_sfixed64'] ?? vec[];
    $this->repeated_float = $s['repeated_float'] ?? vec[];
    $this->repeated_double = $s['repeated_double'] ?? vec[];
    $this->repeated_bool = $s['repeated_bool'] ?? vec[];
    $this->repeated_string = $s['repeated_string'] ?? vec[];
    $this->repeated_bytes = $s['repeated_bytes'] ?? vec[];
    $this->repeated_nested_message = $s['repeated_nested_message'] ?? vec[];
    $this->repeated_foreign_message = $s['repeated_foreign_message'] ?? vec[];
    $this->repeated_nested_enum = $s['repeated_nested_enum'] ?? vec[];
    $this->repeated_foreign_enum = $s['repeated_foreign_enum'] ?? vec[];
    $this->repeated_string_piece = $s['repeated_string_piece'] ?? vec[];
    $this->repeated_cord = $s['repeated_cord'] ?? vec[];
    $this->packed_int32 = $s['packed_int32'] ?? vec[];
    $this->packed_int64 = $s['packed_int64'] ?? vec[];
    $this->packed_uint32 = $s['packed_uint32'] ?? vec[];
    $this->packed_uint64 = $s['packed_uint64'] ?? vec[];
    $this->packed_sint32 = $s['packed_sint32'] ?? vec[];
    $this->packed_sint64 = $s['packed_sint64'] ?? vec[];
    $this->packed_fixed32 = $s['packed_fixed32'] ?? vec[];
    $this->packed_fixed64 = $s['packed_fixed64'] ?? vec[];
    $this->packed_sfixed32 = $s['packed_sfixed32'] ?? vec[];
    $this->packed_sfixed64 = $s['packed_sfixed64'] ?? vec[];
    $this->packed_float = $s['packed_float'] ?? vec[];
    $this->packed_double = $s['packed_double'] ?? vec[];
    $this->packed_bool = $s['packed_bool'] ?? vec[];
    $this->packed_nested_enum = $s['packed_nested_enum'] ?? vec[];
    $this->unpacked_int32 = $s['unpacked_int32'] ?? vec[];
    $this->unpacked_int64 = $s['unpacked_int64'] ?? vec[];
    $this->unpacked_uint32 = $s['unpacked_uint32'] ?? vec[];
    $this->unpacked_uint64 = $s['unpacked_uint64'] ?? vec[];
    $this->unpacked_sint32 = $s['unpacked_sint32'] ?? vec[];
    $this->unpacked_sint64 = $s['unpacked_sint64'] ?? vec[];
    $this->unpacked_fixed32 = $s['unpacked_fixed32'] ?? vec[];
    $this->unpacked_fixed64 = $s['unpacked_fixed64'] ?? vec[];
    $this->unpacked_sfixed32 = $s['unpacked_sfixed32'] ?? vec[];
    $this->unpacked_sfixed64 = $s['unpacked_sfixed64'] ?? vec[];
    $this->unpacked_float = $s['unpacked_float'] ?? vec[];
    $this->unpacked_double = $s['unpacked_double'] ?? vec[];
    $this->unpacked_bool = $s['unpacked_bool'] ?? vec[];
    $this->unpacked_nested_enum = $s['unpacked_nested_enum'] ?? vec[];
    $this->map_int32_int32 = $s['map_int32_int32'] ?? dict[];
    $this->map_int64_int64 = $s['map_int64_int64'] ?? dict[];
    $this->map_uint32_uint32 = $s['map_uint32_uint32'] ?? dict[];
    $this->map_uint64_uint64 = $s['map_uint64_uint64'] ?? dict[];
    $this->map_sint32_sint32 = $s['map_sint32_sint32'] ?? dict[];
    $this->map_sint64_sint64 = $s['map_sint64_sint64'] ?? dict[];
    $this->map_fixed32_fixed32 = $s['map_fixed32_fixed32'] ?? dict[];
    $this->map_fixed64_fixed64 = $s['map_fixed64_fixed64'] ?? dict[];
    $this->map_sfixed32_sfixed32 = $s['map_sfixed32_sfixed32'] ?? dict[];
    $this->map_sfixed64_sfixed64 = $s['map_sfixed64_sfixed64'] ?? dict[];
    $this->map_int32_float = $s['map_int32_float'] ?? dict[];
    $this->map_int32_double = $s['map_int32_double'] ?? dict[];
    $this->map_bool_bool = $s['map_bool_bool'] ?? dict[];
    $this->map_string_string = $s['map_string_string'] ?? dict[];
    $this->map_string_bytes = $s['map_string_bytes'] ?? dict[];
    $this->map_string_nested_message = $s['map_string_nested_message'] ?? dict[];
    $this->map_string_foreign_message = $s['map_string_foreign_message'] ?? dict[];
    $this->map_string_nested_enum = $s['map_string_nested_enum'] ?? dict[];
    $this->map_string_foreign_enum = $s['map_string_foreign_enum'] ?? dict[];
    $this->optional_bool_wrapper = $s['optional_bool_wrapper'] ?? null;
    $this->optional_int32_wrapper = $s['optional_int32_wrapper'] ?? null;
    $this->optional_int64_wrapper = $s['optional_int64_wrapper'] ?? null;
    $this->optional_uint32_wrapper = $s['optional_uint32_wrapper'] ?? null;
    $this->optional_uint64_wrapper = $s['optional_uint64_wrapper'] ?? null;
    $this->optional_float_wrapper = $s['optional_float_wrapper'] ?? null;
    $this->optional_double_wrapper = $s['optional_double_wrapper'] ?? null;
    $this->optional_string_wrapper = $s['optional_string_wrapper'] ?? null;
    $this->optional_bytes_wrapper = $s['optional_bytes_wrapper'] ?? null;
    $this->repeated_bool_wrapper = $s['repeated_bool_wrapper'] ?? vec[];
    $this->repeated_int32_wrapper = $s['repeated_int32_wrapper'] ?? vec[];
    $this->repeated_int64_wrapper = $s['repeated_int64_wrapper'] ?? vec[];
    $this->repeated_uint32_wrapper = $s['repeated_uint32_wrapper'] ?? vec[];
    $this->repeated_uint64_wrapper = $s['repeated_uint64_wrapper'] ?? vec[];
    $this->repeated_float_wrapper = $s['repeated_float_wrapper'] ?? vec[];
    $this->repeated_double_wrapper = $s['repeated_double_wrapper'] ?? vec[];
    $this->repeated_string_wrapper = $s['repeated_string_wrapper'] ?? vec[];
    $this->repeated_bytes_wrapper = $s['repeated_bytes_wrapper'] ?? vec[];
    $this->optional_duration = $s['optional_duration'] ?? null;
    $this->optional_timestamp = $s['optional_timestamp'] ?? null;
    $this->optional_field_mask = $s['optional_field_mask'] ?? null;
    $this->optional_struct = $s['optional_struct'] ?? null;
    $this->optional_any = $s['optional_any'] ?? null;
    $this->optional_value = $s['optional_value'] ?? null;
    $this->optional_null_value = $s['optional_null_value'] ?? \google\protobuf\NullValue::FromInt(0);
    $this->repeated_duration = $s['repeated_duration'] ?? vec[];
    $this->repeated_timestamp = $s['repeated_timestamp'] ?? vec[];
    $this->repeated_fieldmask = $s['repeated_fieldmask'] ?? vec[];
    $this->repeated_struct = $s['repeated_struct'] ?? vec[];
    $this->repeated_any = $s['repeated_any'] ?? vec[];
    $this->repeated_value = $s['repeated_value'] ?? vec[];
    $this->repeated_list_value = $s['repeated_list_value'] ?? vec[];
    $this->fieldname1 = $s['fieldname1'] ?? 0;
    $this->field_name2 = $s['field_name2'] ?? 0;
    $this->_field_name3 = $s['_field_name3'] ?? 0;
    $this->field__name4_ = $s['field__name4_'] ?? 0;
    $this->field0name5 = $s['field0name5'] ?? 0;
    $this->field_0_name6 = $s['field_0_name6'] ?? 0;
    $this->fieldName7 = $s['fieldName7'] ?? 0;
    $this->FieldName8 = $s['FieldName8'] ?? 0;
    $this->field_Name9 = $s['field_Name9'] ?? 0;
    $this->Field_Name10 = $s['Field_Name10'] ?? 0;
    $this->FIELD_NAME11 = $s['FIELD_NAME11'] ?? 0;
    $this->FIELD_name12 = $s['FIELD_name12'] ?? 0;
    $this->__field_name13 = $s['__field_name13'] ?? 0;
    $this->__Field_name14 = $s['__Field_name14'] ?? 0;
    $this->field__name15 = $s['field__name15'] ?? 0;
    $this->field__Name16 = $s['field__Name16'] ?? 0;
    $this->field_name17__ = $s['field_name17__'] ?? 0;
    $this->Field_name18__ = $s['Field_name18__'] ?? 0;
    $this->oneof_field = $s['oneof_field'] ?? new TestAllTypesProto3_oneof_field_NOT_SET();
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->optional_int32 = $d->readVarint32Signed();
          break;
        case 2:
          $this->optional_int64 = $d->readVarint();
          break;
        case 3:
          $this->optional_uint32 = $d->readVarint32();
          break;
        case 4:
          $this->optional_uint64 = $d->readVarint();
          break;
        case 5:
          $this->optional_sint32 = $d->readVarintZigZag32();
          break;
        case 6:
          $this->optional_sint64 = $d->readVarintZigZag64();
          break;
        case 7:
          $this->optional_fixed32 = $d->readLittleEndianInt32Unsigned();
          break;
        case 8:
          $this->optional_fixed64 = $d->readLittleEndianInt64();
          break;
        case 9:
          $this->optional_sfixed32 = $d->readLittleEndianInt32Signed();
          break;
        case 10:
          $this->optional_sfixed64 = $d->readLittleEndianInt64();
          break;
        case 11:
          $this->optional_float = $d->readFloat();
          break;
        case 12:
          $this->optional_double = $d->readDouble();
          break;
        case 13:
          $this->optional_bool = $d->readBool();
          break;
        case 14:
          $this->optional_string = $d->readString();
          break;
        case 15:
          $this->optional_bytes = $d->readString();
          break;
        case 18:
          if ($this->optional_nested_message == null) $this->optional_nested_message = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
          $this->optional_nested_message->MergeFrom($d->readDecoder());
          break;
        case 19:
          if ($this->optional_foreign_message == null) $this->optional_foreign_message = new \protobuf_test_messages\proto3\ForeignMessage();
          $this->optional_foreign_message->MergeFrom($d->readDecoder());
          break;
        case 21:
          $this->optional_nested_enum = \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt($d->readVarint());
          break;
        case 22:
          $this->optional_foreign_enum = \protobuf_test_messages\proto3\ForeignEnum::FromInt($d->readVarint());
          break;
        case 23:
          $this->optional_aliased_enum = \protobuf_test_messages\proto3\TestAllTypesProto3_AliasedEnum::FromInt($d->readVarint());
          break;
        case 24:
          $this->optional_string_piece = $d->readString();
          break;
        case 25:
          $this->optional_cord = $d->readString();
          break;
        case 27:
          if ($this->recursive_message == null) $this->recursive_message = new \protobuf_test_messages\proto3\TestAllTypesProto3();
          $this->recursive_message->MergeFrom($d->readDecoder());
          break;
        case 31:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_int32 []= $packed->readVarint32Signed();
            }
          } else {
            $this->repeated_int32 []= $d->readVarint32Signed();
          }
          break;
        case 32:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_int64 []= $packed->readVarint();
            }
          } else {
            $this->repeated_int64 []= $d->readVarint();
          }
          break;
        case 33:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_uint32 []= $packed->readVarint32();
            }
          } else {
            $this->repeated_uint32 []= $d->readVarint32();
          }
          break;
        case 34:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_uint64 []= $packed->readVarint();
            }
          } else {
            $this->repeated_uint64 []= $d->readVarint();
          }
          break;
        case 35:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_sint32 []= $packed->readVarintZigZag32();
            }
          } else {
            $this->repeated_sint32 []= $d->readVarintZigZag32();
          }
          break;
        case 36:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_sint64 []= $packed->readVarintZigZag64();
            }
          } else {
            $this->repeated_sint64 []= $d->readVarintZigZag64();
          }
          break;
        case 37:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_fixed32 []= $packed->readLittleEndianInt32Unsigned();
            }
          } else {
            $this->repeated_fixed32 []= $d->readLittleEndianInt32Unsigned();
          }
          break;
        case 38:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_fixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->repeated_fixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 39:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_sfixed32 []= $packed->readLittleEndianInt32Signed();
            }
          } else {
            $this->repeated_sfixed32 []= $d->readLittleEndianInt32Signed();
          }
          break;
        case 40:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_sfixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->repeated_sfixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 41:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_float []= $packed->readFloat();
            }
          } else {
            $this->repeated_float []= $d->readFloat();
          }
          break;
        case 42:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_double []= $packed->readDouble();
            }
          } else {
            $this->repeated_double []= $d->readDouble();
          }
          break;
        case 43:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_bool []= $packed->readBool();
            }
          } else {
            $this->repeated_bool []= $d->readBool();
          }
          break;
        case 44:
          $this->repeated_string []= $d->readString();
          break;
        case 45:
          $this->repeated_bytes []= $d->readString();
          break;
        case 48:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_nested_message []= $obj;
          break;
        case 49:
          $obj = new \protobuf_test_messages\proto3\ForeignMessage();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_foreign_message []= $obj;
          break;
        case 51:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_nested_enum []= \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt($packed->readVarint());
            }
          } else {
            $this->repeated_nested_enum []= \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt($d->readVarint());
          }
          break;
        case 52:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_foreign_enum []= \protobuf_test_messages\proto3\ForeignEnum::FromInt($packed->readVarint());
            }
          } else {
            $this->repeated_foreign_enum []= \protobuf_test_messages\proto3\ForeignEnum::FromInt($d->readVarint());
          }
          break;
        case 54:
          $this->repeated_string_piece []= $d->readString();
          break;
        case 55:
          $this->repeated_cord []= $d->readString();
          break;
        case 56:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapInt32Int32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int32_int32[$obj->key] = $obj->value;
          break;
        case 57:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapInt64Int64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int64_int64[$obj->key] = $obj->value;
          break;
        case 58:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapUint32Uint32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_uint32_uint32[$obj->key] = $obj->value;
          break;
        case 59:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapUint64Uint64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_uint64_uint64[$obj->key] = $obj->value;
          break;
        case 60:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapSint32Sint32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_sint32_sint32[$obj->key] = $obj->value;
          break;
        case 61:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapSint64Sint64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_sint64_sint64[$obj->key] = $obj->value;
          break;
        case 62:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapFixed32Fixed32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_fixed32_fixed32[$obj->key] = $obj->value;
          break;
        case 63:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapFixed64Fixed64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_fixed64_fixed64[$obj->key] = $obj->value;
          break;
        case 64:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapSfixed32Sfixed32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_sfixed32_sfixed32[$obj->key] = $obj->value;
          break;
        case 65:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapSfixed64Sfixed64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_sfixed64_sfixed64[$obj->key] = $obj->value;
          break;
        case 66:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapInt32FloatEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int32_float[$obj->key] = $obj->value;
          break;
        case 67:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapInt32DoubleEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int32_double[$obj->key] = $obj->value;
          break;
        case 68:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapBoolBoolEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_bool_bool[\Protobuf\BoolMapKey::FromBool($obj->key)] = $obj->value;
          break;
        case 69:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringStringEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_string[$obj->key] = $obj->value;
          break;
        case 70:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringBytesEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_bytes[$obj->key] = $obj->value;
          break;
        case 71:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringNestedMessageEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_nested_message[$obj->key] = $obj->value ?? new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
          break;
        case 72:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringForeignMessageEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_foreign_message[$obj->key] = $obj->value ?? new \protobuf_test_messages\proto3\ForeignMessage();
          break;
        case 73:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringNestedEnumEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_nested_enum[$obj->key] = $obj->value;
          break;
        case 74:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringForeignEnumEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_foreign_enum[$obj->key] = $obj->value;
          break;
        case 75:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_int32 []= $packed->readVarint32Signed();
            }
          } else {
            $this->packed_int32 []= $d->readVarint32Signed();
          }
          break;
        case 76:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_int64 []= $packed->readVarint();
            }
          } else {
            $this->packed_int64 []= $d->readVarint();
          }
          break;
        case 77:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_uint32 []= $packed->readVarint32();
            }
          } else {
            $this->packed_uint32 []= $d->readVarint32();
          }
          break;
        case 78:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_uint64 []= $packed->readVarint();
            }
          } else {
            $this->packed_uint64 []= $d->readVarint();
          }
          break;
        case 79:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_sint32 []= $packed->readVarintZigZag32();
            }
          } else {
            $this->packed_sint32 []= $d->readVarintZigZag32();
          }
          break;
        case 80:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_sint64 []= $packed->readVarintZigZag64();
            }
          } else {
            $this->packed_sint64 []= $d->readVarintZigZag64();
          }
          break;
        case 81:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_fixed32 []= $packed->readLittleEndianInt32Unsigned();
            }
          } else {
            $this->packed_fixed32 []= $d->readLittleEndianInt32Unsigned();
          }
          break;
        case 82:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_fixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->packed_fixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 83:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_sfixed32 []= $packed->readLittleEndianInt32Signed();
            }
          } else {
            $this->packed_sfixed32 []= $d->readLittleEndianInt32Signed();
          }
          break;
        case 84:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_sfixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->packed_sfixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 85:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_float []= $packed->readFloat();
            }
          } else {
            $this->packed_float []= $d->readFloat();
          }
          break;
        case 86:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_double []= $packed->readDouble();
            }
          } else {
            $this->packed_double []= $d->readDouble();
          }
          break;
        case 87:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_bool []= $packed->readBool();
            }
          } else {
            $this->packed_bool []= $d->readBool();
          }
          break;
        case 88:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_nested_enum []= \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt($packed->readVarint());
            }
          } else {
            $this->packed_nested_enum []= \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt($d->readVarint());
          }
          break;
        case 89:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_int32 []= $packed->readVarint32Signed();
            }
          } else {
            $this->unpacked_int32 []= $d->readVarint32Signed();
          }
          break;
        case 90:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_int64 []= $packed->readVarint();
            }
          } else {
            $this->unpacked_int64 []= $d->readVarint();
          }
          break;
        case 91:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_uint32 []= $packed->readVarint32();
            }
          } else {
            $this->unpacked_uint32 []= $d->readVarint32();
          }
          break;
        case 92:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_uint64 []= $packed->readVarint();
            }
          } else {
            $this->unpacked_uint64 []= $d->readVarint();
          }
          break;
        case 93:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_sint32 []= $packed->readVarintZigZag32();
            }
          } else {
            $this->unpacked_sint32 []= $d->readVarintZigZag32();
          }
          break;
        case 94:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_sint64 []= $packed->readVarintZigZag64();
            }
          } else {
            $this->unpacked_sint64 []= $d->readVarintZigZag64();
          }
          break;
        case 95:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_fixed32 []= $packed->readLittleEndianInt32Unsigned();
            }
          } else {
            $this->unpacked_fixed32 []= $d->readLittleEndianInt32Unsigned();
          }
          break;
        case 96:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_fixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->unpacked_fixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 97:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_sfixed32 []= $packed->readLittleEndianInt32Signed();
            }
          } else {
            $this->unpacked_sfixed32 []= $d->readLittleEndianInt32Signed();
          }
          break;
        case 98:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_sfixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->unpacked_sfixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 99:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_float []= $packed->readFloat();
            }
          } else {
            $this->unpacked_float []= $d->readFloat();
          }
          break;
        case 100:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_double []= $packed->readDouble();
            }
          } else {
            $this->unpacked_double []= $d->readDouble();
          }
          break;
        case 101:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_bool []= $packed->readBool();
            }
          } else {
            $this->unpacked_bool []= $d->readBool();
          }
          break;
        case 102:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_nested_enum []= \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt($packed->readVarint());
            }
          } else {
            $this->unpacked_nested_enum []= \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt($d->readVarint());
          }
          break;
        case 111:
          $this->oneof_field = new TestAllTypesProto3_oneof_uint32($d->readVarint32());
          break;
        case 112:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
          $obj->MergeFrom($d->readDecoder());
          $this->oneof_field = new TestAllTypesProto3_oneof_nested_message($obj);
          break;
        case 113:
          $this->oneof_field = new TestAllTypesProto3_oneof_string($d->readString());
          break;
        case 114:
          $this->oneof_field = new TestAllTypesProto3_oneof_bytes($d->readString());
          break;
        case 115:
          $this->oneof_field = new TestAllTypesProto3_oneof_bool($d->readBool());
          break;
        case 116:
          $this->oneof_field = new TestAllTypesProto3_oneof_uint64($d->readVarint());
          break;
        case 117:
          $this->oneof_field = new TestAllTypesProto3_oneof_float($d->readFloat());
          break;
        case 118:
          $this->oneof_field = new TestAllTypesProto3_oneof_double($d->readDouble());
          break;
        case 119:
          $this->oneof_field = new TestAllTypesProto3_oneof_enum(\protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt($d->readVarint()));
          break;
        case 120:
          $this->oneof_field = new TestAllTypesProto3_oneof_null_value(\google\protobuf\NullValue::FromInt($d->readVarint()));
          break;
        case 201:
          if ($this->optional_bool_wrapper == null) $this->optional_bool_wrapper = new \google\protobuf\BoolValue();
          $this->optional_bool_wrapper->MergeFrom($d->readDecoder());
          break;
        case 202:
          if ($this->optional_int32_wrapper == null) $this->optional_int32_wrapper = new \google\protobuf\Int32Value();
          $this->optional_int32_wrapper->MergeFrom($d->readDecoder());
          break;
        case 203:
          if ($this->optional_int64_wrapper == null) $this->optional_int64_wrapper = new \google\protobuf\Int64Value();
          $this->optional_int64_wrapper->MergeFrom($d->readDecoder());
          break;
        case 204:
          if ($this->optional_uint32_wrapper == null) $this->optional_uint32_wrapper = new \google\protobuf\UInt32Value();
          $this->optional_uint32_wrapper->MergeFrom($d->readDecoder());
          break;
        case 205:
          if ($this->optional_uint64_wrapper == null) $this->optional_uint64_wrapper = new \google\protobuf\UInt64Value();
          $this->optional_uint64_wrapper->MergeFrom($d->readDecoder());
          break;
        case 206:
          if ($this->optional_float_wrapper == null) $this->optional_float_wrapper = new \google\protobuf\FloatValue();
          $this->optional_float_wrapper->MergeFrom($d->readDecoder());
          break;
        case 207:
          if ($this->optional_double_wrapper == null) $this->optional_double_wrapper = new \google\protobuf\DoubleValue();
          $this->optional_double_wrapper->MergeFrom($d->readDecoder());
          break;
        case 208:
          if ($this->optional_string_wrapper == null) $this->optional_string_wrapper = new \google\protobuf\StringValue();
          $this->optional_string_wrapper->MergeFrom($d->readDecoder());
          break;
        case 209:
          if ($this->optional_bytes_wrapper == null) $this->optional_bytes_wrapper = new \google\protobuf\BytesValue();
          $this->optional_bytes_wrapper->MergeFrom($d->readDecoder());
          break;
        case 211:
          $obj = new \google\protobuf\BoolValue();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_bool_wrapper []= $obj;
          break;
        case 212:
          $obj = new \google\protobuf\Int32Value();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_int32_wrapper []= $obj;
          break;
        case 213:
          $obj = new \google\protobuf\Int64Value();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_int64_wrapper []= $obj;
          break;
        case 214:
          $obj = new \google\protobuf\UInt32Value();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_uint32_wrapper []= $obj;
          break;
        case 215:
          $obj = new \google\protobuf\UInt64Value();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_uint64_wrapper []= $obj;
          break;
        case 216:
          $obj = new \google\protobuf\FloatValue();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_float_wrapper []= $obj;
          break;
        case 217:
          $obj = new \google\protobuf\DoubleValue();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_double_wrapper []= $obj;
          break;
        case 218:
          $obj = new \google\protobuf\StringValue();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_string_wrapper []= $obj;
          break;
        case 219:
          $obj = new \google\protobuf\BytesValue();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_bytes_wrapper []= $obj;
          break;
        case 301:
          if ($this->optional_duration == null) $this->optional_duration = new \google\protobuf\Duration();
          $this->optional_duration->MergeFrom($d->readDecoder());
          break;
        case 302:
          if ($this->optional_timestamp == null) $this->optional_timestamp = new \google\protobuf\Timestamp();
          $this->optional_timestamp->MergeFrom($d->readDecoder());
          break;
        case 303:
          if ($this->optional_field_mask == null) $this->optional_field_mask = new \google\protobuf\FieldMask();
          $this->optional_field_mask->MergeFrom($d->readDecoder());
          break;
        case 304:
          if ($this->optional_struct == null) $this->optional_struct = new \google\protobuf\Struct();
          $this->optional_struct->MergeFrom($d->readDecoder());
          break;
        case 305:
          if ($this->optional_any == null) $this->optional_any = new \google\protobuf\Any();
          $this->optional_any->MergeFrom($d->readDecoder());
          break;
        case 306:
          if ($this->optional_value == null) $this->optional_value = new \google\protobuf\Value();
          $this->optional_value->MergeFrom($d->readDecoder());
          break;
        case 307:
          $this->optional_null_value = \google\protobuf\NullValue::FromInt($d->readVarint());
          break;
        case 311:
          $obj = new \google\protobuf\Duration();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_duration []= $obj;
          break;
        case 312:
          $obj = new \google\protobuf\Timestamp();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_timestamp []= $obj;
          break;
        case 313:
          $obj = new \google\protobuf\FieldMask();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_fieldmask []= $obj;
          break;
        case 315:
          $obj = new \google\protobuf\Any();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_any []= $obj;
          break;
        case 316:
          $obj = new \google\protobuf\Value();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_value []= $obj;
          break;
        case 317:
          $obj = new \google\protobuf\ListValue();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_list_value []= $obj;
          break;
        case 324:
          $obj = new \google\protobuf\Struct();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_struct []= $obj;
          break;
        case 401:
          $this->fieldname1 = $d->readVarint32Signed();
          break;
        case 402:
          $this->field_name2 = $d->readVarint32Signed();
          break;
        case 403:
          $this->_field_name3 = $d->readVarint32Signed();
          break;
        case 404:
          $this->field__name4_ = $d->readVarint32Signed();
          break;
        case 405:
          $this->field0name5 = $d->readVarint32Signed();
          break;
        case 406:
          $this->field_0_name6 = $d->readVarint32Signed();
          break;
        case 407:
          $this->fieldName7 = $d->readVarint32Signed();
          break;
        case 408:
          $this->FieldName8 = $d->readVarint32Signed();
          break;
        case 409:
          $this->field_Name9 = $d->readVarint32Signed();
          break;
        case 410:
          $this->Field_Name10 = $d->readVarint32Signed();
          break;
        case 411:
          $this->FIELD_NAME11 = $d->readVarint32Signed();
          break;
        case 412:
          $this->FIELD_name12 = $d->readVarint32Signed();
          break;
        case 413:
          $this->__field_name13 = $d->readVarint32Signed();
          break;
        case 414:
          $this->__Field_name14 = $d->readVarint32Signed();
          break;
        case 415:
          $this->field__name15 = $d->readVarint32Signed();
          break;
        case 416:
          $this->field__Name16 = $d->readVarint32Signed();
          break;
        case 417:
          $this->field_name17__ = $d->readVarint32Signed();
          break;
        case 418:
          $this->Field_name18__ = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->optional_int32 !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->optional_int32);
    }
    if ($this->optional_int64 !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->optional_int64);
    }
    if ($this->optional_uint32 !== 0) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->optional_uint32);
    }
    if ($this->optional_uint64 !== 0) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->optional_uint64);
    }
    if ($this->optional_sint32 !== 0) {
      $e->writeTag(5, 0);
      $e->writeVarintZigZag32($this->optional_sint32);
    }
    if ($this->optional_sint64 !== 0) {
      $e->writeTag(6, 0);
      $e->writeVarintZigZag64($this->optional_sint64);
    }
    if ($this->optional_fixed32 !== 0) {
      $e->writeTag(7, 5);
      $e->writeLittleEndianInt32Unsigned($this->optional_fixed32);
    }
    if ($this->optional_fixed64 !== 0) {
      $e->writeTag(8, 1);
      $e->writeLittleEndianInt64($this->optional_fixed64);
    }
    if ($this->optional_sfixed32 !== 0) {
      $e->writeTag(9, 5);
      $e->writeLittleEndianInt32Signed($this->optional_sfixed32);
    }
    if ($this->optional_sfixed64 !== 0) {
      $e->writeTag(10, 1);
      $e->writeLittleEndianInt64($this->optional_sfixed64);
    }
    if ($this->optional_float !== 0.0) {
      $e->writeTag(11, 5);
      $e->writeFloat($this->optional_float);
    }
    if ($this->optional_double !== 0.0) {
      $e->writeTag(12, 1);
      $e->writeDouble($this->optional_double);
    }
    if ($this->optional_bool !== false) {
      $e->writeTag(13, 0);
      $e->writeBool($this->optional_bool);
    }
    if ($this->optional_string !== '') {
      $e->writeTag(14, 2);
      $e->writeString($this->optional_string);
    }
    if ($this->optional_bytes !== '') {
      $e->writeTag(15, 2);
      $e->writeString($this->optional_bytes);
    }
    $msg = $this->optional_nested_message;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 18);
    }
    $msg = $this->optional_foreign_message;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 19);
    }
    if ($this->optional_nested_enum !== \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt(0)) {
      $e->writeTag(21, 0);
      $e->writeVarint($this->optional_nested_enum);
    }
    if ($this->optional_foreign_enum !== \protobuf_test_messages\proto3\ForeignEnum::FromInt(0)) {
      $e->writeTag(22, 0);
      $e->writeVarint($this->optional_foreign_enum);
    }
    if ($this->optional_aliased_enum !== \protobuf_test_messages\proto3\TestAllTypesProto3_AliasedEnum::FromInt(0)) {
      $e->writeTag(23, 0);
      $e->writeVarint($this->optional_aliased_enum);
    }
    if ($this->optional_string_piece !== '') {
      $e->writeTag(24, 2);
      $e->writeString($this->optional_string_piece);
    }
    if ($this->optional_cord !== '') {
      $e->writeTag(25, 2);
      $e->writeString($this->optional_cord);
    }
    $msg = $this->recursive_message;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 27);
    }
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->repeated_int32 as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 31);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->repeated_int64 as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 32);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->repeated_uint32 as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 33);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->repeated_uint64 as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 34);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->repeated_sint32 as $elem) {
      $packed->writeVarintZigZag32($elem);
    }
    $e->writeEncoder($packed, 35);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->repeated_sint64 as $elem) {
      $packed->writeVarintZigZag64($elem);
    }
    $e->writeEncoder($packed, 36);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->repeated_fixed32 as $elem) {
      $packed->writeLittleEndianInt32Unsigned($elem);
    }
    $e->writeEncoder($packed, 37);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->repeated_fixed64 as $elem) {
      $packed->writeLittleEndianInt64($elem);
    }
    $e->writeEncoder($packed, 38);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->repeated_sfixed32 as $elem) {
      $packed->writeLittleEndianInt32Signed($elem);
    }
    $e->writeEncoder($packed, 39);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->repeated_sfixed64 as $elem) {
      $packed->writeLittleEndianInt64($elem);
    }
    $e->writeEncoder($packed, 40);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->repeated_float as $elem) {
      $packed->writeFloat($elem);
    }
    $e->writeEncoder($packed, 41);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->repeated_double as $elem) {
      $packed->writeDouble($elem);
    }
    $e->writeEncoder($packed, 42);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->repeated_bool as $elem) {
      $packed->writeBool($elem);
    }
    $e->writeEncoder($packed, 43);
    foreach ($this->repeated_string as $elem) {
      $e->writeTag(44, 2);
      $e->writeString($elem);
    }
    foreach ($this->repeated_bytes as $elem) {
      $e->writeTag(45, 2);
      $e->writeString($elem);
    }
    foreach ($this->repeated_nested_message as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 48);
    }
    foreach ($this->repeated_foreign_message as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 49);
    }
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->repeated_nested_enum as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 51);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->repeated_foreign_enum as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 52);
    foreach ($this->repeated_string_piece as $elem) {
      $e->writeTag(54, 2);
      $e->writeString($elem);
    }
    foreach ($this->repeated_cord as $elem) {
      $e->writeTag(55, 2);
      $e->writeString($elem);
    }
    foreach ($this->map_int32_int32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapInt32Int32Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 56);
    }
    foreach ($this->map_int64_int64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapInt64Int64Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 57);
    }
    foreach ($this->map_uint32_uint32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapUint32Uint32Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 58);
    }
    foreach ($this->map_uint64_uint64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapUint64Uint64Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 59);
    }
    foreach ($this->map_sint32_sint32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapSint32Sint32Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 60);
    }
    foreach ($this->map_sint64_sint64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapSint64Sint64Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 61);
    }
    foreach ($this->map_fixed32_fixed32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapFixed32Fixed32Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 62);
    }
    foreach ($this->map_fixed64_fixed64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapFixed64Fixed64Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 63);
    }
    foreach ($this->map_sfixed32_sfixed32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapSfixed32Sfixed32Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 64);
    }
    foreach ($this->map_sfixed64_sfixed64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapSfixed64Sfixed64Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 65);
    }
    foreach ($this->map_int32_float as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapInt32FloatEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 66);
    }
    foreach ($this->map_int32_double as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapInt32DoubleEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 67);
    }
    foreach ($this->map_bool_bool as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapBoolBoolEntry();
      $obj->key = \Protobuf\BoolMapKey::ToBool($k);
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 68);
    }
    foreach ($this->map_string_string as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringStringEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 69);
    }
    foreach ($this->map_string_bytes as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringBytesEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 70);
    }
    foreach ($this->map_string_nested_message as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringNestedMessageEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 71);
    }
    foreach ($this->map_string_foreign_message as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringForeignMessageEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 72);
    }
    foreach ($this->map_string_nested_enum as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringNestedEnumEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 73);
    }
    foreach ($this->map_string_foreign_enum as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringForeignEnumEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 74);
    }
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_int32 as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 75);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_int64 as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 76);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_uint32 as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 77);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_uint64 as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 78);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_sint32 as $elem) {
      $packed->writeVarintZigZag32($elem);
    }
    $e->writeEncoder($packed, 79);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_sint64 as $elem) {
      $packed->writeVarintZigZag64($elem);
    }
    $e->writeEncoder($packed, 80);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_fixed32 as $elem) {
      $packed->writeLittleEndianInt32Unsigned($elem);
    }
    $e->writeEncoder($packed, 81);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_fixed64 as $elem) {
      $packed->writeLittleEndianInt64($elem);
    }
    $e->writeEncoder($packed, 82);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_sfixed32 as $elem) {
      $packed->writeLittleEndianInt32Signed($elem);
    }
    $e->writeEncoder($packed, 83);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_sfixed64 as $elem) {
      $packed->writeLittleEndianInt64($elem);
    }
    $e->writeEncoder($packed, 84);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_float as $elem) {
      $packed->writeFloat($elem);
    }
    $e->writeEncoder($packed, 85);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_double as $elem) {
      $packed->writeDouble($elem);
    }
    $e->writeEncoder($packed, 86);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_bool as $elem) {
      $packed->writeBool($elem);
    }
    $e->writeEncoder($packed, 87);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_nested_enum as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 88);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->unpacked_int32 as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 89);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->unpacked_int64 as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 90);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->unpacked_uint32 as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 91);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->unpacked_uint64 as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 92);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->unpacked_sint32 as $elem) {
      $packed->writeVarintZigZag32($elem);
    }
    $e->writeEncoder($packed, 93);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->unpacked_sint64 as $elem) {
      $packed->writeVarintZigZag64($elem);
    }
    $e->writeEncoder($packed, 94);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->unpacked_fixed32 as $elem) {
      $packed->writeLittleEndianInt32Unsigned($elem);
    }
    $e->writeEncoder($packed, 95);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->unpacked_fixed64 as $elem) {
      $packed->writeLittleEndianInt64($elem);
    }
    $e->writeEncoder($packed, 96);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->unpacked_sfixed32 as $elem) {
      $packed->writeLittleEndianInt32Signed($elem);
    }
    $e->writeEncoder($packed, 97);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->unpacked_sfixed64 as $elem) {
      $packed->writeLittleEndianInt64($elem);
    }
    $e->writeEncoder($packed, 98);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->unpacked_float as $elem) {
      $packed->writeFloat($elem);
    }
    $e->writeEncoder($packed, 99);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->unpacked_double as $elem) {
      $packed->writeDouble($elem);
    }
    $e->writeEncoder($packed, 100);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->unpacked_bool as $elem) {
      $packed->writeBool($elem);
    }
    $e->writeEncoder($packed, 101);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->unpacked_nested_enum as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 102);
    $msg = $this->optional_bool_wrapper;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 201);
    }
    $msg = $this->optional_int32_wrapper;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 202);
    }
    $msg = $this->optional_int64_wrapper;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 203);
    }
    $msg = $this->optional_uint32_wrapper;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 204);
    }
    $msg = $this->optional_uint64_wrapper;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 205);
    }
    $msg = $this->optional_float_wrapper;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 206);
    }
    $msg = $this->optional_double_wrapper;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 207);
    }
    $msg = $this->optional_string_wrapper;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 208);
    }
    $msg = $this->optional_bytes_wrapper;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 209);
    }
    foreach ($this->repeated_bool_wrapper as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 211);
    }
    foreach ($this->repeated_int32_wrapper as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 212);
    }
    foreach ($this->repeated_int64_wrapper as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 213);
    }
    foreach ($this->repeated_uint32_wrapper as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 214);
    }
    foreach ($this->repeated_uint64_wrapper as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 215);
    }
    foreach ($this->repeated_float_wrapper as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 216);
    }
    foreach ($this->repeated_double_wrapper as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 217);
    }
    foreach ($this->repeated_string_wrapper as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 218);
    }
    foreach ($this->repeated_bytes_wrapper as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 219);
    }
    $msg = $this->optional_duration;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 301);
    }
    $msg = $this->optional_timestamp;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 302);
    }
    $msg = $this->optional_field_mask;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 303);
    }
    $msg = $this->optional_struct;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 304);
    }
    $msg = $this->optional_any;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 305);
    }
    $msg = $this->optional_value;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 306);
    }
    if ($this->optional_null_value !== \google\protobuf\NullValue::FromInt(0)) {
      $e->writeTag(307, 0);
      $e->writeVarint($this->optional_null_value);
    }
    foreach ($this->repeated_duration as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 311);
    }
    foreach ($this->repeated_timestamp as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 312);
    }
    foreach ($this->repeated_fieldmask as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 313);
    }
    foreach ($this->repeated_any as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 315);
    }
    foreach ($this->repeated_value as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 316);
    }
    foreach ($this->repeated_list_value as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 317);
    }
    foreach ($this->repeated_struct as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 324);
    }
    if ($this->fieldname1 !== 0) {
      $e->writeTag(401, 0);
      $e->writeVarint($this->fieldname1);
    }
    if ($this->field_name2 !== 0) {
      $e->writeTag(402, 0);
      $e->writeVarint($this->field_name2);
    }
    if ($this->_field_name3 !== 0) {
      $e->writeTag(403, 0);
      $e->writeVarint($this->_field_name3);
    }
    if ($this->field__name4_ !== 0) {
      $e->writeTag(404, 0);
      $e->writeVarint($this->field__name4_);
    }
    if ($this->field0name5 !== 0) {
      $e->writeTag(405, 0);
      $e->writeVarint($this->field0name5);
    }
    if ($this->field_0_name6 !== 0) {
      $e->writeTag(406, 0);
      $e->writeVarint($this->field_0_name6);
    }
    if ($this->fieldName7 !== 0) {
      $e->writeTag(407, 0);
      $e->writeVarint($this->fieldName7);
    }
    if ($this->FieldName8 !== 0) {
      $e->writeTag(408, 0);
      $e->writeVarint($this->FieldName8);
    }
    if ($this->field_Name9 !== 0) {
      $e->writeTag(409, 0);
      $e->writeVarint($this->field_Name9);
    }
    if ($this->Field_Name10 !== 0) {
      $e->writeTag(410, 0);
      $e->writeVarint($this->Field_Name10);
    }
    if ($this->FIELD_NAME11 !== 0) {
      $e->writeTag(411, 0);
      $e->writeVarint($this->FIELD_NAME11);
    }
    if ($this->FIELD_name12 !== 0) {
      $e->writeTag(412, 0);
      $e->writeVarint($this->FIELD_name12);
    }
    if ($this->__field_name13 !== 0) {
      $e->writeTag(413, 0);
      $e->writeVarint($this->__field_name13);
    }
    if ($this->__Field_name14 !== 0) {
      $e->writeTag(414, 0);
      $e->writeVarint($this->__Field_name14);
    }
    if ($this->field__name15 !== 0) {
      $e->writeTag(415, 0);
      $e->writeVarint($this->field__name15);
    }
    if ($this->field__Name16 !== 0) {
      $e->writeTag(416, 0);
      $e->writeVarint($this->field__Name16);
    }
    if ($this->field_name17__ !== 0) {
      $e->writeTag(417, 0);
      $e->writeVarint($this->field_name17__);
    }
    if ($this->Field_name18__ !== 0) {
      $e->writeTag(418, 0);
      $e->writeVarint($this->Field_name18__);
    }
    $this->oneof_field->WriteTo($e);
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('optional_int32', 'optionalInt32', $this->optional_int32, false);
    $e->writeInt64Signed('optional_int64', 'optionalInt64', $this->optional_int64, false);
    $e->writeInt32('optional_uint32', 'optionalUint32', $this->optional_uint32, false);
    $e->writeInt64Unsigned('optional_uint64', 'optionalUint64', $this->optional_uint64, false);
    $e->writeInt32('optional_sint32', 'optionalSint32', $this->optional_sint32, false);
    $e->writeInt64Signed('optional_sint64', 'optionalSint64', $this->optional_sint64, false);
    $e->writeInt32('optional_fixed32', 'optionalFixed32', $this->optional_fixed32, false);
    $e->writeInt64Unsigned('optional_fixed64', 'optionalFixed64', $this->optional_fixed64, false);
    $e->writeInt32('optional_sfixed32', 'optionalSfixed32', $this->optional_sfixed32, false);
    $e->writeInt64Signed('optional_sfixed64', 'optionalSfixed64', $this->optional_sfixed64, false);
    $e->writeFloat('optional_float', 'optionalFloat', $this->optional_float, false);
    $e->writeFloat('optional_double', 'optionalDouble', $this->optional_double, false);
    $e->writeBool('optional_bool', 'optionalBool', $this->optional_bool, false);
    $e->writeString('optional_string', 'optionalString', $this->optional_string, false);
    $e->writeBytes('optional_bytes', 'optionalBytes', $this->optional_bytes, false);
    $e->writeMessage('optional_nested_message', 'optionalNestedMessage', $this->optional_nested_message, false);
    $e->writeMessage('optional_foreign_message', 'optionalForeignMessage', $this->optional_foreign_message, false);
    $e->writeEnum('optional_nested_enum', 'optionalNestedEnum', \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::ToStringDict(), $this->optional_nested_enum, false);
    $e->writeEnum('optional_foreign_enum', 'optionalForeignEnum', \protobuf_test_messages\proto3\ForeignEnum::ToStringDict(), $this->optional_foreign_enum, false);
    $e->writeEnum('optional_aliased_enum', 'optionalAliasedEnum', \protobuf_test_messages\proto3\TestAllTypesProto3_AliasedEnum::ToStringDict(), $this->optional_aliased_enum, false);
    $e->writeString('optional_string_piece', 'optionalStringPiece', $this->optional_string_piece, false);
    $e->writeString('optional_cord', 'optionalCord', $this->optional_cord, false);
    $e->writeMessage('recursive_message', 'recursiveMessage', $this->recursive_message, false);
    $e->writePrimitiveList('repeated_int32', 'repeatedInt32', $this->repeated_int32);
    $e->writeInt64SignedList('repeated_int64', 'repeatedInt64', $this->repeated_int64);
    $e->writePrimitiveList('repeated_uint32', 'repeatedUint32', $this->repeated_uint32);
    $e->writeInt64UnsignedList('repeated_uint64', 'repeatedUint64', $this->repeated_uint64);
    $e->writePrimitiveList('repeated_sint32', 'repeatedSint32', $this->repeated_sint32);
    $e->writeInt64SignedList('repeated_sint64', 'repeatedSint64', $this->repeated_sint64);
    $e->writePrimitiveList('repeated_fixed32', 'repeatedFixed32', $this->repeated_fixed32);
    $e->writeInt64UnsignedList('repeated_fixed64', 'repeatedFixed64', $this->repeated_fixed64);
    $e->writePrimitiveList('repeated_sfixed32', 'repeatedSfixed32', $this->repeated_sfixed32);
    $e->writeInt64SignedList('repeated_sfixed64', 'repeatedSfixed64', $this->repeated_sfixed64);
    $e->writeFloatList('repeated_float', 'repeatedFloat', $this->repeated_float);
    $e->writeFloatList('repeated_double', 'repeatedDouble', $this->repeated_double);
    $e->writePrimitiveList('repeated_bool', 'repeatedBool', $this->repeated_bool);
    $e->writePrimitiveList('repeated_string', 'repeatedString', $this->repeated_string);
    $e->writeBytesList('repeated_bytes', 'repeatedBytes', $this->repeated_bytes);
    $e->writeMessageList('repeated_nested_message', 'repeatedNestedMessage', $this->repeated_nested_message);
    $e->writeMessageList('repeated_foreign_message', 'repeatedForeignMessage', $this->repeated_foreign_message);
    $e->writeEnumList('repeated_nested_enum', 'repeatedNestedEnum', \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::ToStringDict(), $this->repeated_nested_enum);
    $e->writeEnumList('repeated_foreign_enum', 'repeatedForeignEnum', \protobuf_test_messages\proto3\ForeignEnum::ToStringDict(), $this->repeated_foreign_enum);
    $e->writePrimitiveList('repeated_string_piece', 'repeatedStringPiece', $this->repeated_string_piece);
    $e->writePrimitiveList('repeated_cord', 'repeatedCord', $this->repeated_cord);
    $e->writePrimitiveMap('map_int32_int32', 'mapInt32Int32', $this->map_int32_int32);
    $e->writeInt64SignedMap('map_int64_int64', 'mapInt64Int64', $this->map_int64_int64);
    $e->writePrimitiveMap('map_uint32_uint32', 'mapUint32Uint32', $this->map_uint32_uint32);
    $e->writeInt64UnsignedMap('map_uint64_uint64', 'mapUint64Uint64', $this->map_uint64_uint64);
    $e->writePrimitiveMap('map_sint32_sint32', 'mapSint32Sint32', $this->map_sint32_sint32);
    $e->writeInt64SignedMap('map_sint64_sint64', 'mapSint64Sint64', $this->map_sint64_sint64);
    $e->writePrimitiveMap('map_fixed32_fixed32', 'mapFixed32Fixed32', $this->map_fixed32_fixed32);
    $e->writeInt64UnsignedMap('map_fixed64_fixed64', 'mapFixed64Fixed64', $this->map_fixed64_fixed64);
    $e->writePrimitiveMap('map_sfixed32_sfixed32', 'mapSfixed32Sfixed32', $this->map_sfixed32_sfixed32);
    $e->writeInt64SignedMap('map_sfixed64_sfixed64', 'mapSfixed64Sfixed64', $this->map_sfixed64_sfixed64);
    $e->writeFloatMap('map_int32_float', 'mapInt32Float', $this->map_int32_float);
    $e->writeFloatMap('map_int32_double', 'mapInt32Double', $this->map_int32_double);
    $e->writePrimitiveMap('map_bool_bool', 'mapBoolBool', $this->map_bool_bool);
    $e->writePrimitiveMap('map_string_string', 'mapStringString', $this->map_string_string);
    $e->writeBytesMap('map_string_bytes', 'mapStringBytes', $this->map_string_bytes);
    $e->writeMessageMap('map_string_nested_message', 'mapStringNestedMessage', $this->map_string_nested_message);
    $e->writeMessageMap('map_string_foreign_message', 'mapStringForeignMessage', $this->map_string_foreign_message);
    $e->writeEnumMap('map_string_nested_enum', 'mapStringNestedEnum', \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::ToStringDict(), $this->map_string_nested_enum);
    $e->writeEnumMap('map_string_foreign_enum', 'mapStringForeignEnum', \protobuf_test_messages\proto3\ForeignEnum::ToStringDict(), $this->map_string_foreign_enum);
    $e->writePrimitiveList('packed_int32', 'packedInt32', $this->packed_int32);
    $e->writeInt64SignedList('packed_int64', 'packedInt64', $this->packed_int64);
    $e->writePrimitiveList('packed_uint32', 'packedUint32', $this->packed_uint32);
    $e->writeInt64UnsignedList('packed_uint64', 'packedUint64', $this->packed_uint64);
    $e->writePrimitiveList('packed_sint32', 'packedSint32', $this->packed_sint32);
    $e->writeInt64SignedList('packed_sint64', 'packedSint64', $this->packed_sint64);
    $e->writePrimitiveList('packed_fixed32', 'packedFixed32', $this->packed_fixed32);
    $e->writeInt64UnsignedList('packed_fixed64', 'packedFixed64', $this->packed_fixed64);
    $e->writePrimitiveList('packed_sfixed32', 'packedSfixed32', $this->packed_sfixed32);
    $e->writeInt64SignedList('packed_sfixed64', 'packedSfixed64', $this->packed_sfixed64);
    $e->writeFloatList('packed_float', 'packedFloat', $this->packed_float);
    $e->writeFloatList('packed_double', 'packedDouble', $this->packed_double);
    $e->writePrimitiveList('packed_bool', 'packedBool', $this->packed_bool);
    $e->writeEnumList('packed_nested_enum', 'packedNestedEnum', \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::ToStringDict(), $this->packed_nested_enum);
    $e->writePrimitiveList('unpacked_int32', 'unpackedInt32', $this->unpacked_int32);
    $e->writeInt64SignedList('unpacked_int64', 'unpackedInt64', $this->unpacked_int64);
    $e->writePrimitiveList('unpacked_uint32', 'unpackedUint32', $this->unpacked_uint32);
    $e->writeInt64UnsignedList('unpacked_uint64', 'unpackedUint64', $this->unpacked_uint64);
    $e->writePrimitiveList('unpacked_sint32', 'unpackedSint32', $this->unpacked_sint32);
    $e->writeInt64SignedList('unpacked_sint64', 'unpackedSint64', $this->unpacked_sint64);
    $e->writePrimitiveList('unpacked_fixed32', 'unpackedFixed32', $this->unpacked_fixed32);
    $e->writeInt64UnsignedList('unpacked_fixed64', 'unpackedFixed64', $this->unpacked_fixed64);
    $e->writePrimitiveList('unpacked_sfixed32', 'unpackedSfixed32', $this->unpacked_sfixed32);
    $e->writeInt64SignedList('unpacked_sfixed64', 'unpackedSfixed64', $this->unpacked_sfixed64);
    $e->writeFloatList('unpacked_float', 'unpackedFloat', $this->unpacked_float);
    $e->writeFloatList('unpacked_double', 'unpackedDouble', $this->unpacked_double);
    $e->writePrimitiveList('unpacked_bool', 'unpackedBool', $this->unpacked_bool);
    $e->writeEnumList('unpacked_nested_enum', 'unpackedNestedEnum', \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::ToStringDict(), $this->unpacked_nested_enum);
    $e->writeMessage('optional_bool_wrapper', 'optionalBoolWrapper', $this->optional_bool_wrapper, false);
    $e->writeMessage('optional_int32_wrapper', 'optionalInt32Wrapper', $this->optional_int32_wrapper, false);
    $e->writeMessage('optional_int64_wrapper', 'optionalInt64Wrapper', $this->optional_int64_wrapper, false);
    $e->writeMessage('optional_uint32_wrapper', 'optionalUint32Wrapper', $this->optional_uint32_wrapper, false);
    $e->writeMessage('optional_uint64_wrapper', 'optionalUint64Wrapper', $this->optional_uint64_wrapper, false);
    $e->writeMessage('optional_float_wrapper', 'optionalFloatWrapper', $this->optional_float_wrapper, false);
    $e->writeMessage('optional_double_wrapper', 'optionalDoubleWrapper', $this->optional_double_wrapper, false);
    $e->writeMessage('optional_string_wrapper', 'optionalStringWrapper', $this->optional_string_wrapper, false);
    $e->writeMessage('optional_bytes_wrapper', 'optionalBytesWrapper', $this->optional_bytes_wrapper, false);
    $e->writeMessageList('repeated_bool_wrapper', 'repeatedBoolWrapper', $this->repeated_bool_wrapper);
    $e->writeMessageList('repeated_int32_wrapper', 'repeatedInt32Wrapper', $this->repeated_int32_wrapper);
    $e->writeMessageList('repeated_int64_wrapper', 'repeatedInt64Wrapper', $this->repeated_int64_wrapper);
    $e->writeMessageList('repeated_uint32_wrapper', 'repeatedUint32Wrapper', $this->repeated_uint32_wrapper);
    $e->writeMessageList('repeated_uint64_wrapper', 'repeatedUint64Wrapper', $this->repeated_uint64_wrapper);
    $e->writeMessageList('repeated_float_wrapper', 'repeatedFloatWrapper', $this->repeated_float_wrapper);
    $e->writeMessageList('repeated_double_wrapper', 'repeatedDoubleWrapper', $this->repeated_double_wrapper);
    $e->writeMessageList('repeated_string_wrapper', 'repeatedStringWrapper', $this->repeated_string_wrapper);
    $e->writeMessageList('repeated_bytes_wrapper', 'repeatedBytesWrapper', $this->repeated_bytes_wrapper);
    $e->writeMessage('optional_duration', 'optionalDuration', $this->optional_duration, false);
    $e->writeMessage('optional_timestamp', 'optionalTimestamp', $this->optional_timestamp, false);
    $e->writeMessage('optional_field_mask', 'optionalFieldMask', $this->optional_field_mask, false);
    $e->writeMessage('optional_struct', 'optionalStruct', $this->optional_struct, false);
    $e->writeMessage('optional_any', 'optionalAny', $this->optional_any, false);
    $e->writeMessage('optional_value', 'optionalValue', $this->optional_value, false);
    $e->writeEnum('optional_null_value', 'optionalNullValue', \google\protobuf\NullValue::ToStringDict(), $this->optional_null_value, false);
    $e->writeMessageList('repeated_duration', 'repeatedDuration', $this->repeated_duration);
    $e->writeMessageList('repeated_timestamp', 'repeatedTimestamp', $this->repeated_timestamp);
    $e->writeMessageList('repeated_fieldmask', 'repeatedFieldmask', $this->repeated_fieldmask);
    $e->writeMessageList('repeated_any', 'repeatedAny', $this->repeated_any);
    $e->writeMessageList('repeated_value', 'repeatedValue', $this->repeated_value);
    $e->writeMessageList('repeated_list_value', 'repeatedListValue', $this->repeated_list_value);
    $e->writeMessageList('repeated_struct', 'repeatedStruct', $this->repeated_struct);
    $e->writeInt32('fieldname1', 'fieldname1', $this->fieldname1, false);
    $e->writeInt32('field_name2', 'fieldName2', $this->field_name2, false);
    $e->writeInt32('_field_name3', 'FieldName3', $this->_field_name3, false);
    $e->writeInt32('field__name4_', 'fieldName4', $this->field__name4_, false);
    $e->writeInt32('field0name5', 'field0name5', $this->field0name5, false);
    $e->writeInt32('field_0_name6', 'field0Name6', $this->field_0_name6, false);
    $e->writeInt32('fieldName7', 'fieldName7', $this->fieldName7, false);
    $e->writeInt32('FieldName8', 'FieldName8', $this->FieldName8, false);
    $e->writeInt32('field_Name9', 'fieldName9', $this->field_Name9, false);
    $e->writeInt32('Field_Name10', 'FieldName10', $this->Field_Name10, false);
    $e->writeInt32('FIELD_NAME11', 'FIELDNAME11', $this->FIELD_NAME11, false);
    $e->writeInt32('FIELD_name12', 'FIELDName12', $this->FIELD_name12, false);
    $e->writeInt32('__field_name13', 'FieldName13', $this->__field_name13, false);
    $e->writeInt32('__Field_name14', 'FieldName14', $this->__Field_name14, false);
    $e->writeInt32('field__name15', 'fieldName15', $this->field__name15, false);
    $e->writeInt32('field__Name16', 'fieldName16', $this->field__Name16, false);
    $e->writeInt32('field_name17__', 'fieldName17', $this->field_name17__, false);
    $e->writeInt32('Field_name18__', 'FieldName18', $this->Field_name18__, false);
    $this->oneof_field->WriteJsonTo($e);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'optional_int32': case 'optionalInt32':
          $this->optional_int32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'optional_int64': case 'optionalInt64':
          $this->optional_int64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'optional_uint32': case 'optionalUint32':
          $this->optional_uint32 = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          break;
        case 'optional_uint64': case 'optionalUint64':
          $this->optional_uint64 = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'optional_sint32': case 'optionalSint32':
          $this->optional_sint32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'optional_sint64': case 'optionalSint64':
          $this->optional_sint64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'optional_fixed32': case 'optionalFixed32':
          $this->optional_fixed32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'optional_fixed64': case 'optionalFixed64':
          $this->optional_fixed64 = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'optional_sfixed32': case 'optionalSfixed32':
          $this->optional_sfixed32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'optional_sfixed64': case 'optionalSfixed64':
          $this->optional_sfixed64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'optional_float': case 'optionalFloat':
          $this->optional_float = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        case 'optional_double': case 'optionalDouble':
          $this->optional_double = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        case 'optional_bool': case 'optionalBool':
          $this->optional_bool = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'optional_string': case 'optionalString':
          $this->optional_string = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'optional_bytes': case 'optionalBytes':
          $this->optional_bytes = \Protobuf\Internal\JsonDecoder::readBytes($v);
          break;
        case 'optional_nested_message': case 'optionalNestedMessage':
          if ($v === null) break;
          if ($this->optional_nested_message == null) $this->optional_nested_message = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
          $this->optional_nested_message->MergeJsonFrom($v);
          break;
        case 'optional_foreign_message': case 'optionalForeignMessage':
          if ($v === null) break;
          if ($this->optional_foreign_message == null) $this->optional_foreign_message = new \protobuf_test_messages\proto3\ForeignMessage();
          $this->optional_foreign_message->MergeJsonFrom($v);
          break;
        case 'optional_nested_enum': case 'optionalNestedEnum':
          $this->optional_nested_enum = \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromMixed($v);
          break;
        case 'optional_foreign_enum': case 'optionalForeignEnum':
          $this->optional_foreign_enum = \protobuf_test_messages\proto3\ForeignEnum::FromMixed($v);
          break;
        case 'optional_aliased_enum': case 'optionalAliasedEnum':
          $this->optional_aliased_enum = \protobuf_test_messages\proto3\TestAllTypesProto3_AliasedEnum::FromMixed($v);
          break;
        case 'optional_string_piece': case 'optionalStringPiece':
          $this->optional_string_piece = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'optional_cord': case 'optionalCord':
          $this->optional_cord = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'recursive_message': case 'recursiveMessage':
          if ($v === null) break;
          if ($this->recursive_message == null) $this->recursive_message = new \protobuf_test_messages\proto3\TestAllTypesProto3();
          $this->recursive_message->MergeJsonFrom($v);
          break;
        case 'repeated_int32': case 'repeatedInt32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_int32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'repeated_int64': case 'repeatedInt64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_int64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'repeated_uint32': case 'repeatedUint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_uint32 []= \Protobuf\Internal\JsonDecoder::readInt32Unsigned($vv);
          }
          break;
        case 'repeated_uint64': case 'repeatedUint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_uint64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'repeated_sint32': case 'repeatedSint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_sint32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'repeated_sint64': case 'repeatedSint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_sint64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'repeated_fixed32': case 'repeatedFixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_fixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'repeated_fixed64': case 'repeatedFixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_fixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'repeated_sfixed32': case 'repeatedSfixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_sfixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'repeated_sfixed64': case 'repeatedSfixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_sfixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'repeated_float': case 'repeatedFloat':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_float []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'repeated_double': case 'repeatedDouble':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_double []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'repeated_bool': case 'repeatedBool':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_bool []= \Protobuf\Internal\JsonDecoder::readBool($vv);
          }
          break;
        case 'repeated_string': case 'repeatedString':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_string []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'repeated_bytes': case 'repeatedBytes':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_bytes []= \Protobuf\Internal\JsonDecoder::readBytes($vv);
          }
          break;
        case 'repeated_nested_message': case 'repeatedNestedMessage':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
            $obj->MergeJsonFrom($vv);
            $this->repeated_nested_message []= $obj;
          }
          break;
        case 'repeated_foreign_message': case 'repeatedForeignMessage':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \protobuf_test_messages\proto3\ForeignMessage();
            $obj->MergeJsonFrom($vv);
            $this->repeated_foreign_message []= $obj;
          }
          break;
        case 'repeated_nested_enum': case 'repeatedNestedEnum':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_nested_enum []= \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromMixed($vv);
          }
          break;
        case 'repeated_foreign_enum': case 'repeatedForeignEnum':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_foreign_enum []= \protobuf_test_messages\proto3\ForeignEnum::FromMixed($vv);
          }
          break;
        case 'repeated_string_piece': case 'repeatedStringPiece':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_string_piece []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'repeated_cord': case 'repeatedCord':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_cord []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'map_int32_int32': case 'mapInt32Int32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int32_int32[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
            }
          }
          break;
        case 'map_int64_int64': case 'mapInt64Int64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int64_int64[\Protobuf\Internal\JsonDecoder::readInt64Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
            }
          }
          break;
        case 'map_uint32_uint32': case 'mapUint32Uint32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_uint32_uint32[\Protobuf\Internal\JsonDecoder::readInt32Unsigned($k)] = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
            }
          }
          break;
        case 'map_uint64_uint64': case 'mapUint64Uint64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_uint64_uint64[\Protobuf\Internal\JsonDecoder::readInt64Unsigned($k)] = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
            }
          }
          break;
        case 'map_sint32_sint32': case 'mapSint32Sint32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_sint32_sint32[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
            }
          }
          break;
        case 'map_sint64_sint64': case 'mapSint64Sint64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_sint64_sint64[\Protobuf\Internal\JsonDecoder::readInt64Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
            }
          }
          break;
        case 'map_fixed32_fixed32': case 'mapFixed32Fixed32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_fixed32_fixed32[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
            }
          }
          break;
        case 'map_fixed64_fixed64': case 'mapFixed64Fixed64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_fixed64_fixed64[\Protobuf\Internal\JsonDecoder::readInt64Unsigned($k)] = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
            }
          }
          break;
        case 'map_sfixed32_sfixed32': case 'mapSfixed32Sfixed32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_sfixed32_sfixed32[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
            }
          }
          break;
        case 'map_sfixed64_sfixed64': case 'mapSfixed64Sfixed64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_sfixed64_sfixed64[\Protobuf\Internal\JsonDecoder::readInt64Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
            }
          }
          break;
        case 'map_int32_float': case 'mapInt32Float':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int32_float[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readFloat($v);
            }
          }
          break;
        case 'map_int32_double': case 'mapInt32Double':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int32_double[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readFloat($v);
            }
          }
          break;
        case 'map_bool_bool': case 'mapBoolBool':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_bool_bool[\Protobuf\Internal\JsonDecoder::readBoolMapKey($k)] = \Protobuf\Internal\JsonDecoder::readBool($v);
            }
          }
          break;
        case 'map_string_string': case 'mapStringString':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_string_string[\Protobuf\Internal\JsonDecoder::readString($k)] = \Protobuf\Internal\JsonDecoder::readString($v);
            }
          }
          break;
        case 'map_string_bytes': case 'mapStringBytes':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_string_bytes[\Protobuf\Internal\JsonDecoder::readString($k)] = \Protobuf\Internal\JsonDecoder::readBytes($v);
            }
          }
          break;
        case 'map_string_nested_message': case 'mapStringNestedMessage':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
              $obj->MergeJsonFrom($v);
              $this->map_string_nested_message[\Protobuf\Internal\JsonDecoder::readString($k)] = $obj;
            }
          }
          break;
        case 'map_string_foreign_message': case 'mapStringForeignMessage':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $obj = new \protobuf_test_messages\proto3\ForeignMessage();
              $obj->MergeJsonFrom($v);
              $this->map_string_foreign_message[\Protobuf\Internal\JsonDecoder::readString($k)] = $obj;
            }
          }
          break;
        case 'map_string_nested_enum': case 'mapStringNestedEnum':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_string_nested_enum[\Protobuf\Internal\JsonDecoder::readString($k)] = \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromMixed($v);
            }
          }
          break;
        case 'map_string_foreign_enum': case 'mapStringForeignEnum':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_string_foreign_enum[\Protobuf\Internal\JsonDecoder::readString($k)] = \protobuf_test_messages\proto3\ForeignEnum::FromMixed($v);
            }
          }
          break;
        case 'packed_int32': case 'packedInt32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_int32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'packed_int64': case 'packedInt64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_int64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'packed_uint32': case 'packedUint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_uint32 []= \Protobuf\Internal\JsonDecoder::readInt32Unsigned($vv);
          }
          break;
        case 'packed_uint64': case 'packedUint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_uint64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'packed_sint32': case 'packedSint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_sint32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'packed_sint64': case 'packedSint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_sint64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'packed_fixed32': case 'packedFixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_fixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'packed_fixed64': case 'packedFixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_fixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'packed_sfixed32': case 'packedSfixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_sfixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'packed_sfixed64': case 'packedSfixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_sfixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'packed_float': case 'packedFloat':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_float []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'packed_double': case 'packedDouble':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_double []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'packed_bool': case 'packedBool':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_bool []= \Protobuf\Internal\JsonDecoder::readBool($vv);
          }
          break;
        case 'packed_nested_enum': case 'packedNestedEnum':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_nested_enum []= \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromMixed($vv);
          }
          break;
        case 'unpacked_int32': case 'unpackedInt32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_int32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'unpacked_int64': case 'unpackedInt64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_int64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'unpacked_uint32': case 'unpackedUint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_uint32 []= \Protobuf\Internal\JsonDecoder::readInt32Unsigned($vv);
          }
          break;
        case 'unpacked_uint64': case 'unpackedUint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_uint64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'unpacked_sint32': case 'unpackedSint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_sint32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'unpacked_sint64': case 'unpackedSint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_sint64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'unpacked_fixed32': case 'unpackedFixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_fixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'unpacked_fixed64': case 'unpackedFixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_fixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'unpacked_sfixed32': case 'unpackedSfixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_sfixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'unpacked_sfixed64': case 'unpackedSfixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_sfixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'unpacked_float': case 'unpackedFloat':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_float []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'unpacked_double': case 'unpackedDouble':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_double []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'unpacked_bool': case 'unpackedBool':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_bool []= \Protobuf\Internal\JsonDecoder::readBool($vv);
          }
          break;
        case 'unpacked_nested_enum': case 'unpackedNestedEnum':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_nested_enum []= \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromMixed($vv);
          }
          break;
        case 'oneof_uint32': case 'oneofUint32':
          $this->oneof_field = new TestAllTypesProto3_oneof_uint32(\Protobuf\Internal\JsonDecoder::readInt32Unsigned($v));
          break;
        case 'oneof_nested_message': case 'oneofNestedMessage':
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
          $obj->MergeJsonFrom($v);
          $this->oneof_field = new TestAllTypesProto3_oneof_nested_message($obj);
          break;
        case 'oneof_string': case 'oneofString':
          $this->oneof_field = new TestAllTypesProto3_oneof_string(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'oneof_bytes': case 'oneofBytes':
          $this->oneof_field = new TestAllTypesProto3_oneof_bytes(\Protobuf\Internal\JsonDecoder::readBytes($v));
          break;
        case 'oneof_bool': case 'oneofBool':
          $this->oneof_field = new TestAllTypesProto3_oneof_bool(\Protobuf\Internal\JsonDecoder::readBool($v));
          break;
        case 'oneof_uint64': case 'oneofUint64':
          $this->oneof_field = new TestAllTypesProto3_oneof_uint64(\Protobuf\Internal\JsonDecoder::readInt64Unsigned($v));
          break;
        case 'oneof_float': case 'oneofFloat':
          $this->oneof_field = new TestAllTypesProto3_oneof_float(\Protobuf\Internal\JsonDecoder::readFloat($v));
          break;
        case 'oneof_double': case 'oneofDouble':
          $this->oneof_field = new TestAllTypesProto3_oneof_double(\Protobuf\Internal\JsonDecoder::readFloat($v));
          break;
        case 'oneof_enum': case 'oneofEnum':
          $this->oneof_field = new TestAllTypesProto3_oneof_enum(\protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromMixed($v));
          break;
        case 'oneof_null_value': case 'oneofNullValue':
          $this->oneof_field = new TestAllTypesProto3_oneof_null_value(\google\protobuf\NullValue::FromMixed($v));
          break;
        case 'optional_bool_wrapper': case 'optionalBoolWrapper':
          if ($v === null) break;
          if ($this->optional_bool_wrapper == null) $this->optional_bool_wrapper = new \google\protobuf\BoolValue();
          $this->optional_bool_wrapper->MergeJsonFrom($v);
          break;
        case 'optional_int32_wrapper': case 'optionalInt32Wrapper':
          if ($v === null) break;
          if ($this->optional_int32_wrapper == null) $this->optional_int32_wrapper = new \google\protobuf\Int32Value();
          $this->optional_int32_wrapper->MergeJsonFrom($v);
          break;
        case 'optional_int64_wrapper': case 'optionalInt64Wrapper':
          if ($v === null) break;
          if ($this->optional_int64_wrapper == null) $this->optional_int64_wrapper = new \google\protobuf\Int64Value();
          $this->optional_int64_wrapper->MergeJsonFrom($v);
          break;
        case 'optional_uint32_wrapper': case 'optionalUint32Wrapper':
          if ($v === null) break;
          if ($this->optional_uint32_wrapper == null) $this->optional_uint32_wrapper = new \google\protobuf\UInt32Value();
          $this->optional_uint32_wrapper->MergeJsonFrom($v);
          break;
        case 'optional_uint64_wrapper': case 'optionalUint64Wrapper':
          if ($v === null) break;
          if ($this->optional_uint64_wrapper == null) $this->optional_uint64_wrapper = new \google\protobuf\UInt64Value();
          $this->optional_uint64_wrapper->MergeJsonFrom($v);
          break;
        case 'optional_float_wrapper': case 'optionalFloatWrapper':
          if ($v === null) break;
          if ($this->optional_float_wrapper == null) $this->optional_float_wrapper = new \google\protobuf\FloatValue();
          $this->optional_float_wrapper->MergeJsonFrom($v);
          break;
        case 'optional_double_wrapper': case 'optionalDoubleWrapper':
          if ($v === null) break;
          if ($this->optional_double_wrapper == null) $this->optional_double_wrapper = new \google\protobuf\DoubleValue();
          $this->optional_double_wrapper->MergeJsonFrom($v);
          break;
        case 'optional_string_wrapper': case 'optionalStringWrapper':
          if ($v === null) break;
          if ($this->optional_string_wrapper == null) $this->optional_string_wrapper = new \google\protobuf\StringValue();
          $this->optional_string_wrapper->MergeJsonFrom($v);
          break;
        case 'optional_bytes_wrapper': case 'optionalBytesWrapper':
          if ($v === null) break;
          if ($this->optional_bytes_wrapper == null) $this->optional_bytes_wrapper = new \google\protobuf\BytesValue();
          $this->optional_bytes_wrapper->MergeJsonFrom($v);
          break;
        case 'repeated_bool_wrapper': case 'repeatedBoolWrapper':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\BoolValue();
            $obj->MergeJsonFrom($vv);
            $this->repeated_bool_wrapper []= $obj;
          }
          break;
        case 'repeated_int32_wrapper': case 'repeatedInt32Wrapper':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Int32Value();
            $obj->MergeJsonFrom($vv);
            $this->repeated_int32_wrapper []= $obj;
          }
          break;
        case 'repeated_int64_wrapper': case 'repeatedInt64Wrapper':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Int64Value();
            $obj->MergeJsonFrom($vv);
            $this->repeated_int64_wrapper []= $obj;
          }
          break;
        case 'repeated_uint32_wrapper': case 'repeatedUint32Wrapper':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UInt32Value();
            $obj->MergeJsonFrom($vv);
            $this->repeated_uint32_wrapper []= $obj;
          }
          break;
        case 'repeated_uint64_wrapper': case 'repeatedUint64Wrapper':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UInt64Value();
            $obj->MergeJsonFrom($vv);
            $this->repeated_uint64_wrapper []= $obj;
          }
          break;
        case 'repeated_float_wrapper': case 'repeatedFloatWrapper':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FloatValue();
            $obj->MergeJsonFrom($vv);
            $this->repeated_float_wrapper []= $obj;
          }
          break;
        case 'repeated_double_wrapper': case 'repeatedDoubleWrapper':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DoubleValue();
            $obj->MergeJsonFrom($vv);
            $this->repeated_double_wrapper []= $obj;
          }
          break;
        case 'repeated_string_wrapper': case 'repeatedStringWrapper':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\StringValue();
            $obj->MergeJsonFrom($vv);
            $this->repeated_string_wrapper []= $obj;
          }
          break;
        case 'repeated_bytes_wrapper': case 'repeatedBytesWrapper':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\BytesValue();
            $obj->MergeJsonFrom($vv);
            $this->repeated_bytes_wrapper []= $obj;
          }
          break;
        case 'optional_duration': case 'optionalDuration':
          if ($v === null) break;
          if ($this->optional_duration == null) $this->optional_duration = new \google\protobuf\Duration();
          $this->optional_duration->MergeJsonFrom($v);
          break;
        case 'optional_timestamp': case 'optionalTimestamp':
          if ($v === null) break;
          if ($this->optional_timestamp == null) $this->optional_timestamp = new \google\protobuf\Timestamp();
          $this->optional_timestamp->MergeJsonFrom($v);
          break;
        case 'optional_field_mask': case 'optionalFieldMask':
          if ($v === null) break;
          if ($this->optional_field_mask == null) $this->optional_field_mask = new \google\protobuf\FieldMask();
          $this->optional_field_mask->MergeJsonFrom($v);
          break;
        case 'optional_struct': case 'optionalStruct':
          if ($v === null) break;
          if ($this->optional_struct == null) $this->optional_struct = new \google\protobuf\Struct();
          $this->optional_struct->MergeJsonFrom($v);
          break;
        case 'optional_any': case 'optionalAny':
          if ($v === null) break;
          if ($this->optional_any == null) $this->optional_any = new \google\protobuf\Any();
          $this->optional_any->MergeJsonFrom($v);
          break;
        case 'optional_value': case 'optionalValue':
          if ($this->optional_value == null) $this->optional_value = new \google\protobuf\Value();
          $this->optional_value->MergeJsonFrom($v);
          break;
        case 'optional_null_value': case 'optionalNullValue':
          $this->optional_null_value = \google\protobuf\NullValue::FromMixed($v);
          break;
        case 'repeated_duration': case 'repeatedDuration':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Duration();
            $obj->MergeJsonFrom($vv);
            $this->repeated_duration []= $obj;
          }
          break;
        case 'repeated_timestamp': case 'repeatedTimestamp':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Timestamp();
            $obj->MergeJsonFrom($vv);
            $this->repeated_timestamp []= $obj;
          }
          break;
        case 'repeated_fieldmask': case 'repeatedFieldmask':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldMask();
            $obj->MergeJsonFrom($vv);
            $this->repeated_fieldmask []= $obj;
          }
          break;
        case 'repeated_any': case 'repeatedAny':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Any();
            $obj->MergeJsonFrom($vv);
            $this->repeated_any []= $obj;
          }
          break;
        case 'repeated_value': case 'repeatedValue':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Value();
            $obj->MergeJsonFrom($vv);
            $this->repeated_value []= $obj;
          }
          break;
        case 'repeated_list_value': case 'repeatedListValue':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\ListValue();
            $obj->MergeJsonFrom($vv);
            $this->repeated_list_value []= $obj;
          }
          break;
        case 'repeated_struct': case 'repeatedStruct':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Struct();
            $obj->MergeJsonFrom($vv);
            $this->repeated_struct []= $obj;
          }
          break;
        case 'fieldname1':
          $this->fieldname1 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field_name2': case 'fieldName2':
          $this->field_name2 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case '_field_name3': case 'FieldName3':
          $this->_field_name3 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field__name4_': case 'fieldName4':
          $this->field__name4_ = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field0name5':
          $this->field0name5 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field_0_name6': case 'field0Name6':
          $this->field_0_name6 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'fieldName7':
          $this->fieldName7 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'FieldName8':
          $this->FieldName8 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field_Name9': case 'fieldName9':
          $this->field_Name9 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'Field_Name10': case 'FieldName10':
          $this->Field_Name10 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'FIELD_NAME11': case 'FIELDNAME11':
          $this->FIELD_NAME11 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'FIELD_name12': case 'FIELDName12':
          $this->FIELD_name12 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case '__field_name13': case 'FieldName13':
          $this->__field_name13 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case '__Field_name14': case 'FieldName14':
          $this->__Field_name14 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field__name15': case 'fieldName15':
          $this->field__name15 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field__Name16': case 'fieldName16':
          $this->field__Name16 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field_name17__': case 'fieldName17':
          $this->field_name17__ = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'Field_name18__': case 'FieldName18':
          $this->Field_name18__ = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->optional_int32 = $o->optional_int32;
    $this->optional_int64 = $o->optional_int64;
    $this->optional_uint32 = $o->optional_uint32;
    $this->optional_uint64 = $o->optional_uint64;
    $this->optional_sint32 = $o->optional_sint32;
    $this->optional_sint64 = $o->optional_sint64;
    $this->optional_fixed32 = $o->optional_fixed32;
    $this->optional_fixed64 = $o->optional_fixed64;
    $this->optional_sfixed32 = $o->optional_sfixed32;
    $this->optional_sfixed64 = $o->optional_sfixed64;
    $this->optional_float = $o->optional_float;
    $this->optional_double = $o->optional_double;
    $this->optional_bool = $o->optional_bool;
    $this->optional_string = $o->optional_string;
    $this->optional_bytes = $o->optional_bytes;
    $tmp = $o->optional_nested_message;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
      $nv->CopyFrom($tmp);
      $this->optional_nested_message = $nv;
    }
    $tmp = $o->optional_foreign_message;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto3\ForeignMessage();
      $nv->CopyFrom($tmp);
      $this->optional_foreign_message = $nv;
    }
    $this->optional_nested_enum = $o->optional_nested_enum;
    $this->optional_foreign_enum = $o->optional_foreign_enum;
    $this->optional_aliased_enum = $o->optional_aliased_enum;
    $this->optional_string_piece = $o->optional_string_piece;
    $this->optional_cord = $o->optional_cord;
    $tmp = $o->recursive_message;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto3\TestAllTypesProto3();
      $nv->CopyFrom($tmp);
      $this->recursive_message = $nv;
    }
    $this->repeated_int32 = $o->repeated_int32;
    $this->repeated_int64 = $o->repeated_int64;
    $this->repeated_uint32 = $o->repeated_uint32;
    $this->repeated_uint64 = $o->repeated_uint64;
    $this->repeated_sint32 = $o->repeated_sint32;
    $this->repeated_sint64 = $o->repeated_sint64;
    $this->repeated_fixed32 = $o->repeated_fixed32;
    $this->repeated_fixed64 = $o->repeated_fixed64;
    $this->repeated_sfixed32 = $o->repeated_sfixed32;
    $this->repeated_sfixed64 = $o->repeated_sfixed64;
    $this->repeated_float = $o->repeated_float;
    $this->repeated_double = $o->repeated_double;
    $this->repeated_bool = $o->repeated_bool;
    $this->repeated_string = $o->repeated_string;
    $this->repeated_bytes = $o->repeated_bytes;
    foreach ($o->repeated_nested_message as $v) {
      $nv = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
      $nv->CopyFrom($v);
      $this->repeated_nested_message []= $nv;
    }
    foreach ($o->repeated_foreign_message as $v) {
      $nv = new \protobuf_test_messages\proto3\ForeignMessage();
      $nv->CopyFrom($v);
      $this->repeated_foreign_message []= $nv;
    }
    $this->repeated_nested_enum = $o->repeated_nested_enum;
    $this->repeated_foreign_enum = $o->repeated_foreign_enum;
    $this->repeated_string_piece = $o->repeated_string_piece;
    $this->repeated_cord = $o->repeated_cord;
    $this->map_int32_int32 = $o->map_int32_int32;
    $this->map_int64_int64 = $o->map_int64_int64;
    $this->map_uint32_uint32 = $o->map_uint32_uint32;
    $this->map_uint64_uint64 = $o->map_uint64_uint64;
    $this->map_sint32_sint32 = $o->map_sint32_sint32;
    $this->map_sint64_sint64 = $o->map_sint64_sint64;
    $this->map_fixed32_fixed32 = $o->map_fixed32_fixed32;
    $this->map_fixed64_fixed64 = $o->map_fixed64_fixed64;
    $this->map_sfixed32_sfixed32 = $o->map_sfixed32_sfixed32;
    $this->map_sfixed64_sfixed64 = $o->map_sfixed64_sfixed64;
    $this->map_int32_float = $o->map_int32_float;
    $this->map_int32_double = $o->map_int32_double;
    $this->map_bool_bool = $o->map_bool_bool;
    $this->map_string_string = $o->map_string_string;
    $this->map_string_bytes = $o->map_string_bytes;
    foreach ($o->map_string_nested_message as $k => $v) {
      $nv = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
      $nv->CopyFrom($v);
      $this->map_string_nested_message[$k] = $nv;
    }
    foreach ($o->map_string_foreign_message as $k => $v) {
      $nv = new \protobuf_test_messages\proto3\ForeignMessage();
      $nv->CopyFrom($v);
      $this->map_string_foreign_message[$k] = $nv;
    }
    $this->map_string_nested_enum = $o->map_string_nested_enum;
    $this->map_string_foreign_enum = $o->map_string_foreign_enum;
    $this->packed_int32 = $o->packed_int32;
    $this->packed_int64 = $o->packed_int64;
    $this->packed_uint32 = $o->packed_uint32;
    $this->packed_uint64 = $o->packed_uint64;
    $this->packed_sint32 = $o->packed_sint32;
    $this->packed_sint64 = $o->packed_sint64;
    $this->packed_fixed32 = $o->packed_fixed32;
    $this->packed_fixed64 = $o->packed_fixed64;
    $this->packed_sfixed32 = $o->packed_sfixed32;
    $this->packed_sfixed64 = $o->packed_sfixed64;
    $this->packed_float = $o->packed_float;
    $this->packed_double = $o->packed_double;
    $this->packed_bool = $o->packed_bool;
    $this->packed_nested_enum = $o->packed_nested_enum;
    $this->unpacked_int32 = $o->unpacked_int32;
    $this->unpacked_int64 = $o->unpacked_int64;
    $this->unpacked_uint32 = $o->unpacked_uint32;
    $this->unpacked_uint64 = $o->unpacked_uint64;
    $this->unpacked_sint32 = $o->unpacked_sint32;
    $this->unpacked_sint64 = $o->unpacked_sint64;
    $this->unpacked_fixed32 = $o->unpacked_fixed32;
    $this->unpacked_fixed64 = $o->unpacked_fixed64;
    $this->unpacked_sfixed32 = $o->unpacked_sfixed32;
    $this->unpacked_sfixed64 = $o->unpacked_sfixed64;
    $this->unpacked_float = $o->unpacked_float;
    $this->unpacked_double = $o->unpacked_double;
    $this->unpacked_bool = $o->unpacked_bool;
    $this->unpacked_nested_enum = $o->unpacked_nested_enum;
    $tmp = $o->optional_bool_wrapper;
    if ($tmp !== null) {
      $nv = new \google\protobuf\BoolValue();
      $nv->CopyFrom($tmp);
      $this->optional_bool_wrapper = $nv;
    }
    $tmp = $o->optional_int32_wrapper;
    if ($tmp !== null) {
      $nv = new \google\protobuf\Int32Value();
      $nv->CopyFrom($tmp);
      $this->optional_int32_wrapper = $nv;
    }
    $tmp = $o->optional_int64_wrapper;
    if ($tmp !== null) {
      $nv = new \google\protobuf\Int64Value();
      $nv->CopyFrom($tmp);
      $this->optional_int64_wrapper = $nv;
    }
    $tmp = $o->optional_uint32_wrapper;
    if ($tmp !== null) {
      $nv = new \google\protobuf\UInt32Value();
      $nv->CopyFrom($tmp);
      $this->optional_uint32_wrapper = $nv;
    }
    $tmp = $o->optional_uint64_wrapper;
    if ($tmp !== null) {
      $nv = new \google\protobuf\UInt64Value();
      $nv->CopyFrom($tmp);
      $this->optional_uint64_wrapper = $nv;
    }
    $tmp = $o->optional_float_wrapper;
    if ($tmp !== null) {
      $nv = new \google\protobuf\FloatValue();
      $nv->CopyFrom($tmp);
      $this->optional_float_wrapper = $nv;
    }
    $tmp = $o->optional_double_wrapper;
    if ($tmp !== null) {
      $nv = new \google\protobuf\DoubleValue();
      $nv->CopyFrom($tmp);
      $this->optional_double_wrapper = $nv;
    }
    $tmp = $o->optional_string_wrapper;
    if ($tmp !== null) {
      $nv = new \google\protobuf\StringValue();
      $nv->CopyFrom($tmp);
      $this->optional_string_wrapper = $nv;
    }
    $tmp = $o->optional_bytes_wrapper;
    if ($tmp !== null) {
      $nv = new \google\protobuf\BytesValue();
      $nv->CopyFrom($tmp);
      $this->optional_bytes_wrapper = $nv;
    }
    foreach ($o->repeated_bool_wrapper as $v) {
      $nv = new \google\protobuf\BoolValue();
      $nv->CopyFrom($v);
      $this->repeated_bool_wrapper []= $nv;
    }
    foreach ($o->repeated_int32_wrapper as $v) {
      $nv = new \google\protobuf\Int32Value();
      $nv->CopyFrom($v);
      $this->repeated_int32_wrapper []= $nv;
    }
    foreach ($o->repeated_int64_wrapper as $v) {
      $nv = new \google\protobuf\Int64Value();
      $nv->CopyFrom($v);
      $this->repeated_int64_wrapper []= $nv;
    }
    foreach ($o->repeated_uint32_wrapper as $v) {
      $nv = new \google\protobuf\UInt32Value();
      $nv->CopyFrom($v);
      $this->repeated_uint32_wrapper []= $nv;
    }
    foreach ($o->repeated_uint64_wrapper as $v) {
      $nv = new \google\protobuf\UInt64Value();
      $nv->CopyFrom($v);
      $this->repeated_uint64_wrapper []= $nv;
    }
    foreach ($o->repeated_float_wrapper as $v) {
      $nv = new \google\protobuf\FloatValue();
      $nv->CopyFrom($v);
      $this->repeated_float_wrapper []= $nv;
    }
    foreach ($o->repeated_double_wrapper as $v) {
      $nv = new \google\protobuf\DoubleValue();
      $nv->CopyFrom($v);
      $this->repeated_double_wrapper []= $nv;
    }
    foreach ($o->repeated_string_wrapper as $v) {
      $nv = new \google\protobuf\StringValue();
      $nv->CopyFrom($v);
      $this->repeated_string_wrapper []= $nv;
    }
    foreach ($o->repeated_bytes_wrapper as $v) {
      $nv = new \google\protobuf\BytesValue();
      $nv->CopyFrom($v);
      $this->repeated_bytes_wrapper []= $nv;
    }
    $tmp = $o->optional_duration;
    if ($tmp !== null) {
      $nv = new \google\protobuf\Duration();
      $nv->CopyFrom($tmp);
      $this->optional_duration = $nv;
    }
    $tmp = $o->optional_timestamp;
    if ($tmp !== null) {
      $nv = new \google\protobuf\Timestamp();
      $nv->CopyFrom($tmp);
      $this->optional_timestamp = $nv;
    }
    $tmp = $o->optional_field_mask;
    if ($tmp !== null) {
      $nv = new \google\protobuf\FieldMask();
      $nv->CopyFrom($tmp);
      $this->optional_field_mask = $nv;
    }
    $tmp = $o->optional_struct;
    if ($tmp !== null) {
      $nv = new \google\protobuf\Struct();
      $nv->CopyFrom($tmp);
      $this->optional_struct = $nv;
    }
    $tmp = $o->optional_any;
    if ($tmp !== null) {
      $nv = new \google\protobuf\Any();
      $nv->CopyFrom($tmp);
      $this->optional_any = $nv;
    }
    $tmp = $o->optional_value;
    if ($tmp !== null) {
      $nv = new \google\protobuf\Value();
      $nv->CopyFrom($tmp);
      $this->optional_value = $nv;
    }
    $this->optional_null_value = $o->optional_null_value;
    foreach ($o->repeated_duration as $v) {
      $nv = new \google\protobuf\Duration();
      $nv->CopyFrom($v);
      $this->repeated_duration []= $nv;
    }
    foreach ($o->repeated_timestamp as $v) {
      $nv = new \google\protobuf\Timestamp();
      $nv->CopyFrom($v);
      $this->repeated_timestamp []= $nv;
    }
    foreach ($o->repeated_fieldmask as $v) {
      $nv = new \google\protobuf\FieldMask();
      $nv->CopyFrom($v);
      $this->repeated_fieldmask []= $nv;
    }
    foreach ($o->repeated_any as $v) {
      $nv = new \google\protobuf\Any();
      $nv->CopyFrom($v);
      $this->repeated_any []= $nv;
    }
    foreach ($o->repeated_value as $v) {
      $nv = new \google\protobuf\Value();
      $nv->CopyFrom($v);
      $this->repeated_value []= $nv;
    }
    foreach ($o->repeated_list_value as $v) {
      $nv = new \google\protobuf\ListValue();
      $nv->CopyFrom($v);
      $this->repeated_list_value []= $nv;
    }
    foreach ($o->repeated_struct as $v) {
      $nv = new \google\protobuf\Struct();
      $nv->CopyFrom($v);
      $this->repeated_struct []= $nv;
    }
    $this->fieldname1 = $o->fieldname1;
    $this->field_name2 = $o->field_name2;
    $this->_field_name3 = $o->_field_name3;
    $this->field__name4_ = $o->field__name4_;
    $this->field0name5 = $o->field0name5;
    $this->field_0_name6 = $o->field_0_name6;
    $this->fieldName7 = $o->fieldName7;
    $this->FieldName8 = $o->FieldName8;
    $this->field_Name9 = $o->field_Name9;
    $this->Field_Name10 = $o->Field_Name10;
    $this->FIELD_NAME11 = $o->FIELD_NAME11;
    $this->FIELD_name12 = $o->FIELD_name12;
    $this->__field_name13 = $o->__field_name13;
    $this->__Field_name14 = $o->__Field_name14;
    $this->field__name15 = $o->field__name15;
    $this->field__Name16 = $o->field__Name16;
    $this->field_name17__ = $o->field_name17__;
    $this->Field_name18__ = $o->Field_name18__;
    $this->oneof_field = $o->oneof_field->Copy();
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class ForeignMessage implements \Protobuf\Message {
  public int $c;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'c' => int,
  ) $s = shape()) {
    $this->c = $s['c'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.ForeignMessage";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->c = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->c !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->c);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('c', 'c', $this->c, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'c':
          $this->c = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ForeignMessage)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->c = $o->c;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}


class XXX_FileDescriptor_google_protobuf_test_messages_proto3__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'google/protobuf/test_messages_proto3.proto';
  const string RAW =
  'eNqsWtlzHEcZ1+w4stTalVZtWW4rIZnIMZ44xLGsyVgOOSzFWsuOLScjOyfJslqNXCrvoe'
  .'yRWDxAFcUDBU/chJu8cz8ABbzxwg3FDX8HVbyF6v66e77umZGR1q6ydvebX/++o7/+zW73'
  .'kJM32+2bjfix7U67117vbz7Wi7u9ajPudms3425VmOdPiRf6PgWqGiC4Oj9z1KaqtXbg2s'
  .'z99qWNfqfW22q35HXPvr65FTc2qs1a95ZE3Gcjur1Ov96TVx9IZbHVjLu9WnM7L4C3O7Xt'
  .'7bgjg5995zVCr8fd3mKjcX1nO+4+L1Kix8l4e5vHWWtUt1q9+TPM8Rz/nqikrJe40YaFAS'
  .'t4ju8asDCgJ8iEhvWBzvUcvxTp0TeENQUMA3bAc/wDJtBi7ALjPZ7jTybAtTRjFxiHPcen'
  .'JjAM6MOkrIGbW7fjjfkz7KDn+AcjTVABcxoaBmzEc/xhCxoG9BEymbhXtKOe409EmmNN2j'
  .'PAYcCI5/hlGxwGRuk3G+1aj415jl9ISl/hRiP/jXZ/vRGzouf4TpL/BWGlx4geWV1vtxus'
  .'5Dn+SFRUxqV2u2FWs9fZat1k457jj6JqCqsR3fpOL+6yCc/xi0l0S9xI3yZHNKwVd3vxhl'
  .'pcjHqOP3bmmVO7Lr1T6dY9tSp4rgIwOqz4DTO9SVhSvXYn3rrZ0p4PCc+P3sFzBUYpP9O6'
  .'7IadtsiUnWHc6jfZYc/xx888ud/0llv9ZkTN3LiNvkEOpxITDqeFw5P/X1aC/pCVkuB/E/'
  .'HXGlu1rkroiOB/au8JLQKL6RIZaYhcQtNVt7fieswYb72lwkghGQft9zy/TE+gjq63Oxvs'
  .'qMQ7SVc/2+5s0DfIZCeu9zvdrbdi3QX3ii6Y23M+UVlzqR44TsY78XZc45MPWvWA53IxVV'
  .'YtphgWBszzXC6mCAbSp2FSTB/0XC6mypyIqQEMAzbruVxMMdBilGJ6zHO5mCrzWppRiulD'
  .'nsvFFANBTDVQqd5xz+ViquxITE1oGLD3ey4XUwMKYpq4V7QnPJeLqQ4AiakFDgPmey4XUx'
  .'MMYpoEIcT0Yc/lYqpDUGKqYVJMT3ouF1NlTsRUA4WYPuK5XEyVUYlpEiGI6Qc8l4upjk+L'
  .'acImxPRRz+ViqumUmGqYJaanPfeuiKniT4lpUj1LTOeE572KqS57SkztDIX2zHvu4GJq5q'
  .'bENJWYcBgIh3sSUyslpWxWB0hlC3kfgLKZvaCVTY8TynZW4p2kxYSyHSfF7Vr9ltad57ju'
  .'LBXKTjQGdqU8CBYG7ArXHQsmdKIkYVJ3rnLdETg5XisPBoYBW+W6YwMNRqk717juYOCazS'
  .'h153muOzZQKM+4BCqBeIHrjkBKikR5DGgYsIjrTgoqlGdCuVe0a1x3BFayIOUxwWHArnPd'
  .'SYOF8qjSg+7c4LqDS6+UR+UvdedFrjs4f608chzozktcdwSMgFkoT4tQCcKr6OXBV5HwVA'
  .'ZutI4eJuP9ltGIr8hGHIpK6gq0ogUNA/aqbEYTCpOiobIhX5MNORRpFtmSNjgM2IdkU1pg'
  .'i1k25uuyMRF4Lc0sm/MN2ZwWOAzoo6SswaqTqrJBhyJNpFo0BQ8D9mHZpDY8DOhjZDIJRd'
  .'HXZKMORZpLt2p6QBiwddmsqQGwvJKARMPWZcOi6YGWxXWRTbshmxbVRbbtCaJHQ+PGsnGH'
  .'oqK6IFq3Q6Y0EDfv5l1p3qGIKnbUvg0y0axtQ+fK/l0Qt7ULe3d3tbYtGl38WW71OjtRqY'
  .'ltyFsYyCVwbjBvYSD+GN6kjXbIJPcG60ctoyeEv8q+/MF6g7/gkaeDrdhnGKjV+MEBfYYB'
  .'/DV9KqvyCatZLeonB/AJq3/NyhNbsc8wUNrw1IA+w2DNyhNb6W1yiPuUC1xrzNPC68q+vE'
  .'oxki/glydm2g3PYaDl6plBPYeBfLE8azv9KDks6qyS1tJ3Xvi+vL9aSxL1Ct55ivYV0z+f'
  .'aZX74sD+w0C92v6TK6Y+gSovDapPQsMtfQJdb5Ny4k0K+7PC3fL+3cFtAPyNNw0j3SQ8An'
  .'FbgHvDBeFtaV/e+E2E/wdXY83EopcrfBGXv8iWB1muggL+ouWKrKqY0if8uKsMUEygFb8H'
  .'k2IiI/2kQ44ij9bvxIvC9dUBXBu/DCGE6WbmRfpph8ygUOxfjisiltUBYjF/PUIwR5rZV+'
  .'nHyHS6LuKrxaVBVjHKm3+XQKvYukI/7pAjGeUQIVwWITw3eC2SGKaaGZfoMVJst+L2pvom'
  .'0PYcv7QyFI0Jq7x/d8kUgKzu2b4rW7YrQxEV9Ga36MjkwnzTc/xRHZlcTg8S+ChXUsdz/O'
  .'LKUESEERbAA4RICJeSruf4IytD0SgguAwYJQgD1vMc/4BRgjBIHIHc9j3HL2hHoJOaR2rk'
  .'W57jO5pHatvrKhoxzW8PvimscxHTWSFlOVP9RqP6Vq3Rj9lt4WTmFBwMaV+nVvuNxoscsT'
  .'IUjcMEKAu9hrZghQ7LUyT2K0fMeZqNl1KMTfZmueklGEcjMm2eL2nGXwPjvSlGcUsAyinj'
  .'FCqHMww052924QyDNGcYKM4b6ICibwb6WyC9L0V6A0V62DzgyqNFsf5uN1oV7GHzOCyrAq'
  .'IxNevv8yogetWqgLBlhQqdrEn/kBcqNLcVKhizaKXiKdo/5tHCIrdowZhVAaEBmvVPeRUQ'
  .'smBVQNgU5zW0S2c0/58dIcu7Nj/e8UVBmucBmvEvwLh78xunBjmcqKH+ugunbn7jiAHNkX'
  .'XSoEn/BqR3aH7zQCKPFsX6991odfObxxdZFTCb/x95FcDNb+z0Z4VqNf8/80I1mt88F8ii'
  .'tZr/X3m0RvObm8JZFTCb/995FcDNb5wmKM6L6ExaPbvAvlMQa+loOneJSM6rlYVeJvq4sq'
  .'ofUmDfLeTcP64rSKT9axN9jhxCB/DqgQn2vTyyCsdcrXVvJWTaRBfNM+1+vce+D0RHsiah'
  .'X+8Zp939eo8ukGJyKNraYT+A8VOp8YutnWhMn3G2dujT6Jwcbs8/hLHTqbEwS/pIE27MuB'
  .'LoHv+jwp1u8kklkrv8RXRkpuf6xwXROrvNtW5yNNeaKJnrnxRy5BLNtRqWzDXmEnMtpvqn'
  .'eVxoqpPjQzmKTzVed3yqfwlE+VONlpqcak3Bp/pnMD5nqhVUTrUeCbP0cxibO9UKrqdaj2'
  .'9sdXuS5Bd5lbiy1ZXapiuhTfxbsChmq9aM59hnXPFwDzJRj4zByuIfz7DPYsQqN9EHSbGa'
  .'QObZ5ySkoiDzdJaUACEgQZV93qYR36TFp9Mc8jj7AiCwjR5TNKcFT8i+aIA4T6gz4p/Osi'
  .'/Zjs5ygA5tgX3ZjnYhSZl/PMfesSnO0VlSrGjE3Gn2FRmHJpk7LTCXlq9cqK4uXl2em2Nf'
  .'VRhuBFuCEbU+w75mYISNPkTGq6i+c/Ps6ylv84CqJKiAfSOFCpICAuhx9k1cQAFCVYbsQv'
  .'atFCjk/lBMZ6tV9u0U6ixHoZgWqlX2biqqhZkOKZk/8YrEqcnnzJwaXSNj9bZ+loIV9vs8'
  .'BmaZOU9oegeelol7K96RrvlbOkXugeVVEDb48ERhwUkY8K46ZnAzGFzMsESmsvbJMUcpg6'
  .'OUzWHse2OOAxkcB9IcqX1szDGZwTGZzWHsS2MOmsFBMccFMp29y4xZDmawHMxhMXeMMctw'
  .'BsswZqkQlrf3i3kmMngm8nisPVzMU87gKWd2G96RvVO/FjDDIjmUscl6JwoHUzxNyvbOKR'
  .'4/kjF+JKNJ7N1QzDGawTGaTsPe3rwTRRFTfMoh9+6yT5nBdQNz3YXnZ1AwO+S+3fYpM4J5'
  .'1gxmj4/UINefcKA5s7YmM/xG2O+gT9mgMLrkaO7uZEYY580w9vLsTeJ09hwhaMv1IHEr16'
  .'6Vh/ibpcWo7MCbV8sFHsDq8sXye+qfM/sKGcNPJZbI6OKVS4trVWDQH4EHfeRsB4n7wo2X'
  .'4c2b/dvwZn3xI+XCTKHsLJX0biK/PV4eHvmPW37Pnb2fjFub1EXi1NUdsn7yPBnDe7cTZK'
  .'xyLVq+dHFVxoQMEJVheLVcWFogfr3dtL86ZlZ0xfmv47xbGIY5XR8G6/8CAAD//8OKaK4';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    return (string)\gzuncompress(\base64_decode(self::RAW));
  }
}
