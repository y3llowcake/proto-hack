<?hh // strict
namespace protobuf_test_messages\proto2;

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: google/protobuf/test_messages_proto2.proto

newtype ForeignEnumProto2_enum_t as int = int;
abstract class ForeignEnumProto2 {
  const ForeignEnumProto2_enum_t FOREIGN_FOO = 0;
  const ForeignEnumProto2_enum_t FOREIGN_BAR = 1;
  const ForeignEnumProto2_enum_t FOREIGN_BAZ = 2;
  private static dict<int, string> $itos = dict[
    0 => 'FOREIGN_FOO',
    1 => 'FOREIGN_BAR',
    2 => 'FOREIGN_BAZ',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'FOREIGN_FOO' => 0,
    'FOREIGN_BAR' => 1,
    'FOREIGN_BAZ' => 2,
  ];
  public static function FromMixed(mixed $m): ForeignEnumProto2_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): ForeignEnumProto2_enum_t {
    return $i;
  }
}

newtype TestAllTypesProto2_NestedEnum_enum_t as int = int;
abstract class TestAllTypesProto2_NestedEnum {
  const TestAllTypesProto2_NestedEnum_enum_t FOO = 0;
  const TestAllTypesProto2_NestedEnum_enum_t BAR = 1;
  const TestAllTypesProto2_NestedEnum_enum_t BAZ = 2;
  const TestAllTypesProto2_NestedEnum_enum_t NEG = -1;
  private static dict<int, string> $itos = dict[
    0 => 'FOO',
    1 => 'BAR',
    2 => 'BAZ',
    -1 => 'NEG',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'FOO' => 0,
    'BAR' => 1,
    'BAZ' => 2,
    'NEG' => -1,
  ];
  public static function FromMixed(mixed $m): TestAllTypesProto2_NestedEnum_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): TestAllTypesProto2_NestedEnum_enum_t {
    return $i;
  }
}

enum TestAllTypesProto2_oneof_field_oneof_t: int {
  NOT_SET = 0;
  oneof_uint32 = 111;
  oneof_nested_message = 112;
  oneof_string = 113;
  oneof_bytes = 114;
  oneof_bool = 115;
  oneof_uint64 = 116;
  oneof_float = 117;
  oneof_double = 118;
  oneof_enum = 119;
}

interface TestAllTypesProto2_oneof_field {
  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t;
  public function WriteTo(\Protobuf\Internal\Encoder $e): void;
  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void;
  public function Copy(): TestAllTypesProto2_oneof_field;
}

class TestAllTypesProto2_oneof_field_NOT_SET implements TestAllTypesProto2_oneof_field {
  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::NOT_SET;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {}

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {}

  public function Copy(): TestAllTypesProto2_oneof_field { return $this; }
}

class TestAllTypesProto2_oneof_uint32 implements TestAllTypesProto2_oneof_field {
  public function __construct(public int $oneof_uint32) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_uint32;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(111, 0);;
    $e->writeVarint($this->oneof_uint32);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('oneof_uint32', 'oneofUint32', $this->oneof_uint32, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_uint32($this->oneof_uint32);
  }
}

class TestAllTypesProto2_oneof_nested_message implements TestAllTypesProto2_oneof_field {
  public function __construct(public \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage $oneof_nested_message) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_nested_message;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $nested = new \Protobuf\Internal\Encoder();
    $this->oneof_nested_message->WriteTo($nested);
    $e->writeEncoder($nested, 112);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessage('oneof_nested_message', 'oneofNestedMessage', $this->oneof_nested_message, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
    $nv->CopyFrom($this->oneof_nested_message);
    return new TestAllTypesProto2_oneof_nested_message($nv);
  }
}

class TestAllTypesProto2_oneof_string implements TestAllTypesProto2_oneof_field {
  public function __construct(public string $oneof_string) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_string;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(113, 2);;
    $e->writeString($this->oneof_string);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('oneof_string', 'oneofString', $this->oneof_string, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_string($this->oneof_string);
  }
}

class TestAllTypesProto2_oneof_bytes implements TestAllTypesProto2_oneof_field {
  public function __construct(public string $oneof_bytes) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_bytes;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(114, 2);;
    $e->writeString($this->oneof_bytes);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBytes('oneof_bytes', 'oneofBytes', $this->oneof_bytes, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_bytes($this->oneof_bytes);
  }
}

class TestAllTypesProto2_oneof_bool implements TestAllTypesProto2_oneof_field {
  public function __construct(public bool $oneof_bool) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_bool;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(115, 0);;
    $e->writeBool($this->oneof_bool);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('oneof_bool', 'oneofBool', $this->oneof_bool, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_bool($this->oneof_bool);
  }
}

class TestAllTypesProto2_oneof_uint64 implements TestAllTypesProto2_oneof_field {
  public function __construct(public int $oneof_uint64) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_uint64;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(116, 0);;
    $e->writeVarint($this->oneof_uint64);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Unsigned('oneof_uint64', 'oneofUint64', $this->oneof_uint64, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_uint64($this->oneof_uint64);
  }
}

class TestAllTypesProto2_oneof_float implements TestAllTypesProto2_oneof_field {
  public function __construct(public float $oneof_float) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_float;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(117, 5);;
    $e->writeFloat($this->oneof_float);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeFloat('oneof_float', 'oneofFloat', $this->oneof_float, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_float($this->oneof_float);
  }
}

class TestAllTypesProto2_oneof_double implements TestAllTypesProto2_oneof_field {
  public function __construct(public float $oneof_double) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_double;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(118, 1);;
    $e->writeDouble($this->oneof_double);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeFloat('oneof_double', 'oneofDouble', $this->oneof_double, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_double($this->oneof_double);
  }
}

class TestAllTypesProto2_oneof_enum implements TestAllTypesProto2_oneof_field {
  public function __construct(public \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t $oneof_enum) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_enum;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(119, 0);;
    $e->writeVarint($this->oneof_enum);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeEnum('oneof_enum', 'oneofEnum', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->oneof_enum, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_enum($this->oneof_enum);
  }
}

class TestAllTypesProto2_NestedMessage implements \Protobuf\Message {
  public int $a;
  public ?\protobuf_test_messages\proto2\TestAllTypesProto2 $corecursive;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'a' => int,
    ?'corecursive' => ?\protobuf_test_messages\proto2\TestAllTypesProto2,
  ) $s = shape()) {
    $this->a = $s['a'] ?? 0;
    $this->corecursive = $s['corecursive'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.NestedMessage";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->a = $d->readVarint32Signed();
          break;
        case 2:
          if ($this->corecursive == null) $this->corecursive = new \protobuf_test_messages\proto2\TestAllTypesProto2();
          $this->corecursive->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->a !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->a);
    }
    $msg = $this->corecursive;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('a', 'a', $this->a, false);
    $e->writeMessage('corecursive', 'corecursive', $this->corecursive, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'a':
          $this->a = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'corecursive':
          if ($v === null) break;
          if ($this->corecursive == null) $this->corecursive = new \protobuf_test_messages\proto2\TestAllTypesProto2();
          $this->corecursive->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_NestedMessage)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->a = $o->a;
    $tmp = $o->corecursive;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2();
      $nv->CopyFrom($tmp);
      $this->corecursive = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapInt32Int32Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapInt32Int32Entry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32Signed();
          break;
        case 2:
          $this->value = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeInt32('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapInt32Int32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapInt64Int64Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapInt64Int64Entry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint();
          break;
        case 2:
          $this->value = $d->readVarint();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Signed('key', 'key', $this->key, false);
    $e->writeInt64Signed('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapInt64Int64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapUint32Uint32Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapUint32Uint32Entry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32();
          break;
        case 2:
          $this->value = $d->readVarint32();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeInt32('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapUint32Uint32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapUint64Uint64Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapUint64Uint64Entry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint();
          break;
        case 2:
          $this->value = $d->readVarint();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Unsigned('key', 'key', $this->key, false);
    $e->writeInt64Unsigned('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapUint64Uint64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapSint32Sint32Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapSint32Sint32Entry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarintZigZag32();
          break;
        case 2:
          $this->value = $d->readVarintZigZag32();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarintZigZag32($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarintZigZag32($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeInt32('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapSint32Sint32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapSint64Sint64Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapSint64Sint64Entry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarintZigZag64();
          break;
        case 2:
          $this->value = $d->readVarintZigZag64();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarintZigZag64($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarintZigZag64($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Signed('key', 'key', $this->key, false);
    $e->writeInt64Signed('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapSint64Sint64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapFixed32Fixed32Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapFixed32Fixed32Entry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readLittleEndianInt32Unsigned();
          break;
        case 2:
          $this->value = $d->readLittleEndianInt32Unsigned();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 5);
      $e->writeLittleEndianInt32Unsigned($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 5);
      $e->writeLittleEndianInt32Unsigned($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeInt32('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapFixed32Fixed32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapFixed64Fixed64Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapFixed64Fixed64Entry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readLittleEndianInt64();
          break;
        case 2:
          $this->value = $d->readLittleEndianInt64();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 1);
      $e->writeLittleEndianInt64($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 1);
      $e->writeLittleEndianInt64($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Unsigned('key', 'key', $this->key, false);
    $e->writeInt64Unsigned('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapFixed64Fixed64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapSfixed32Sfixed32Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapSfixed32Sfixed32Entry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readLittleEndianInt32Signed();
          break;
        case 2:
          $this->value = $d->readLittleEndianInt32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 5);
      $e->writeLittleEndianInt32Signed($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 5);
      $e->writeLittleEndianInt32Signed($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeInt32('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapSfixed32Sfixed32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapSfixed64Sfixed64Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapSfixed64Sfixed64Entry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readLittleEndianInt64();
          break;
        case 2:
          $this->value = $d->readLittleEndianInt64();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 1);
      $e->writeLittleEndianInt64($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 1);
      $e->writeLittleEndianInt64($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Signed('key', 'key', $this->key, false);
    $e->writeInt64Signed('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapSfixed64Sfixed64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapInt32FloatEntry implements \Protobuf\Message {
  public int $key;
  public float $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => float,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0.0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapInt32FloatEntry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32Signed();
          break;
        case 2:
          $this->value = $d->readFloat();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0.0) {
      $e->writeTag(2, 5);
      $e->writeFloat($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeFloat('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapInt32FloatEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapInt32DoubleEntry implements \Protobuf\Message {
  public int $key;
  public float $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => float,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0.0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapInt32DoubleEntry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32Signed();
          break;
        case 2:
          $this->value = $d->readDouble();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0.0) {
      $e->writeTag(2, 1);
      $e->writeDouble($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeFloat('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapInt32DoubleEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapBoolBoolEntry implements \Protobuf\Message {
  public bool $key;
  public bool $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => bool,
    ?'value' => bool,
  ) $s = shape()) {
    $this->key = $s['key'] ?? false;
    $this->value = $s['value'] ?? false;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapBoolBoolEntry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readBool();
          break;
        case 2:
          $this->value = $d->readBool();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== false) {
      $e->writeTag(1, 0);
      $e->writeBool($this->key);
    }
    if ($this->value !== false) {
      $e->writeTag(2, 0);
      $e->writeBool($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('key', 'key', $this->key, false);
    $e->writeBool('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapBoolBoolEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapStringStringEntry implements \Protobuf\Message {
  public string $key;
  public string $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => string,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapStringStringEntry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          $this->value = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    if ($this->value !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeString('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapStringStringEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapStringBytesEntry implements \Protobuf\Message {
  public string $key;
  public string $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => string,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapStringBytesEntry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          $this->value = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    if ($this->value !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeBytes('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readBytes($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapStringBytesEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapStringNestedMessageEntry implements \Protobuf\Message {
  public string $key;
  public ?\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => ?\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapStringNestedMessageEntry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          if ($this->value == null) $this->value = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
          $this->value->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    $msg = $this->value;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeMessage('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          if ($v === null) break;
          if ($this->value == null) $this->value = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
          $this->value->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapStringNestedMessageEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $tmp = $o->value;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
      $nv->CopyFrom($tmp);
      $this->value = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapStringForeignMessageEntry implements \Protobuf\Message {
  public string $key;
  public ?\protobuf_test_messages\proto2\ForeignMessageProto2 $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => ?\protobuf_test_messages\proto2\ForeignMessageProto2,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapStringForeignMessageEntry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          if ($this->value == null) $this->value = new \protobuf_test_messages\proto2\ForeignMessageProto2();
          $this->value->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    $msg = $this->value;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeMessage('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          if ($v === null) break;
          if ($this->value == null) $this->value = new \protobuf_test_messages\proto2\ForeignMessageProto2();
          $this->value->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapStringForeignMessageEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $tmp = $o->value;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto2\ForeignMessageProto2();
      $nv->CopyFrom($tmp);
      $this->value = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapStringNestedEnumEntry implements \Protobuf\Message {
  public string $key;
  public \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt(0);
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapStringNestedEnumEntry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          $this->value = \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($d->readVarint());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    if ($this->value !== \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt(0)) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeEnum('value', 'value', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          $this->value = \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapStringNestedEnumEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapStringForeignEnumEntry implements \Protobuf\Message {
  public string $key;
  public \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? \protobuf_test_messages\proto2\ForeignEnumProto2::FromInt(0);
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapStringForeignEnumEntry";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          $this->value = \protobuf_test_messages\proto2\ForeignEnumProto2::FromInt($d->readVarint());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    if ($this->value !== \protobuf_test_messages\proto2\ForeignEnumProto2::FromInt(0)) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeEnum('value', 'value', \protobuf_test_messages\proto2\ForeignEnumProto2::ToStringDict(), $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          $this->value = \protobuf_test_messages\proto2\ForeignEnumProto2::FromMixed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapStringForeignEnumEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_Data implements \Protobuf\Message {
  public int $group_int32;
  public int $group_uint32;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'group_int32' => int,
    ?'group_uint32' => int,
  ) $s = shape()) {
    $this->group_int32 = $s['group_int32'] ?? 0;
    $this->group_uint32 = $s['group_uint32'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.Data";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 202:
          $this->group_int32 = $d->readVarint32Signed();
          break;
        case 203:
          $this->group_uint32 = $d->readVarint32();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->group_int32 !== 0) {
      $e->writeTag(202, 0);
      $e->writeVarint($this->group_int32);
    }
    if ($this->group_uint32 !== 0) {
      $e->writeTag(203, 0);
      $e->writeVarint($this->group_uint32);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('group_int32', 'groupInt32', $this->group_int32, false);
    $e->writeInt32('group_uint32', 'groupUint32', $this->group_uint32, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'group_int32': case 'groupInt32':
          $this->group_int32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'group_uint32': case 'groupUint32':
          $this->group_uint32 = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_Data)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->group_int32 = $o->group_int32;
    $this->group_uint32 = $o->group_uint32;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MessageSetCorrect implements \Protobuf\Message {
  private string $XXX_unrecognized;

  public function __construct(shape(
  ) $s = shape()) {
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MessageSetCorrect";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MessageSetCorrect)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MessageSetCorrectExtension1 implements \Protobuf\Message {
  public string $str;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'str' => string,
  ) $s = shape()) {
    $this->str = $s['str'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MessageSetCorrectExtension1";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 25:
          $this->str = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->str !== '') {
      $e->writeTag(25, 2);
      $e->writeString($this->str);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('str', 'str', $this->str, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'str':
          $this->str = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MessageSetCorrectExtension1)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->str = $o->str;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MessageSetCorrectExtension2 implements \Protobuf\Message {
  public int $i;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'i' => int,
  ) $s = shape()) {
    $this->i = $s['i'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MessageSetCorrectExtension2";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 9:
          $this->i = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->i !== 0) {
      $e->writeTag(9, 0);
      $e->writeVarint($this->i);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('i', 'i', $this->i, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'i':
          $this->i = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MessageSetCorrectExtension2)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->i = $o->i;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2 implements \Protobuf\Message {
  public int $optional_int32;
  public int $optional_int64;
  public int $optional_uint32;
  public int $optional_uint64;
  public int $optional_sint32;
  public int $optional_sint64;
  public int $optional_fixed32;
  public int $optional_fixed64;
  public int $optional_sfixed32;
  public int $optional_sfixed64;
  public float $optional_float;
  public float $optional_double;
  public bool $optional_bool;
  public string $optional_string;
  public string $optional_bytes;
  public ?\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage $optional_nested_message;
  public ?\protobuf_test_messages\proto2\ForeignMessageProto2 $optional_foreign_message;
  public \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t $optional_nested_enum;
  public \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t $optional_foreign_enum;
  public string $optional_string_piece;
  public string $optional_cord;
  public ?\protobuf_test_messages\proto2\TestAllTypesProto2 $recursive_message;
  public vec<int> $repeated_int32;
  public vec<int> $repeated_int64;
  public vec<int> $repeated_uint32;
  public vec<int> $repeated_uint64;
  public vec<int> $repeated_sint32;
  public vec<int> $repeated_sint64;
  public vec<int> $repeated_fixed32;
  public vec<int> $repeated_fixed64;
  public vec<int> $repeated_sfixed32;
  public vec<int> $repeated_sfixed64;
  public vec<float> $repeated_float;
  public vec<float> $repeated_double;
  public vec<bool> $repeated_bool;
  public vec<string> $repeated_string;
  public vec<string> $repeated_bytes;
  public vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage> $repeated_nested_message;
  public vec<\protobuf_test_messages\proto2\ForeignMessageProto2> $repeated_foreign_message;
  public vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t> $repeated_nested_enum;
  public vec<\protobuf_test_messages\proto2\ForeignEnumProto2_enum_t> $repeated_foreign_enum;
  public vec<string> $repeated_string_piece;
  public vec<string> $repeated_cord;
  public vec<int> $packed_int32;
  public vec<int> $packed_int64;
  public vec<int> $packed_uint32;
  public vec<int> $packed_uint64;
  public vec<int> $packed_sint32;
  public vec<int> $packed_sint64;
  public vec<int> $packed_fixed32;
  public vec<int> $packed_fixed64;
  public vec<int> $packed_sfixed32;
  public vec<int> $packed_sfixed64;
  public vec<float> $packed_float;
  public vec<float> $packed_double;
  public vec<bool> $packed_bool;
  public vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t> $packed_nested_enum;
  public vec<int> $unpacked_int32;
  public vec<int> $unpacked_int64;
  public vec<int> $unpacked_uint32;
  public vec<int> $unpacked_uint64;
  public vec<int> $unpacked_sint32;
  public vec<int> $unpacked_sint64;
  public vec<int> $unpacked_fixed32;
  public vec<int> $unpacked_fixed64;
  public vec<int> $unpacked_sfixed32;
  public vec<int> $unpacked_sfixed64;
  public vec<float> $unpacked_float;
  public vec<float> $unpacked_double;
  public vec<bool> $unpacked_bool;
  public vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t> $unpacked_nested_enum;
  public dict<int, int> $map_int32_int32;
  public dict<int, int> $map_int64_int64;
  public dict<int, int> $map_uint32_uint32;
  public dict<int, int> $map_uint64_uint64;
  public dict<int, int> $map_sint32_sint32;
  public dict<int, int> $map_sint64_sint64;
  public dict<int, int> $map_fixed32_fixed32;
  public dict<int, int> $map_fixed64_fixed64;
  public dict<int, int> $map_sfixed32_sfixed32;
  public dict<int, int> $map_sfixed64_sfixed64;
  public dict<int, float> $map_int32_float;
  public dict<int, float> $map_int32_double;
  public dict<\Protobuf\Internal\bool_map_key_t, bool> $map_bool_bool;
  public dict<string, string> $map_string_string;
  public dict<string, string> $map_string_bytes;
  public dict<string, \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage> $map_string_nested_message;
  public dict<string, \protobuf_test_messages\proto2\ForeignMessageProto2> $map_string_foreign_message;
  public dict<string, \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t> $map_string_nested_enum;
  public dict<string, \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t> $map_string_foreign_enum;
  public ?\protobuf_test_messages\proto2\TestAllTypesProto2_Data $data;
  public int $fieldname1;
  public int $field_name2;
  public int $_field_name3;
  public int $field__name4_;
  public int $field0name5;
  public int $field_0_name6;
  public int $fieldName7;
  public int $FieldName8;
  public int $field_Name9;
  public int $Field_Name10;
  public int $FIELD_NAME11;
  public int $FIELD_name12;
  public int $__field_name13;
  public int $__Field_name14;
  public int $field__name15;
  public int $field__Name16;
  public int $field_name17__;
  public int $Field_name18__;
  public TestAllTypesProto2_oneof_field $oneof_field;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'optional_int32' => int,
    ?'optional_int64' => int,
    ?'optional_uint32' => int,
    ?'optional_uint64' => int,
    ?'optional_sint32' => int,
    ?'optional_sint64' => int,
    ?'optional_fixed32' => int,
    ?'optional_fixed64' => int,
    ?'optional_sfixed32' => int,
    ?'optional_sfixed64' => int,
    ?'optional_float' => float,
    ?'optional_double' => float,
    ?'optional_bool' => bool,
    ?'optional_string' => string,
    ?'optional_bytes' => string,
    ?'optional_nested_message' => ?\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage,
    ?'optional_foreign_message' => ?\protobuf_test_messages\proto2\ForeignMessageProto2,
    ?'optional_nested_enum' => \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t,
    ?'optional_foreign_enum' => \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t,
    ?'optional_string_piece' => string,
    ?'optional_cord' => string,
    ?'recursive_message' => ?\protobuf_test_messages\proto2\TestAllTypesProto2,
    ?'repeated_int32' => vec<int>,
    ?'repeated_int64' => vec<int>,
    ?'repeated_uint32' => vec<int>,
    ?'repeated_uint64' => vec<int>,
    ?'repeated_sint32' => vec<int>,
    ?'repeated_sint64' => vec<int>,
    ?'repeated_fixed32' => vec<int>,
    ?'repeated_fixed64' => vec<int>,
    ?'repeated_sfixed32' => vec<int>,
    ?'repeated_sfixed64' => vec<int>,
    ?'repeated_float' => vec<float>,
    ?'repeated_double' => vec<float>,
    ?'repeated_bool' => vec<bool>,
    ?'repeated_string' => vec<string>,
    ?'repeated_bytes' => vec<string>,
    ?'repeated_nested_message' => vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage>,
    ?'repeated_foreign_message' => vec<\protobuf_test_messages\proto2\ForeignMessageProto2>,
    ?'repeated_nested_enum' => vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t>,
    ?'repeated_foreign_enum' => vec<\protobuf_test_messages\proto2\ForeignEnumProto2_enum_t>,
    ?'repeated_string_piece' => vec<string>,
    ?'repeated_cord' => vec<string>,
    ?'packed_int32' => vec<int>,
    ?'packed_int64' => vec<int>,
    ?'packed_uint32' => vec<int>,
    ?'packed_uint64' => vec<int>,
    ?'packed_sint32' => vec<int>,
    ?'packed_sint64' => vec<int>,
    ?'packed_fixed32' => vec<int>,
    ?'packed_fixed64' => vec<int>,
    ?'packed_sfixed32' => vec<int>,
    ?'packed_sfixed64' => vec<int>,
    ?'packed_float' => vec<float>,
    ?'packed_double' => vec<float>,
    ?'packed_bool' => vec<bool>,
    ?'packed_nested_enum' => vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t>,
    ?'unpacked_int32' => vec<int>,
    ?'unpacked_int64' => vec<int>,
    ?'unpacked_uint32' => vec<int>,
    ?'unpacked_uint64' => vec<int>,
    ?'unpacked_sint32' => vec<int>,
    ?'unpacked_sint64' => vec<int>,
    ?'unpacked_fixed32' => vec<int>,
    ?'unpacked_fixed64' => vec<int>,
    ?'unpacked_sfixed32' => vec<int>,
    ?'unpacked_sfixed64' => vec<int>,
    ?'unpacked_float' => vec<float>,
    ?'unpacked_double' => vec<float>,
    ?'unpacked_bool' => vec<bool>,
    ?'unpacked_nested_enum' => vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t>,
    ?'map_int32_int32' => dict<int, int>,
    ?'map_int64_int64' => dict<int, int>,
    ?'map_uint32_uint32' => dict<int, int>,
    ?'map_uint64_uint64' => dict<int, int>,
    ?'map_sint32_sint32' => dict<int, int>,
    ?'map_sint64_sint64' => dict<int, int>,
    ?'map_fixed32_fixed32' => dict<int, int>,
    ?'map_fixed64_fixed64' => dict<int, int>,
    ?'map_sfixed32_sfixed32' => dict<int, int>,
    ?'map_sfixed64_sfixed64' => dict<int, int>,
    ?'map_int32_float' => dict<int, float>,
    ?'map_int32_double' => dict<int, float>,
    ?'map_bool_bool' => dict<\Protobuf\Internal\bool_map_key_t, bool>,
    ?'map_string_string' => dict<string, string>,
    ?'map_string_bytes' => dict<string, string>,
    ?'map_string_nested_message' => dict<string, \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage>,
    ?'map_string_foreign_message' => dict<string, \protobuf_test_messages\proto2\ForeignMessageProto2>,
    ?'map_string_nested_enum' => dict<string, \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t>,
    ?'map_string_foreign_enum' => dict<string, \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t>,
    ?'data' => ?\protobuf_test_messages\proto2\TestAllTypesProto2_Data,
    ?'fieldname1' => int,
    ?'field_name2' => int,
    ?'_field_name3' => int,
    ?'field__name4_' => int,
    ?'field0name5' => int,
    ?'field_0_name6' => int,
    ?'fieldName7' => int,
    ?'FieldName8' => int,
    ?'field_Name9' => int,
    ?'Field_Name10' => int,
    ?'FIELD_NAME11' => int,
    ?'FIELD_name12' => int,
    ?'__field_name13' => int,
    ?'__Field_name14' => int,
    ?'field__name15' => int,
    ?'field__Name16' => int,
    ?'field_name17__' => int,
    ?'Field_name18__' => int,
    ?'oneof_field' => TestAllTypesProto2_oneof_field,
  ) $s = shape()) {
    $this->optional_int32 = $s['optional_int32'] ?? 0;
    $this->optional_int64 = $s['optional_int64'] ?? 0;
    $this->optional_uint32 = $s['optional_uint32'] ?? 0;
    $this->optional_uint64 = $s['optional_uint64'] ?? 0;
    $this->optional_sint32 = $s['optional_sint32'] ?? 0;
    $this->optional_sint64 = $s['optional_sint64'] ?? 0;
    $this->optional_fixed32 = $s['optional_fixed32'] ?? 0;
    $this->optional_fixed64 = $s['optional_fixed64'] ?? 0;
    $this->optional_sfixed32 = $s['optional_sfixed32'] ?? 0;
    $this->optional_sfixed64 = $s['optional_sfixed64'] ?? 0;
    $this->optional_float = $s['optional_float'] ?? 0.0;
    $this->optional_double = $s['optional_double'] ?? 0.0;
    $this->optional_bool = $s['optional_bool'] ?? false;
    $this->optional_string = $s['optional_string'] ?? '';
    $this->optional_bytes = $s['optional_bytes'] ?? '';
    $this->optional_nested_message = $s['optional_nested_message'] ?? null;
    $this->optional_foreign_message = $s['optional_foreign_message'] ?? null;
    $this->optional_nested_enum = $s['optional_nested_enum'] ?? \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt(0);
    $this->optional_foreign_enum = $s['optional_foreign_enum'] ?? \protobuf_test_messages\proto2\ForeignEnumProto2::FromInt(0);
    $this->optional_string_piece = $s['optional_string_piece'] ?? '';
    $this->optional_cord = $s['optional_cord'] ?? '';
    $this->recursive_message = $s['recursive_message'] ?? null;
    $this->repeated_int32 = $s['repeated_int32'] ?? vec[];
    $this->repeated_int64 = $s['repeated_int64'] ?? vec[];
    $this->repeated_uint32 = $s['repeated_uint32'] ?? vec[];
    $this->repeated_uint64 = $s['repeated_uint64'] ?? vec[];
    $this->repeated_sint32 = $s['repeated_sint32'] ?? vec[];
    $this->repeated_sint64 = $s['repeated_sint64'] ?? vec[];
    $this->repeated_fixed32 = $s['repeated_fixed32'] ?? vec[];
    $this->repeated_fixed64 = $s['repeated_fixed64'] ?? vec[];
    $this->repeated_sfixed32 = $s['repeated_sfixed32'] ?? vec[];
    $this->repeated_sfixed64 = $s['repeated_sfixed64'] ?? vec[];
    $this->repeated_float = $s['repeated_float'] ?? vec[];
    $this->repeated_double = $s['repeated_double'] ?? vec[];
    $this->repeated_bool = $s['repeated_bool'] ?? vec[];
    $this->repeated_string = $s['repeated_string'] ?? vec[];
    $this->repeated_bytes = $s['repeated_bytes'] ?? vec[];
    $this->repeated_nested_message = $s['repeated_nested_message'] ?? vec[];
    $this->repeated_foreign_message = $s['repeated_foreign_message'] ?? vec[];
    $this->repeated_nested_enum = $s['repeated_nested_enum'] ?? vec[];
    $this->repeated_foreign_enum = $s['repeated_foreign_enum'] ?? vec[];
    $this->repeated_string_piece = $s['repeated_string_piece'] ?? vec[];
    $this->repeated_cord = $s['repeated_cord'] ?? vec[];
    $this->packed_int32 = $s['packed_int32'] ?? vec[];
    $this->packed_int64 = $s['packed_int64'] ?? vec[];
    $this->packed_uint32 = $s['packed_uint32'] ?? vec[];
    $this->packed_uint64 = $s['packed_uint64'] ?? vec[];
    $this->packed_sint32 = $s['packed_sint32'] ?? vec[];
    $this->packed_sint64 = $s['packed_sint64'] ?? vec[];
    $this->packed_fixed32 = $s['packed_fixed32'] ?? vec[];
    $this->packed_fixed64 = $s['packed_fixed64'] ?? vec[];
    $this->packed_sfixed32 = $s['packed_sfixed32'] ?? vec[];
    $this->packed_sfixed64 = $s['packed_sfixed64'] ?? vec[];
    $this->packed_float = $s['packed_float'] ?? vec[];
    $this->packed_double = $s['packed_double'] ?? vec[];
    $this->packed_bool = $s['packed_bool'] ?? vec[];
    $this->packed_nested_enum = $s['packed_nested_enum'] ?? vec[];
    $this->unpacked_int32 = $s['unpacked_int32'] ?? vec[];
    $this->unpacked_int64 = $s['unpacked_int64'] ?? vec[];
    $this->unpacked_uint32 = $s['unpacked_uint32'] ?? vec[];
    $this->unpacked_uint64 = $s['unpacked_uint64'] ?? vec[];
    $this->unpacked_sint32 = $s['unpacked_sint32'] ?? vec[];
    $this->unpacked_sint64 = $s['unpacked_sint64'] ?? vec[];
    $this->unpacked_fixed32 = $s['unpacked_fixed32'] ?? vec[];
    $this->unpacked_fixed64 = $s['unpacked_fixed64'] ?? vec[];
    $this->unpacked_sfixed32 = $s['unpacked_sfixed32'] ?? vec[];
    $this->unpacked_sfixed64 = $s['unpacked_sfixed64'] ?? vec[];
    $this->unpacked_float = $s['unpacked_float'] ?? vec[];
    $this->unpacked_double = $s['unpacked_double'] ?? vec[];
    $this->unpacked_bool = $s['unpacked_bool'] ?? vec[];
    $this->unpacked_nested_enum = $s['unpacked_nested_enum'] ?? vec[];
    $this->map_int32_int32 = $s['map_int32_int32'] ?? dict[];
    $this->map_int64_int64 = $s['map_int64_int64'] ?? dict[];
    $this->map_uint32_uint32 = $s['map_uint32_uint32'] ?? dict[];
    $this->map_uint64_uint64 = $s['map_uint64_uint64'] ?? dict[];
    $this->map_sint32_sint32 = $s['map_sint32_sint32'] ?? dict[];
    $this->map_sint64_sint64 = $s['map_sint64_sint64'] ?? dict[];
    $this->map_fixed32_fixed32 = $s['map_fixed32_fixed32'] ?? dict[];
    $this->map_fixed64_fixed64 = $s['map_fixed64_fixed64'] ?? dict[];
    $this->map_sfixed32_sfixed32 = $s['map_sfixed32_sfixed32'] ?? dict[];
    $this->map_sfixed64_sfixed64 = $s['map_sfixed64_sfixed64'] ?? dict[];
    $this->map_int32_float = $s['map_int32_float'] ?? dict[];
    $this->map_int32_double = $s['map_int32_double'] ?? dict[];
    $this->map_bool_bool = $s['map_bool_bool'] ?? dict[];
    $this->map_string_string = $s['map_string_string'] ?? dict[];
    $this->map_string_bytes = $s['map_string_bytes'] ?? dict[];
    $this->map_string_nested_message = $s['map_string_nested_message'] ?? dict[];
    $this->map_string_foreign_message = $s['map_string_foreign_message'] ?? dict[];
    $this->map_string_nested_enum = $s['map_string_nested_enum'] ?? dict[];
    $this->map_string_foreign_enum = $s['map_string_foreign_enum'] ?? dict[];
    $this->data = $s['data'] ?? null;
    $this->fieldname1 = $s['fieldname1'] ?? 0;
    $this->field_name2 = $s['field_name2'] ?? 0;
    $this->_field_name3 = $s['_field_name3'] ?? 0;
    $this->field__name4_ = $s['field__name4_'] ?? 0;
    $this->field0name5 = $s['field0name5'] ?? 0;
    $this->field_0_name6 = $s['field_0_name6'] ?? 0;
    $this->fieldName7 = $s['fieldName7'] ?? 0;
    $this->FieldName8 = $s['FieldName8'] ?? 0;
    $this->field_Name9 = $s['field_Name9'] ?? 0;
    $this->Field_Name10 = $s['Field_Name10'] ?? 0;
    $this->FIELD_NAME11 = $s['FIELD_NAME11'] ?? 0;
    $this->FIELD_name12 = $s['FIELD_name12'] ?? 0;
    $this->__field_name13 = $s['__field_name13'] ?? 0;
    $this->__Field_name14 = $s['__Field_name14'] ?? 0;
    $this->field__name15 = $s['field__name15'] ?? 0;
    $this->field__Name16 = $s['field__Name16'] ?? 0;
    $this->field_name17__ = $s['field_name17__'] ?? 0;
    $this->Field_name18__ = $s['Field_name18__'] ?? 0;
    $this->oneof_field = $s['oneof_field'] ?? new TestAllTypesProto2_oneof_field_NOT_SET();
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->optional_int32 = $d->readVarint32Signed();
          break;
        case 2:
          $this->optional_int64 = $d->readVarint();
          break;
        case 3:
          $this->optional_uint32 = $d->readVarint32();
          break;
        case 4:
          $this->optional_uint64 = $d->readVarint();
          break;
        case 5:
          $this->optional_sint32 = $d->readVarintZigZag32();
          break;
        case 6:
          $this->optional_sint64 = $d->readVarintZigZag64();
          break;
        case 7:
          $this->optional_fixed32 = $d->readLittleEndianInt32Unsigned();
          break;
        case 8:
          $this->optional_fixed64 = $d->readLittleEndianInt64();
          break;
        case 9:
          $this->optional_sfixed32 = $d->readLittleEndianInt32Signed();
          break;
        case 10:
          $this->optional_sfixed64 = $d->readLittleEndianInt64();
          break;
        case 11:
          $this->optional_float = $d->readFloat();
          break;
        case 12:
          $this->optional_double = $d->readDouble();
          break;
        case 13:
          $this->optional_bool = $d->readBool();
          break;
        case 14:
          $this->optional_string = $d->readString();
          break;
        case 15:
          $this->optional_bytes = $d->readString();
          break;
        case 18:
          if ($this->optional_nested_message == null) $this->optional_nested_message = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
          $this->optional_nested_message->MergeFrom($d->readDecoder());
          break;
        case 19:
          if ($this->optional_foreign_message == null) $this->optional_foreign_message = new \protobuf_test_messages\proto2\ForeignMessageProto2();
          $this->optional_foreign_message->MergeFrom($d->readDecoder());
          break;
        case 21:
          $this->optional_nested_enum = \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($d->readVarint());
          break;
        case 22:
          $this->optional_foreign_enum = \protobuf_test_messages\proto2\ForeignEnumProto2::FromInt($d->readVarint());
          break;
        case 24:
          $this->optional_string_piece = $d->readString();
          break;
        case 25:
          $this->optional_cord = $d->readString();
          break;
        case 27:
          if ($this->recursive_message == null) $this->recursive_message = new \protobuf_test_messages\proto2\TestAllTypesProto2();
          $this->recursive_message->MergeFrom($d->readDecoder());
          break;
        case 31:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_int32 []= $packed->readVarint32Signed();
            }
          } else {
            $this->repeated_int32 []= $d->readVarint32Signed();
          }
          break;
        case 32:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_int64 []= $packed->readVarint();
            }
          } else {
            $this->repeated_int64 []= $d->readVarint();
          }
          break;
        case 33:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_uint32 []= $packed->readVarint32();
            }
          } else {
            $this->repeated_uint32 []= $d->readVarint32();
          }
          break;
        case 34:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_uint64 []= $packed->readVarint();
            }
          } else {
            $this->repeated_uint64 []= $d->readVarint();
          }
          break;
        case 35:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_sint32 []= $packed->readVarintZigZag32();
            }
          } else {
            $this->repeated_sint32 []= $d->readVarintZigZag32();
          }
          break;
        case 36:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_sint64 []= $packed->readVarintZigZag64();
            }
          } else {
            $this->repeated_sint64 []= $d->readVarintZigZag64();
          }
          break;
        case 37:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_fixed32 []= $packed->readLittleEndianInt32Unsigned();
            }
          } else {
            $this->repeated_fixed32 []= $d->readLittleEndianInt32Unsigned();
          }
          break;
        case 38:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_fixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->repeated_fixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 39:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_sfixed32 []= $packed->readLittleEndianInt32Signed();
            }
          } else {
            $this->repeated_sfixed32 []= $d->readLittleEndianInt32Signed();
          }
          break;
        case 40:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_sfixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->repeated_sfixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 41:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_float []= $packed->readFloat();
            }
          } else {
            $this->repeated_float []= $d->readFloat();
          }
          break;
        case 42:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_double []= $packed->readDouble();
            }
          } else {
            $this->repeated_double []= $d->readDouble();
          }
          break;
        case 43:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_bool []= $packed->readBool();
            }
          } else {
            $this->repeated_bool []= $d->readBool();
          }
          break;
        case 44:
          $this->repeated_string []= $d->readString();
          break;
        case 45:
          $this->repeated_bytes []= $d->readString();
          break;
        case 48:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_nested_message []= $obj;
          break;
        case 49:
          $obj = new \protobuf_test_messages\proto2\ForeignMessageProto2();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_foreign_message []= $obj;
          break;
        case 51:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($packed->readVarint());
            }
          } else {
            $this->repeated_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($d->readVarint());
          }
          break;
        case 52:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_foreign_enum []= \protobuf_test_messages\proto2\ForeignEnumProto2::FromInt($packed->readVarint());
            }
          } else {
            $this->repeated_foreign_enum []= \protobuf_test_messages\proto2\ForeignEnumProto2::FromInt($d->readVarint());
          }
          break;
        case 54:
          $this->repeated_string_piece []= $d->readString();
          break;
        case 55:
          $this->repeated_cord []= $d->readString();
          break;
        case 56:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32Int32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int32_int32[$obj->key] = $obj->value;
          break;
        case 57:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt64Int64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int64_int64[$obj->key] = $obj->value;
          break;
        case 58:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapUint32Uint32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_uint32_uint32[$obj->key] = $obj->value;
          break;
        case 59:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapUint64Uint64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_uint64_uint64[$obj->key] = $obj->value;
          break;
        case 60:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSint32Sint32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_sint32_sint32[$obj->key] = $obj->value;
          break;
        case 61:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSint64Sint64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_sint64_sint64[$obj->key] = $obj->value;
          break;
        case 62:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapFixed32Fixed32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_fixed32_fixed32[$obj->key] = $obj->value;
          break;
        case 63:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapFixed64Fixed64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_fixed64_fixed64[$obj->key] = $obj->value;
          break;
        case 64:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSfixed32Sfixed32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_sfixed32_sfixed32[$obj->key] = $obj->value;
          break;
        case 65:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSfixed64Sfixed64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_sfixed64_sfixed64[$obj->key] = $obj->value;
          break;
        case 66:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32FloatEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int32_float[$obj->key] = $obj->value;
          break;
        case 67:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32DoubleEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int32_double[$obj->key] = $obj->value;
          break;
        case 68:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapBoolBoolEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_bool_bool[\Protobuf\BoolMapKey::FromBool($obj->key)] = $obj->value;
          break;
        case 69:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringStringEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_string[$obj->key] = $obj->value;
          break;
        case 70:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringBytesEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_bytes[$obj->key] = $obj->value;
          break;
        case 71:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringNestedMessageEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_nested_message[$obj->key] = $obj->value ?? new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
          break;
        case 72:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringForeignMessageEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_foreign_message[$obj->key] = $obj->value ?? new \protobuf_test_messages\proto2\ForeignMessageProto2();
          break;
        case 73:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringNestedEnumEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_nested_enum[$obj->key] = $obj->value;
          break;
        case 74:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringForeignEnumEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_foreign_enum[$obj->key] = $obj->value;
          break;
        case 75:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_int32 []= $packed->readVarint32Signed();
            }
          } else {
            $this->packed_int32 []= $d->readVarint32Signed();
          }
          break;
        case 76:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_int64 []= $packed->readVarint();
            }
          } else {
            $this->packed_int64 []= $d->readVarint();
          }
          break;
        case 77:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_uint32 []= $packed->readVarint32();
            }
          } else {
            $this->packed_uint32 []= $d->readVarint32();
          }
          break;
        case 78:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_uint64 []= $packed->readVarint();
            }
          } else {
            $this->packed_uint64 []= $d->readVarint();
          }
          break;
        case 79:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_sint32 []= $packed->readVarintZigZag32();
            }
          } else {
            $this->packed_sint32 []= $d->readVarintZigZag32();
          }
          break;
        case 80:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_sint64 []= $packed->readVarintZigZag64();
            }
          } else {
            $this->packed_sint64 []= $d->readVarintZigZag64();
          }
          break;
        case 81:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_fixed32 []= $packed->readLittleEndianInt32Unsigned();
            }
          } else {
            $this->packed_fixed32 []= $d->readLittleEndianInt32Unsigned();
          }
          break;
        case 82:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_fixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->packed_fixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 83:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_sfixed32 []= $packed->readLittleEndianInt32Signed();
            }
          } else {
            $this->packed_sfixed32 []= $d->readLittleEndianInt32Signed();
          }
          break;
        case 84:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_sfixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->packed_sfixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 85:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_float []= $packed->readFloat();
            }
          } else {
            $this->packed_float []= $d->readFloat();
          }
          break;
        case 86:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_double []= $packed->readDouble();
            }
          } else {
            $this->packed_double []= $d->readDouble();
          }
          break;
        case 87:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_bool []= $packed->readBool();
            }
          } else {
            $this->packed_bool []= $d->readBool();
          }
          break;
        case 88:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($packed->readVarint());
            }
          } else {
            $this->packed_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($d->readVarint());
          }
          break;
        case 89:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_int32 []= $packed->readVarint32Signed();
            }
          } else {
            $this->unpacked_int32 []= $d->readVarint32Signed();
          }
          break;
        case 90:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_int64 []= $packed->readVarint();
            }
          } else {
            $this->unpacked_int64 []= $d->readVarint();
          }
          break;
        case 91:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_uint32 []= $packed->readVarint32();
            }
          } else {
            $this->unpacked_uint32 []= $d->readVarint32();
          }
          break;
        case 92:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_uint64 []= $packed->readVarint();
            }
          } else {
            $this->unpacked_uint64 []= $d->readVarint();
          }
          break;
        case 93:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_sint32 []= $packed->readVarintZigZag32();
            }
          } else {
            $this->unpacked_sint32 []= $d->readVarintZigZag32();
          }
          break;
        case 94:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_sint64 []= $packed->readVarintZigZag64();
            }
          } else {
            $this->unpacked_sint64 []= $d->readVarintZigZag64();
          }
          break;
        case 95:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_fixed32 []= $packed->readLittleEndianInt32Unsigned();
            }
          } else {
            $this->unpacked_fixed32 []= $d->readLittleEndianInt32Unsigned();
          }
          break;
        case 96:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_fixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->unpacked_fixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 97:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_sfixed32 []= $packed->readLittleEndianInt32Signed();
            }
          } else {
            $this->unpacked_sfixed32 []= $d->readLittleEndianInt32Signed();
          }
          break;
        case 98:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_sfixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->unpacked_sfixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 99:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_float []= $packed->readFloat();
            }
          } else {
            $this->unpacked_float []= $d->readFloat();
          }
          break;
        case 100:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_double []= $packed->readDouble();
            }
          } else {
            $this->unpacked_double []= $d->readDouble();
          }
          break;
        case 101:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_bool []= $packed->readBool();
            }
          } else {
            $this->unpacked_bool []= $d->readBool();
          }
          break;
        case 102:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($packed->readVarint());
            }
          } else {
            $this->unpacked_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($d->readVarint());
          }
          break;
        case 111:
          $this->oneof_field = new TestAllTypesProto2_oneof_uint32($d->readVarint32());
          break;
        case 112:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
          $obj->MergeFrom($d->readDecoder());
          $this->oneof_field = new TestAllTypesProto2_oneof_nested_message($obj);
          break;
        case 113:
          $this->oneof_field = new TestAllTypesProto2_oneof_string($d->readString());
          break;
        case 114:
          $this->oneof_field = new TestAllTypesProto2_oneof_bytes($d->readString());
          break;
        case 115:
          $this->oneof_field = new TestAllTypesProto2_oneof_bool($d->readBool());
          break;
        case 116:
          $this->oneof_field = new TestAllTypesProto2_oneof_uint64($d->readVarint());
          break;
        case 117:
          $this->oneof_field = new TestAllTypesProto2_oneof_float($d->readFloat());
          break;
        case 118:
          $this->oneof_field = new TestAllTypesProto2_oneof_double($d->readDouble());
          break;
        case 119:
          $this->oneof_field = new TestAllTypesProto2_oneof_enum(\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($d->readVarint()));
          break;
        case 201:
          if ($this->data == null) $this->data = new \protobuf_test_messages\proto2\TestAllTypesProto2_Data();
          $this->data->MergeFrom($d->readDecoder());
          break;
        case 401:
          $this->fieldname1 = $d->readVarint32Signed();
          break;
        case 402:
          $this->field_name2 = $d->readVarint32Signed();
          break;
        case 403:
          $this->_field_name3 = $d->readVarint32Signed();
          break;
        case 404:
          $this->field__name4_ = $d->readVarint32Signed();
          break;
        case 405:
          $this->field0name5 = $d->readVarint32Signed();
          break;
        case 406:
          $this->field_0_name6 = $d->readVarint32Signed();
          break;
        case 407:
          $this->fieldName7 = $d->readVarint32Signed();
          break;
        case 408:
          $this->FieldName8 = $d->readVarint32Signed();
          break;
        case 409:
          $this->field_Name9 = $d->readVarint32Signed();
          break;
        case 410:
          $this->Field_Name10 = $d->readVarint32Signed();
          break;
        case 411:
          $this->FIELD_NAME11 = $d->readVarint32Signed();
          break;
        case 412:
          $this->FIELD_name12 = $d->readVarint32Signed();
          break;
        case 413:
          $this->__field_name13 = $d->readVarint32Signed();
          break;
        case 414:
          $this->__Field_name14 = $d->readVarint32Signed();
          break;
        case 415:
          $this->field__name15 = $d->readVarint32Signed();
          break;
        case 416:
          $this->field__Name16 = $d->readVarint32Signed();
          break;
        case 417:
          $this->field_name17__ = $d->readVarint32Signed();
          break;
        case 418:
          $this->Field_name18__ = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->optional_int32 !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->optional_int32);
    }
    if ($this->optional_int64 !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->optional_int64);
    }
    if ($this->optional_uint32 !== 0) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->optional_uint32);
    }
    if ($this->optional_uint64 !== 0) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->optional_uint64);
    }
    if ($this->optional_sint32 !== 0) {
      $e->writeTag(5, 0);
      $e->writeVarintZigZag32($this->optional_sint32);
    }
    if ($this->optional_sint64 !== 0) {
      $e->writeTag(6, 0);
      $e->writeVarintZigZag64($this->optional_sint64);
    }
    if ($this->optional_fixed32 !== 0) {
      $e->writeTag(7, 5);
      $e->writeLittleEndianInt32Unsigned($this->optional_fixed32);
    }
    if ($this->optional_fixed64 !== 0) {
      $e->writeTag(8, 1);
      $e->writeLittleEndianInt64($this->optional_fixed64);
    }
    if ($this->optional_sfixed32 !== 0) {
      $e->writeTag(9, 5);
      $e->writeLittleEndianInt32Signed($this->optional_sfixed32);
    }
    if ($this->optional_sfixed64 !== 0) {
      $e->writeTag(10, 1);
      $e->writeLittleEndianInt64($this->optional_sfixed64);
    }
    if ($this->optional_float !== 0.0) {
      $e->writeTag(11, 5);
      $e->writeFloat($this->optional_float);
    }
    if ($this->optional_double !== 0.0) {
      $e->writeTag(12, 1);
      $e->writeDouble($this->optional_double);
    }
    if ($this->optional_bool !== false) {
      $e->writeTag(13, 0);
      $e->writeBool($this->optional_bool);
    }
    if ($this->optional_string !== '') {
      $e->writeTag(14, 2);
      $e->writeString($this->optional_string);
    }
    if ($this->optional_bytes !== '') {
      $e->writeTag(15, 2);
      $e->writeString($this->optional_bytes);
    }
    $msg = $this->optional_nested_message;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 18);
    }
    $msg = $this->optional_foreign_message;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 19);
    }
    if ($this->optional_nested_enum !== \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt(0)) {
      $e->writeTag(21, 0);
      $e->writeVarint($this->optional_nested_enum);
    }
    if ($this->optional_foreign_enum !== \protobuf_test_messages\proto2\ForeignEnumProto2::FromInt(0)) {
      $e->writeTag(22, 0);
      $e->writeVarint($this->optional_foreign_enum);
    }
    if ($this->optional_string_piece !== '') {
      $e->writeTag(24, 2);
      $e->writeString($this->optional_string_piece);
    }
    if ($this->optional_cord !== '') {
      $e->writeTag(25, 2);
      $e->writeString($this->optional_cord);
    }
    $msg = $this->recursive_message;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 27);
    }
    foreach ($this->repeated_int32 as $elem) {
      $e->writeTag(31, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->repeated_int64 as $elem) {
      $e->writeTag(32, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->repeated_uint32 as $elem) {
      $e->writeTag(33, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->repeated_uint64 as $elem) {
      $e->writeTag(34, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->repeated_sint32 as $elem) {
      $e->writeTag(35, 0);
      $e->writeVarintZigZag32($elem);
    }
    foreach ($this->repeated_sint64 as $elem) {
      $e->writeTag(36, 0);
      $e->writeVarintZigZag64($elem);
    }
    foreach ($this->repeated_fixed32 as $elem) {
      $e->writeTag(37, 5);
      $e->writeLittleEndianInt32Unsigned($elem);
    }
    foreach ($this->repeated_fixed64 as $elem) {
      $e->writeTag(38, 1);
      $e->writeLittleEndianInt64($elem);
    }
    foreach ($this->repeated_sfixed32 as $elem) {
      $e->writeTag(39, 5);
      $e->writeLittleEndianInt32Signed($elem);
    }
    foreach ($this->repeated_sfixed64 as $elem) {
      $e->writeTag(40, 1);
      $e->writeLittleEndianInt64($elem);
    }
    foreach ($this->repeated_float as $elem) {
      $e->writeTag(41, 5);
      $e->writeFloat($elem);
    }
    foreach ($this->repeated_double as $elem) {
      $e->writeTag(42, 1);
      $e->writeDouble($elem);
    }
    foreach ($this->repeated_bool as $elem) {
      $e->writeTag(43, 0);
      $e->writeBool($elem);
    }
    foreach ($this->repeated_string as $elem) {
      $e->writeTag(44, 2);
      $e->writeString($elem);
    }
    foreach ($this->repeated_bytes as $elem) {
      $e->writeTag(45, 2);
      $e->writeString($elem);
    }
    foreach ($this->repeated_nested_message as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 48);
    }
    foreach ($this->repeated_foreign_message as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 49);
    }
    foreach ($this->repeated_nested_enum as $elem) {
      $e->writeTag(51, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->repeated_foreign_enum as $elem) {
      $e->writeTag(52, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->repeated_string_piece as $elem) {
      $e->writeTag(54, 2);
      $e->writeString($elem);
    }
    foreach ($this->repeated_cord as $elem) {
      $e->writeTag(55, 2);
      $e->writeString($elem);
    }
    foreach ($this->map_int32_int32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32Int32Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 56);
    }
    foreach ($this->map_int64_int64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt64Int64Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 57);
    }
    foreach ($this->map_uint32_uint32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapUint32Uint32Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 58);
    }
    foreach ($this->map_uint64_uint64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapUint64Uint64Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 59);
    }
    foreach ($this->map_sint32_sint32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSint32Sint32Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 60);
    }
    foreach ($this->map_sint64_sint64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSint64Sint64Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 61);
    }
    foreach ($this->map_fixed32_fixed32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapFixed32Fixed32Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 62);
    }
    foreach ($this->map_fixed64_fixed64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapFixed64Fixed64Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 63);
    }
    foreach ($this->map_sfixed32_sfixed32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSfixed32Sfixed32Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 64);
    }
    foreach ($this->map_sfixed64_sfixed64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSfixed64Sfixed64Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 65);
    }
    foreach ($this->map_int32_float as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32FloatEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 66);
    }
    foreach ($this->map_int32_double as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32DoubleEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 67);
    }
    foreach ($this->map_bool_bool as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapBoolBoolEntry();
      $obj->key = \Protobuf\BoolMapKey::ToBool($k);
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 68);
    }
    foreach ($this->map_string_string as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringStringEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 69);
    }
    foreach ($this->map_string_bytes as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringBytesEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 70);
    }
    foreach ($this->map_string_nested_message as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringNestedMessageEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 71);
    }
    foreach ($this->map_string_foreign_message as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringForeignMessageEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 72);
    }
    foreach ($this->map_string_nested_enum as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringNestedEnumEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 73);
    }
    foreach ($this->map_string_foreign_enum as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringForeignEnumEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 74);
    }
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_int32 as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 75);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_int64 as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 76);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_uint32 as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 77);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_uint64 as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 78);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_sint32 as $elem) {
      $packed->writeVarintZigZag32($elem);
    }
    $e->writeEncoder($packed, 79);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_sint64 as $elem) {
      $packed->writeVarintZigZag64($elem);
    }
    $e->writeEncoder($packed, 80);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_fixed32 as $elem) {
      $packed->writeLittleEndianInt32Unsigned($elem);
    }
    $e->writeEncoder($packed, 81);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_fixed64 as $elem) {
      $packed->writeLittleEndianInt64($elem);
    }
    $e->writeEncoder($packed, 82);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_sfixed32 as $elem) {
      $packed->writeLittleEndianInt32Signed($elem);
    }
    $e->writeEncoder($packed, 83);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_sfixed64 as $elem) {
      $packed->writeLittleEndianInt64($elem);
    }
    $e->writeEncoder($packed, 84);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_float as $elem) {
      $packed->writeFloat($elem);
    }
    $e->writeEncoder($packed, 85);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_double as $elem) {
      $packed->writeDouble($elem);
    }
    $e->writeEncoder($packed, 86);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_bool as $elem) {
      $packed->writeBool($elem);
    }
    $e->writeEncoder($packed, 87);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->packed_nested_enum as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 88);
    foreach ($this->unpacked_int32 as $elem) {
      $e->writeTag(89, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->unpacked_int64 as $elem) {
      $e->writeTag(90, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->unpacked_uint32 as $elem) {
      $e->writeTag(91, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->unpacked_uint64 as $elem) {
      $e->writeTag(92, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->unpacked_sint32 as $elem) {
      $e->writeTag(93, 0);
      $e->writeVarintZigZag32($elem);
    }
    foreach ($this->unpacked_sint64 as $elem) {
      $e->writeTag(94, 0);
      $e->writeVarintZigZag64($elem);
    }
    foreach ($this->unpacked_fixed32 as $elem) {
      $e->writeTag(95, 5);
      $e->writeLittleEndianInt32Unsigned($elem);
    }
    foreach ($this->unpacked_fixed64 as $elem) {
      $e->writeTag(96, 1);
      $e->writeLittleEndianInt64($elem);
    }
    foreach ($this->unpacked_sfixed32 as $elem) {
      $e->writeTag(97, 5);
      $e->writeLittleEndianInt32Signed($elem);
    }
    foreach ($this->unpacked_sfixed64 as $elem) {
      $e->writeTag(98, 1);
      $e->writeLittleEndianInt64($elem);
    }
    foreach ($this->unpacked_float as $elem) {
      $e->writeTag(99, 5);
      $e->writeFloat($elem);
    }
    foreach ($this->unpacked_double as $elem) {
      $e->writeTag(100, 1);
      $e->writeDouble($elem);
    }
    foreach ($this->unpacked_bool as $elem) {
      $e->writeTag(101, 0);
      $e->writeBool($elem);
    }
    foreach ($this->unpacked_nested_enum as $elem) {
      $e->writeTag(102, 0);
      $e->writeVarint($elem);
    }
    $msg = $this->data;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 201);
    }
    if ($this->fieldname1 !== 0) {
      $e->writeTag(401, 0);
      $e->writeVarint($this->fieldname1);
    }
    if ($this->field_name2 !== 0) {
      $e->writeTag(402, 0);
      $e->writeVarint($this->field_name2);
    }
    if ($this->_field_name3 !== 0) {
      $e->writeTag(403, 0);
      $e->writeVarint($this->_field_name3);
    }
    if ($this->field__name4_ !== 0) {
      $e->writeTag(404, 0);
      $e->writeVarint($this->field__name4_);
    }
    if ($this->field0name5 !== 0) {
      $e->writeTag(405, 0);
      $e->writeVarint($this->field0name5);
    }
    if ($this->field_0_name6 !== 0) {
      $e->writeTag(406, 0);
      $e->writeVarint($this->field_0_name6);
    }
    if ($this->fieldName7 !== 0) {
      $e->writeTag(407, 0);
      $e->writeVarint($this->fieldName7);
    }
    if ($this->FieldName8 !== 0) {
      $e->writeTag(408, 0);
      $e->writeVarint($this->FieldName8);
    }
    if ($this->field_Name9 !== 0) {
      $e->writeTag(409, 0);
      $e->writeVarint($this->field_Name9);
    }
    if ($this->Field_Name10 !== 0) {
      $e->writeTag(410, 0);
      $e->writeVarint($this->Field_Name10);
    }
    if ($this->FIELD_NAME11 !== 0) {
      $e->writeTag(411, 0);
      $e->writeVarint($this->FIELD_NAME11);
    }
    if ($this->FIELD_name12 !== 0) {
      $e->writeTag(412, 0);
      $e->writeVarint($this->FIELD_name12);
    }
    if ($this->__field_name13 !== 0) {
      $e->writeTag(413, 0);
      $e->writeVarint($this->__field_name13);
    }
    if ($this->__Field_name14 !== 0) {
      $e->writeTag(414, 0);
      $e->writeVarint($this->__Field_name14);
    }
    if ($this->field__name15 !== 0) {
      $e->writeTag(415, 0);
      $e->writeVarint($this->field__name15);
    }
    if ($this->field__Name16 !== 0) {
      $e->writeTag(416, 0);
      $e->writeVarint($this->field__Name16);
    }
    if ($this->field_name17__ !== 0) {
      $e->writeTag(417, 0);
      $e->writeVarint($this->field_name17__);
    }
    if ($this->Field_name18__ !== 0) {
      $e->writeTag(418, 0);
      $e->writeVarint($this->Field_name18__);
    }
    $this->oneof_field->WriteTo($e);
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('optional_int32', 'optionalInt32', $this->optional_int32, false);
    $e->writeInt64Signed('optional_int64', 'optionalInt64', $this->optional_int64, false);
    $e->writeInt32('optional_uint32', 'optionalUint32', $this->optional_uint32, false);
    $e->writeInt64Unsigned('optional_uint64', 'optionalUint64', $this->optional_uint64, false);
    $e->writeInt32('optional_sint32', 'optionalSint32', $this->optional_sint32, false);
    $e->writeInt64Signed('optional_sint64', 'optionalSint64', $this->optional_sint64, false);
    $e->writeInt32('optional_fixed32', 'optionalFixed32', $this->optional_fixed32, false);
    $e->writeInt64Unsigned('optional_fixed64', 'optionalFixed64', $this->optional_fixed64, false);
    $e->writeInt32('optional_sfixed32', 'optionalSfixed32', $this->optional_sfixed32, false);
    $e->writeInt64Signed('optional_sfixed64', 'optionalSfixed64', $this->optional_sfixed64, false);
    $e->writeFloat('optional_float', 'optionalFloat', $this->optional_float, false);
    $e->writeFloat('optional_double', 'optionalDouble', $this->optional_double, false);
    $e->writeBool('optional_bool', 'optionalBool', $this->optional_bool, false);
    $e->writeString('optional_string', 'optionalString', $this->optional_string, false);
    $e->writeBytes('optional_bytes', 'optionalBytes', $this->optional_bytes, false);
    $e->writeMessage('optional_nested_message', 'optionalNestedMessage', $this->optional_nested_message, false);
    $e->writeMessage('optional_foreign_message', 'optionalForeignMessage', $this->optional_foreign_message, false);
    $e->writeEnum('optional_nested_enum', 'optionalNestedEnum', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->optional_nested_enum, false);
    $e->writeEnum('optional_foreign_enum', 'optionalForeignEnum', \protobuf_test_messages\proto2\ForeignEnumProto2::ToStringDict(), $this->optional_foreign_enum, false);
    $e->writeString('optional_string_piece', 'optionalStringPiece', $this->optional_string_piece, false);
    $e->writeString('optional_cord', 'optionalCord', $this->optional_cord, false);
    $e->writeMessage('recursive_message', 'recursiveMessage', $this->recursive_message, false);
    $e->writePrimitiveList('repeated_int32', 'repeatedInt32', $this->repeated_int32);
    $e->writeInt64SignedList('repeated_int64', 'repeatedInt64', $this->repeated_int64);
    $e->writePrimitiveList('repeated_uint32', 'repeatedUint32', $this->repeated_uint32);
    $e->writeInt64UnsignedList('repeated_uint64', 'repeatedUint64', $this->repeated_uint64);
    $e->writePrimitiveList('repeated_sint32', 'repeatedSint32', $this->repeated_sint32);
    $e->writeInt64SignedList('repeated_sint64', 'repeatedSint64', $this->repeated_sint64);
    $e->writePrimitiveList('repeated_fixed32', 'repeatedFixed32', $this->repeated_fixed32);
    $e->writeInt64UnsignedList('repeated_fixed64', 'repeatedFixed64', $this->repeated_fixed64);
    $e->writePrimitiveList('repeated_sfixed32', 'repeatedSfixed32', $this->repeated_sfixed32);
    $e->writeInt64SignedList('repeated_sfixed64', 'repeatedSfixed64', $this->repeated_sfixed64);
    $e->writeFloatList('repeated_float', 'repeatedFloat', $this->repeated_float);
    $e->writeFloatList('repeated_double', 'repeatedDouble', $this->repeated_double);
    $e->writePrimitiveList('repeated_bool', 'repeatedBool', $this->repeated_bool);
    $e->writePrimitiveList('repeated_string', 'repeatedString', $this->repeated_string);
    $e->writeBytesList('repeated_bytes', 'repeatedBytes', $this->repeated_bytes);
    $e->writeMessageList('repeated_nested_message', 'repeatedNestedMessage', $this->repeated_nested_message);
    $e->writeMessageList('repeated_foreign_message', 'repeatedForeignMessage', $this->repeated_foreign_message);
    $e->writeEnumList('repeated_nested_enum', 'repeatedNestedEnum', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->repeated_nested_enum);
    $e->writeEnumList('repeated_foreign_enum', 'repeatedForeignEnum', \protobuf_test_messages\proto2\ForeignEnumProto2::ToStringDict(), $this->repeated_foreign_enum);
    $e->writePrimitiveList('repeated_string_piece', 'repeatedStringPiece', $this->repeated_string_piece);
    $e->writePrimitiveList('repeated_cord', 'repeatedCord', $this->repeated_cord);
    $e->writePrimitiveMap('map_int32_int32', 'mapInt32Int32', $this->map_int32_int32);
    $e->writeInt64SignedMap('map_int64_int64', 'mapInt64Int64', $this->map_int64_int64);
    $e->writePrimitiveMap('map_uint32_uint32', 'mapUint32Uint32', $this->map_uint32_uint32);
    $e->writeInt64UnsignedMap('map_uint64_uint64', 'mapUint64Uint64', $this->map_uint64_uint64);
    $e->writePrimitiveMap('map_sint32_sint32', 'mapSint32Sint32', $this->map_sint32_sint32);
    $e->writeInt64SignedMap('map_sint64_sint64', 'mapSint64Sint64', $this->map_sint64_sint64);
    $e->writePrimitiveMap('map_fixed32_fixed32', 'mapFixed32Fixed32', $this->map_fixed32_fixed32);
    $e->writeInt64UnsignedMap('map_fixed64_fixed64', 'mapFixed64Fixed64', $this->map_fixed64_fixed64);
    $e->writePrimitiveMap('map_sfixed32_sfixed32', 'mapSfixed32Sfixed32', $this->map_sfixed32_sfixed32);
    $e->writeInt64SignedMap('map_sfixed64_sfixed64', 'mapSfixed64Sfixed64', $this->map_sfixed64_sfixed64);
    $e->writeFloatMap('map_int32_float', 'mapInt32Float', $this->map_int32_float);
    $e->writeFloatMap('map_int32_double', 'mapInt32Double', $this->map_int32_double);
    $e->writePrimitiveMap('map_bool_bool', 'mapBoolBool', $this->map_bool_bool);
    $e->writePrimitiveMap('map_string_string', 'mapStringString', $this->map_string_string);
    $e->writeBytesMap('map_string_bytes', 'mapStringBytes', $this->map_string_bytes);
    $e->writeMessageMap('map_string_nested_message', 'mapStringNestedMessage', $this->map_string_nested_message);
    $e->writeMessageMap('map_string_foreign_message', 'mapStringForeignMessage', $this->map_string_foreign_message);
    $e->writeEnumMap('map_string_nested_enum', 'mapStringNestedEnum', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->map_string_nested_enum);
    $e->writeEnumMap('map_string_foreign_enum', 'mapStringForeignEnum', \protobuf_test_messages\proto2\ForeignEnumProto2::ToStringDict(), $this->map_string_foreign_enum);
    $e->writePrimitiveList('packed_int32', 'packedInt32', $this->packed_int32);
    $e->writeInt64SignedList('packed_int64', 'packedInt64', $this->packed_int64);
    $e->writePrimitiveList('packed_uint32', 'packedUint32', $this->packed_uint32);
    $e->writeInt64UnsignedList('packed_uint64', 'packedUint64', $this->packed_uint64);
    $e->writePrimitiveList('packed_sint32', 'packedSint32', $this->packed_sint32);
    $e->writeInt64SignedList('packed_sint64', 'packedSint64', $this->packed_sint64);
    $e->writePrimitiveList('packed_fixed32', 'packedFixed32', $this->packed_fixed32);
    $e->writeInt64UnsignedList('packed_fixed64', 'packedFixed64', $this->packed_fixed64);
    $e->writePrimitiveList('packed_sfixed32', 'packedSfixed32', $this->packed_sfixed32);
    $e->writeInt64SignedList('packed_sfixed64', 'packedSfixed64', $this->packed_sfixed64);
    $e->writeFloatList('packed_float', 'packedFloat', $this->packed_float);
    $e->writeFloatList('packed_double', 'packedDouble', $this->packed_double);
    $e->writePrimitiveList('packed_bool', 'packedBool', $this->packed_bool);
    $e->writeEnumList('packed_nested_enum', 'packedNestedEnum', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->packed_nested_enum);
    $e->writePrimitiveList('unpacked_int32', 'unpackedInt32', $this->unpacked_int32);
    $e->writeInt64SignedList('unpacked_int64', 'unpackedInt64', $this->unpacked_int64);
    $e->writePrimitiveList('unpacked_uint32', 'unpackedUint32', $this->unpacked_uint32);
    $e->writeInt64UnsignedList('unpacked_uint64', 'unpackedUint64', $this->unpacked_uint64);
    $e->writePrimitiveList('unpacked_sint32', 'unpackedSint32', $this->unpacked_sint32);
    $e->writeInt64SignedList('unpacked_sint64', 'unpackedSint64', $this->unpacked_sint64);
    $e->writePrimitiveList('unpacked_fixed32', 'unpackedFixed32', $this->unpacked_fixed32);
    $e->writeInt64UnsignedList('unpacked_fixed64', 'unpackedFixed64', $this->unpacked_fixed64);
    $e->writePrimitiveList('unpacked_sfixed32', 'unpackedSfixed32', $this->unpacked_sfixed32);
    $e->writeInt64SignedList('unpacked_sfixed64', 'unpackedSfixed64', $this->unpacked_sfixed64);
    $e->writeFloatList('unpacked_float', 'unpackedFloat', $this->unpacked_float);
    $e->writeFloatList('unpacked_double', 'unpackedDouble', $this->unpacked_double);
    $e->writePrimitiveList('unpacked_bool', 'unpackedBool', $this->unpacked_bool);
    $e->writeEnumList('unpacked_nested_enum', 'unpackedNestedEnum', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->unpacked_nested_enum);
    $e->writeMessage('data', 'data', $this->data, false);
    $e->writeInt32('fieldname1', 'fieldname1', $this->fieldname1, false);
    $e->writeInt32('field_name2', 'fieldName2', $this->field_name2, false);
    $e->writeInt32('_field_name3', 'FieldName3', $this->_field_name3, false);
    $e->writeInt32('field__name4_', 'fieldName4', $this->field__name4_, false);
    $e->writeInt32('field0name5', 'field0name5', $this->field0name5, false);
    $e->writeInt32('field_0_name6', 'field0Name6', $this->field_0_name6, false);
    $e->writeInt32('fieldName7', 'fieldName7', $this->fieldName7, false);
    $e->writeInt32('FieldName8', 'FieldName8', $this->FieldName8, false);
    $e->writeInt32('field_Name9', 'fieldName9', $this->field_Name9, false);
    $e->writeInt32('Field_Name10', 'FieldName10', $this->Field_Name10, false);
    $e->writeInt32('FIELD_NAME11', 'FIELDNAME11', $this->FIELD_NAME11, false);
    $e->writeInt32('FIELD_name12', 'FIELDName12', $this->FIELD_name12, false);
    $e->writeInt32('__field_name13', 'FieldName13', $this->__field_name13, false);
    $e->writeInt32('__Field_name14', 'FieldName14', $this->__Field_name14, false);
    $e->writeInt32('field__name15', 'fieldName15', $this->field__name15, false);
    $e->writeInt32('field__Name16', 'fieldName16', $this->field__Name16, false);
    $e->writeInt32('field_name17__', 'fieldName17', $this->field_name17__, false);
    $e->writeInt32('Field_name18__', 'FieldName18', $this->Field_name18__, false);
    $this->oneof_field->WriteJsonTo($e);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'optional_int32': case 'optionalInt32':
          $this->optional_int32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'optional_int64': case 'optionalInt64':
          $this->optional_int64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'optional_uint32': case 'optionalUint32':
          $this->optional_uint32 = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          break;
        case 'optional_uint64': case 'optionalUint64':
          $this->optional_uint64 = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'optional_sint32': case 'optionalSint32':
          $this->optional_sint32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'optional_sint64': case 'optionalSint64':
          $this->optional_sint64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'optional_fixed32': case 'optionalFixed32':
          $this->optional_fixed32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'optional_fixed64': case 'optionalFixed64':
          $this->optional_fixed64 = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'optional_sfixed32': case 'optionalSfixed32':
          $this->optional_sfixed32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'optional_sfixed64': case 'optionalSfixed64':
          $this->optional_sfixed64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'optional_float': case 'optionalFloat':
          $this->optional_float = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        case 'optional_double': case 'optionalDouble':
          $this->optional_double = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        case 'optional_bool': case 'optionalBool':
          $this->optional_bool = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'optional_string': case 'optionalString':
          $this->optional_string = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'optional_bytes': case 'optionalBytes':
          $this->optional_bytes = \Protobuf\Internal\JsonDecoder::readBytes($v);
          break;
        case 'optional_nested_message': case 'optionalNestedMessage':
          if ($v === null) break;
          if ($this->optional_nested_message == null) $this->optional_nested_message = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
          $this->optional_nested_message->MergeJsonFrom($v);
          break;
        case 'optional_foreign_message': case 'optionalForeignMessage':
          if ($v === null) break;
          if ($this->optional_foreign_message == null) $this->optional_foreign_message = new \protobuf_test_messages\proto2\ForeignMessageProto2();
          $this->optional_foreign_message->MergeJsonFrom($v);
          break;
        case 'optional_nested_enum': case 'optionalNestedEnum':
          $this->optional_nested_enum = \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($v);
          break;
        case 'optional_foreign_enum': case 'optionalForeignEnum':
          $this->optional_foreign_enum = \protobuf_test_messages\proto2\ForeignEnumProto2::FromMixed($v);
          break;
        case 'optional_string_piece': case 'optionalStringPiece':
          $this->optional_string_piece = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'optional_cord': case 'optionalCord':
          $this->optional_cord = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'recursive_message': case 'recursiveMessage':
          if ($v === null) break;
          if ($this->recursive_message == null) $this->recursive_message = new \protobuf_test_messages\proto2\TestAllTypesProto2();
          $this->recursive_message->MergeJsonFrom($v);
          break;
        case 'repeated_int32': case 'repeatedInt32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_int32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'repeated_int64': case 'repeatedInt64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_int64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'repeated_uint32': case 'repeatedUint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_uint32 []= \Protobuf\Internal\JsonDecoder::readInt32Unsigned($vv);
          }
          break;
        case 'repeated_uint64': case 'repeatedUint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_uint64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'repeated_sint32': case 'repeatedSint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_sint32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'repeated_sint64': case 'repeatedSint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_sint64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'repeated_fixed32': case 'repeatedFixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_fixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'repeated_fixed64': case 'repeatedFixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_fixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'repeated_sfixed32': case 'repeatedSfixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_sfixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'repeated_sfixed64': case 'repeatedSfixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_sfixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'repeated_float': case 'repeatedFloat':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_float []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'repeated_double': case 'repeatedDouble':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_double []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'repeated_bool': case 'repeatedBool':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_bool []= \Protobuf\Internal\JsonDecoder::readBool($vv);
          }
          break;
        case 'repeated_string': case 'repeatedString':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_string []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'repeated_bytes': case 'repeatedBytes':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_bytes []= \Protobuf\Internal\JsonDecoder::readBytes($vv);
          }
          break;
        case 'repeated_nested_message': case 'repeatedNestedMessage':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
            $obj->MergeJsonFrom($vv);
            $this->repeated_nested_message []= $obj;
          }
          break;
        case 'repeated_foreign_message': case 'repeatedForeignMessage':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \protobuf_test_messages\proto2\ForeignMessageProto2();
            $obj->MergeJsonFrom($vv);
            $this->repeated_foreign_message []= $obj;
          }
          break;
        case 'repeated_nested_enum': case 'repeatedNestedEnum':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($vv);
          }
          break;
        case 'repeated_foreign_enum': case 'repeatedForeignEnum':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_foreign_enum []= \protobuf_test_messages\proto2\ForeignEnumProto2::FromMixed($vv);
          }
          break;
        case 'repeated_string_piece': case 'repeatedStringPiece':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_string_piece []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'repeated_cord': case 'repeatedCord':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_cord []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'map_int32_int32': case 'mapInt32Int32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int32_int32[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
            }
          }
          break;
        case 'map_int64_int64': case 'mapInt64Int64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int64_int64[\Protobuf\Internal\JsonDecoder::readInt64Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
            }
          }
          break;
        case 'map_uint32_uint32': case 'mapUint32Uint32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_uint32_uint32[\Protobuf\Internal\JsonDecoder::readInt32Unsigned($k)] = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
            }
          }
          break;
        case 'map_uint64_uint64': case 'mapUint64Uint64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_uint64_uint64[\Protobuf\Internal\JsonDecoder::readInt64Unsigned($k)] = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
            }
          }
          break;
        case 'map_sint32_sint32': case 'mapSint32Sint32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_sint32_sint32[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
            }
          }
          break;
        case 'map_sint64_sint64': case 'mapSint64Sint64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_sint64_sint64[\Protobuf\Internal\JsonDecoder::readInt64Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
            }
          }
          break;
        case 'map_fixed32_fixed32': case 'mapFixed32Fixed32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_fixed32_fixed32[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
            }
          }
          break;
        case 'map_fixed64_fixed64': case 'mapFixed64Fixed64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_fixed64_fixed64[\Protobuf\Internal\JsonDecoder::readInt64Unsigned($k)] = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
            }
          }
          break;
        case 'map_sfixed32_sfixed32': case 'mapSfixed32Sfixed32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_sfixed32_sfixed32[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
            }
          }
          break;
        case 'map_sfixed64_sfixed64': case 'mapSfixed64Sfixed64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_sfixed64_sfixed64[\Protobuf\Internal\JsonDecoder::readInt64Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
            }
          }
          break;
        case 'map_int32_float': case 'mapInt32Float':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int32_float[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readFloat($v);
            }
          }
          break;
        case 'map_int32_double': case 'mapInt32Double':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int32_double[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readFloat($v);
            }
          }
          break;
        case 'map_bool_bool': case 'mapBoolBool':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_bool_bool[\Protobuf\Internal\JsonDecoder::readBoolMapKey($k)] = \Protobuf\Internal\JsonDecoder::readBool($v);
            }
          }
          break;
        case 'map_string_string': case 'mapStringString':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_string_string[\Protobuf\Internal\JsonDecoder::readString($k)] = \Protobuf\Internal\JsonDecoder::readString($v);
            }
          }
          break;
        case 'map_string_bytes': case 'mapStringBytes':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_string_bytes[\Protobuf\Internal\JsonDecoder::readString($k)] = \Protobuf\Internal\JsonDecoder::readBytes($v);
            }
          }
          break;
        case 'map_string_nested_message': case 'mapStringNestedMessage':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
              $obj->MergeJsonFrom($v);
              $this->map_string_nested_message[\Protobuf\Internal\JsonDecoder::readString($k)] = $obj;
            }
          }
          break;
        case 'map_string_foreign_message': case 'mapStringForeignMessage':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $obj = new \protobuf_test_messages\proto2\ForeignMessageProto2();
              $obj->MergeJsonFrom($v);
              $this->map_string_foreign_message[\Protobuf\Internal\JsonDecoder::readString($k)] = $obj;
            }
          }
          break;
        case 'map_string_nested_enum': case 'mapStringNestedEnum':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_string_nested_enum[\Protobuf\Internal\JsonDecoder::readString($k)] = \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($v);
            }
          }
          break;
        case 'map_string_foreign_enum': case 'mapStringForeignEnum':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_string_foreign_enum[\Protobuf\Internal\JsonDecoder::readString($k)] = \protobuf_test_messages\proto2\ForeignEnumProto2::FromMixed($v);
            }
          }
          break;
        case 'packed_int32': case 'packedInt32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_int32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'packed_int64': case 'packedInt64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_int64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'packed_uint32': case 'packedUint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_uint32 []= \Protobuf\Internal\JsonDecoder::readInt32Unsigned($vv);
          }
          break;
        case 'packed_uint64': case 'packedUint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_uint64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'packed_sint32': case 'packedSint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_sint32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'packed_sint64': case 'packedSint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_sint64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'packed_fixed32': case 'packedFixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_fixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'packed_fixed64': case 'packedFixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_fixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'packed_sfixed32': case 'packedSfixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_sfixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'packed_sfixed64': case 'packedSfixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_sfixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'packed_float': case 'packedFloat':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_float []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'packed_double': case 'packedDouble':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_double []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'packed_bool': case 'packedBool':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_bool []= \Protobuf\Internal\JsonDecoder::readBool($vv);
          }
          break;
        case 'packed_nested_enum': case 'packedNestedEnum':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($vv);
          }
          break;
        case 'unpacked_int32': case 'unpackedInt32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_int32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'unpacked_int64': case 'unpackedInt64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_int64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'unpacked_uint32': case 'unpackedUint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_uint32 []= \Protobuf\Internal\JsonDecoder::readInt32Unsigned($vv);
          }
          break;
        case 'unpacked_uint64': case 'unpackedUint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_uint64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'unpacked_sint32': case 'unpackedSint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_sint32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'unpacked_sint64': case 'unpackedSint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_sint64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'unpacked_fixed32': case 'unpackedFixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_fixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'unpacked_fixed64': case 'unpackedFixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_fixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'unpacked_sfixed32': case 'unpackedSfixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_sfixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'unpacked_sfixed64': case 'unpackedSfixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_sfixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'unpacked_float': case 'unpackedFloat':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_float []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'unpacked_double': case 'unpackedDouble':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_double []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'unpacked_bool': case 'unpackedBool':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_bool []= \Protobuf\Internal\JsonDecoder::readBool($vv);
          }
          break;
        case 'unpacked_nested_enum': case 'unpackedNestedEnum':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($vv);
          }
          break;
        case 'oneof_uint32': case 'oneofUint32':
          $this->oneof_field = new TestAllTypesProto2_oneof_uint32(\Protobuf\Internal\JsonDecoder::readInt32Unsigned($v));
          break;
        case 'oneof_nested_message': case 'oneofNestedMessage':
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
          $obj->MergeJsonFrom($v);
          $this->oneof_field = new TestAllTypesProto2_oneof_nested_message($obj);
          break;
        case 'oneof_string': case 'oneofString':
          $this->oneof_field = new TestAllTypesProto2_oneof_string(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'oneof_bytes': case 'oneofBytes':
          $this->oneof_field = new TestAllTypesProto2_oneof_bytes(\Protobuf\Internal\JsonDecoder::readBytes($v));
          break;
        case 'oneof_bool': case 'oneofBool':
          $this->oneof_field = new TestAllTypesProto2_oneof_bool(\Protobuf\Internal\JsonDecoder::readBool($v));
          break;
        case 'oneof_uint64': case 'oneofUint64':
          $this->oneof_field = new TestAllTypesProto2_oneof_uint64(\Protobuf\Internal\JsonDecoder::readInt64Unsigned($v));
          break;
        case 'oneof_float': case 'oneofFloat':
          $this->oneof_field = new TestAllTypesProto2_oneof_float(\Protobuf\Internal\JsonDecoder::readFloat($v));
          break;
        case 'oneof_double': case 'oneofDouble':
          $this->oneof_field = new TestAllTypesProto2_oneof_double(\Protobuf\Internal\JsonDecoder::readFloat($v));
          break;
        case 'oneof_enum': case 'oneofEnum':
          $this->oneof_field = new TestAllTypesProto2_oneof_enum(\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($v));
          break;
        case 'data':
          if ($v === null) break;
          if ($this->data == null) $this->data = new \protobuf_test_messages\proto2\TestAllTypesProto2_Data();
          $this->data->MergeJsonFrom($v);
          break;
        case 'fieldname1':
          $this->fieldname1 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field_name2': case 'fieldName2':
          $this->field_name2 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case '_field_name3': case 'FieldName3':
          $this->_field_name3 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field__name4_': case 'fieldName4':
          $this->field__name4_ = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field0name5':
          $this->field0name5 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field_0_name6': case 'field0Name6':
          $this->field_0_name6 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'fieldName7':
          $this->fieldName7 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'FieldName8':
          $this->FieldName8 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field_Name9': case 'fieldName9':
          $this->field_Name9 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'Field_Name10': case 'FieldName10':
          $this->Field_Name10 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'FIELD_NAME11': case 'FIELDNAME11':
          $this->FIELD_NAME11 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'FIELD_name12': case 'FIELDName12':
          $this->FIELD_name12 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case '__field_name13': case 'FieldName13':
          $this->__field_name13 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case '__Field_name14': case 'FieldName14':
          $this->__Field_name14 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field__name15': case 'fieldName15':
          $this->field__name15 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field__Name16': case 'fieldName16':
          $this->field__Name16 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field_name17__': case 'fieldName17':
          $this->field_name17__ = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'Field_name18__': case 'FieldName18':
          $this->Field_name18__ = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->optional_int32 = $o->optional_int32;
    $this->optional_int64 = $o->optional_int64;
    $this->optional_uint32 = $o->optional_uint32;
    $this->optional_uint64 = $o->optional_uint64;
    $this->optional_sint32 = $o->optional_sint32;
    $this->optional_sint64 = $o->optional_sint64;
    $this->optional_fixed32 = $o->optional_fixed32;
    $this->optional_fixed64 = $o->optional_fixed64;
    $this->optional_sfixed32 = $o->optional_sfixed32;
    $this->optional_sfixed64 = $o->optional_sfixed64;
    $this->optional_float = $o->optional_float;
    $this->optional_double = $o->optional_double;
    $this->optional_bool = $o->optional_bool;
    $this->optional_string = $o->optional_string;
    $this->optional_bytes = $o->optional_bytes;
    $tmp = $o->optional_nested_message;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
      $nv->CopyFrom($tmp);
      $this->optional_nested_message = $nv;
    }
    $tmp = $o->optional_foreign_message;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto2\ForeignMessageProto2();
      $nv->CopyFrom($tmp);
      $this->optional_foreign_message = $nv;
    }
    $this->optional_nested_enum = $o->optional_nested_enum;
    $this->optional_foreign_enum = $o->optional_foreign_enum;
    $this->optional_string_piece = $o->optional_string_piece;
    $this->optional_cord = $o->optional_cord;
    $tmp = $o->recursive_message;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2();
      $nv->CopyFrom($tmp);
      $this->recursive_message = $nv;
    }
    $this->repeated_int32 = $o->repeated_int32;
    $this->repeated_int64 = $o->repeated_int64;
    $this->repeated_uint32 = $o->repeated_uint32;
    $this->repeated_uint64 = $o->repeated_uint64;
    $this->repeated_sint32 = $o->repeated_sint32;
    $this->repeated_sint64 = $o->repeated_sint64;
    $this->repeated_fixed32 = $o->repeated_fixed32;
    $this->repeated_fixed64 = $o->repeated_fixed64;
    $this->repeated_sfixed32 = $o->repeated_sfixed32;
    $this->repeated_sfixed64 = $o->repeated_sfixed64;
    $this->repeated_float = $o->repeated_float;
    $this->repeated_double = $o->repeated_double;
    $this->repeated_bool = $o->repeated_bool;
    $this->repeated_string = $o->repeated_string;
    $this->repeated_bytes = $o->repeated_bytes;
    foreach ($o->repeated_nested_message as $v) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
      $nv->CopyFrom($v);
      $this->repeated_nested_message []= $nv;
    }
    foreach ($o->repeated_foreign_message as $v) {
      $nv = new \protobuf_test_messages\proto2\ForeignMessageProto2();
      $nv->CopyFrom($v);
      $this->repeated_foreign_message []= $nv;
    }
    $this->repeated_nested_enum = $o->repeated_nested_enum;
    $this->repeated_foreign_enum = $o->repeated_foreign_enum;
    $this->repeated_string_piece = $o->repeated_string_piece;
    $this->repeated_cord = $o->repeated_cord;
    $this->map_int32_int32 = $o->map_int32_int32;
    $this->map_int64_int64 = $o->map_int64_int64;
    $this->map_uint32_uint32 = $o->map_uint32_uint32;
    $this->map_uint64_uint64 = $o->map_uint64_uint64;
    $this->map_sint32_sint32 = $o->map_sint32_sint32;
    $this->map_sint64_sint64 = $o->map_sint64_sint64;
    $this->map_fixed32_fixed32 = $o->map_fixed32_fixed32;
    $this->map_fixed64_fixed64 = $o->map_fixed64_fixed64;
    $this->map_sfixed32_sfixed32 = $o->map_sfixed32_sfixed32;
    $this->map_sfixed64_sfixed64 = $o->map_sfixed64_sfixed64;
    $this->map_int32_float = $o->map_int32_float;
    $this->map_int32_double = $o->map_int32_double;
    $this->map_bool_bool = $o->map_bool_bool;
    $this->map_string_string = $o->map_string_string;
    $this->map_string_bytes = $o->map_string_bytes;
    foreach ($o->map_string_nested_message as $k => $v) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
      $nv->CopyFrom($v);
      $this->map_string_nested_message[$k] = $nv;
    }
    foreach ($o->map_string_foreign_message as $k => $v) {
      $nv = new \protobuf_test_messages\proto2\ForeignMessageProto2();
      $nv->CopyFrom($v);
      $this->map_string_foreign_message[$k] = $nv;
    }
    $this->map_string_nested_enum = $o->map_string_nested_enum;
    $this->map_string_foreign_enum = $o->map_string_foreign_enum;
    $this->packed_int32 = $o->packed_int32;
    $this->packed_int64 = $o->packed_int64;
    $this->packed_uint32 = $o->packed_uint32;
    $this->packed_uint64 = $o->packed_uint64;
    $this->packed_sint32 = $o->packed_sint32;
    $this->packed_sint64 = $o->packed_sint64;
    $this->packed_fixed32 = $o->packed_fixed32;
    $this->packed_fixed64 = $o->packed_fixed64;
    $this->packed_sfixed32 = $o->packed_sfixed32;
    $this->packed_sfixed64 = $o->packed_sfixed64;
    $this->packed_float = $o->packed_float;
    $this->packed_double = $o->packed_double;
    $this->packed_bool = $o->packed_bool;
    $this->packed_nested_enum = $o->packed_nested_enum;
    $this->unpacked_int32 = $o->unpacked_int32;
    $this->unpacked_int64 = $o->unpacked_int64;
    $this->unpacked_uint32 = $o->unpacked_uint32;
    $this->unpacked_uint64 = $o->unpacked_uint64;
    $this->unpacked_sint32 = $o->unpacked_sint32;
    $this->unpacked_sint64 = $o->unpacked_sint64;
    $this->unpacked_fixed32 = $o->unpacked_fixed32;
    $this->unpacked_fixed64 = $o->unpacked_fixed64;
    $this->unpacked_sfixed32 = $o->unpacked_sfixed32;
    $this->unpacked_sfixed64 = $o->unpacked_sfixed64;
    $this->unpacked_float = $o->unpacked_float;
    $this->unpacked_double = $o->unpacked_double;
    $this->unpacked_bool = $o->unpacked_bool;
    $this->unpacked_nested_enum = $o->unpacked_nested_enum;
    $tmp = $o->data;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_Data();
      $nv->CopyFrom($tmp);
      $this->data = $nv;
    }
    $this->fieldname1 = $o->fieldname1;
    $this->field_name2 = $o->field_name2;
    $this->_field_name3 = $o->_field_name3;
    $this->field__name4_ = $o->field__name4_;
    $this->field0name5 = $o->field0name5;
    $this->field_0_name6 = $o->field_0_name6;
    $this->fieldName7 = $o->fieldName7;
    $this->FieldName8 = $o->FieldName8;
    $this->field_Name9 = $o->field_Name9;
    $this->Field_Name10 = $o->Field_Name10;
    $this->FIELD_NAME11 = $o->FIELD_NAME11;
    $this->FIELD_name12 = $o->FIELD_name12;
    $this->__field_name13 = $o->__field_name13;
    $this->__Field_name14 = $o->__Field_name14;
    $this->field__name15 = $o->field__name15;
    $this->field__Name16 = $o->field__Name16;
    $this->field_name17__ = $o->field_name17__;
    $this->Field_name18__ = $o->Field_name18__;
    $this->oneof_field = $o->oneof_field->Copy();
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class ForeignMessageProto2 implements \Protobuf\Message {
  public int $c;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'c' => int,
  ) $s = shape()) {
    $this->c = $s['c'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.ForeignMessageProto2";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->c = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->c !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->c);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('c', 'c', $this->c, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'c':
          $this->c = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ForeignMessageProto2)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->c = $o->c;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class UnknownToTestAllTypes_OptionalGroup implements \Protobuf\Message {
  public int $a;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'a' => int,
  ) $s = shape()) {
    $this->a = $s['a'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.UnknownToTestAllTypes.OptionalGroup";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->a = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->a !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->a);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('a', 'a', $this->a, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'a':
          $this->a = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is UnknownToTestAllTypes_OptionalGroup)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->a = $o->a;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class UnknownToTestAllTypes implements \Protobuf\Message {
  public int $optional_int32;
  public string $optional_string;
  public ?\protobuf_test_messages\proto2\ForeignMessageProto2 $nested_message;
  public ?\protobuf_test_messages\proto2\UnknownToTestAllTypes_OptionalGroup $optionalgroup;
  public bool $optional_bool;
  public vec<int> $repeated_int32;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'optional_int32' => int,
    ?'optional_string' => string,
    ?'nested_message' => ?\protobuf_test_messages\proto2\ForeignMessageProto2,
    ?'optionalgroup' => ?\protobuf_test_messages\proto2\UnknownToTestAllTypes_OptionalGroup,
    ?'optional_bool' => bool,
    ?'repeated_int32' => vec<int>,
  ) $s = shape()) {
    $this->optional_int32 = $s['optional_int32'] ?? 0;
    $this->optional_string = $s['optional_string'] ?? '';
    $this->nested_message = $s['nested_message'] ?? null;
    $this->optionalgroup = $s['optionalgroup'] ?? null;
    $this->optional_bool = $s['optional_bool'] ?? false;
    $this->repeated_int32 = $s['repeated_int32'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.UnknownToTestAllTypes";
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1001:
          $this->optional_int32 = $d->readVarint32Signed();
          break;
        case 1002:
          $this->optional_string = $d->readString();
          break;
        case 1003:
          if ($this->nested_message == null) $this->nested_message = new \protobuf_test_messages\proto2\ForeignMessageProto2();
          $this->nested_message->MergeFrom($d->readDecoder());
          break;
        case 1004:
          if ($this->optionalgroup == null) $this->optionalgroup = new \protobuf_test_messages\proto2\UnknownToTestAllTypes_OptionalGroup();
          $this->optionalgroup->MergeFrom($d->readDecoder());
          break;
        case 1006:
          $this->optional_bool = $d->readBool();
          break;
        case 1011:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_int32 []= $packed->readVarint32Signed();
            }
          } else {
            $this->repeated_int32 []= $d->readVarint32Signed();
          }
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->optional_int32 !== 0) {
      $e->writeTag(1001, 0);
      $e->writeVarint($this->optional_int32);
    }
    if ($this->optional_string !== '') {
      $e->writeTag(1002, 2);
      $e->writeString($this->optional_string);
    }
    $msg = $this->nested_message;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1003);
    }
    $msg = $this->optionalgroup;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1004);
    }
    if ($this->optional_bool !== false) {
      $e->writeTag(1006, 0);
      $e->writeBool($this->optional_bool);
    }
    foreach ($this->repeated_int32 as $elem) {
      $e->writeTag(1011, 0);
      $e->writeVarint($elem);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('optional_int32', 'optionalInt32', $this->optional_int32, false);
    $e->writeString('optional_string', 'optionalString', $this->optional_string, false);
    $e->writeMessage('nested_message', 'nestedMessage', $this->nested_message, false);
    $e->writeMessage('optionalgroup', 'optionalgroup', $this->optionalgroup, false);
    $e->writeBool('optional_bool', 'optionalBool', $this->optional_bool, false);
    $e->writePrimitiveList('repeated_int32', 'repeatedInt32', $this->repeated_int32);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'optional_int32': case 'optionalInt32':
          $this->optional_int32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'optional_string': case 'optionalString':
          $this->optional_string = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'nested_message': case 'nestedMessage':
          if ($v === null) break;
          if ($this->nested_message == null) $this->nested_message = new \protobuf_test_messages\proto2\ForeignMessageProto2();
          $this->nested_message->MergeJsonFrom($v);
          break;
        case 'optionalgroup':
          if ($v === null) break;
          if ($this->optionalgroup == null) $this->optionalgroup = new \protobuf_test_messages\proto2\UnknownToTestAllTypes_OptionalGroup();
          $this->optionalgroup->MergeJsonFrom($v);
          break;
        case 'optional_bool': case 'optionalBool':
          $this->optional_bool = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'repeated_int32': case 'repeatedInt32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_int32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is UnknownToTestAllTypes)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->optional_int32 = $o->optional_int32;
    $this->optional_string = $o->optional_string;
    $tmp = $o->nested_message;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto2\ForeignMessageProto2();
      $nv->CopyFrom($tmp);
      $this->nested_message = $nv;
    }
    $tmp = $o->optionalgroup;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto2\UnknownToTestAllTypes_OptionalGroup();
      $nv->CopyFrom($tmp);
      $this->optionalgroup = $nv;
    }
    $this->optional_bool = $o->optional_bool;
    $this->repeated_int32 = $o->repeated_int32;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}


class XXX_FileDescriptor_google_protobuf_test_messages_proto2__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'google/protobuf/test_messages_proto2.proto';
  const string RAW =
  'eNq0WtlyG8cVRWNIAWwCJNgi5RYdl1vUNpJjigTHI0pxbIsiIWohpQylLHIsBAKHLJQADI'
  .'NFy0tclcpDKnlxnH1zll/IY34gSn4kW+UlD1kqVUr1Ot09IykEGFUJIO6cOefentsH3ZiB'
  .'Z3ejaLcZntvrRL3ofn/nXC/s9qqtsNut7YbdKguX59kbek2CqgaIHy3PfXwdottht3ep2b'
  .'z9ZC/s3mJhdBJORHu9RtSuNauNdm+pjAEB7mhQlNGrNGjDfA9nCXAdA+Z76DScVLA+p3MI'
  .'cIuBOvsOiyaAvodHCHBHTKDF2OWMowS4UzFwK8nY5YyHCHCRCfQ9dAaWFHCn8TjcXirjHA'
  .'FuLlAEFR5OQn0P5wlwD1lQ30NvwKlYXtKOEeBOBopjS8RTwL6HIQFuyQb7njH0O82o1sPj'
  .'BLjZeOgrNGjUvx317zdDXCDABXH9qyyKjkN1ZvV+FDVxkQA3HxRkcCWKmuZo9jqN9i6eIM'
  .'Ad00aTRY3s7j/phV08SYBbiLNboUH0CL6iYO2w2wu3ZYNiRIA7Xn53/oXtO59s3flNxrPB'
  .'gcGM5DfCqAVxPHpRJ2zstpXyYaa89BLlCj9LEHLt4IgafOMoasNpu86w3W/hGQLcifLbgx'
  .'a51u63AmRWSGNoG84kymOCR5jgwv9WG6UShR22CmMqvqbCu6G61wjrIca0J1ay+Wx8Hu+L'
  .'W/QwOq21Wj3qbOOjAg/idrscdbbRPTjVCev9TrfxMFSX51V2eRb3PWZBSXHJy3ISTnTCvb'
  .'BGrwc3kdeJQ11ORpXL6TDfw4Q41OU0GPckBRMud4w41OVkOHY5A+h7eI441OV0oMUoXO44'
  .'cajLyfBWklG43AniUJfTgdzlFFDa0UniUJeTcc3lTKjv4VPEoS5nQLnLxfKS9jRxqMupBD'
  .'SXs8C+h13iUJczwdzl4iSYy50hDnU5lYJ0OQUTLneWONTlZDh2OQVkLvcGcajLyaB0uThD'
  .'7nKfJg51OZWfcrmYjbncm8ShLqfopMspmOVyC8Q5EJeT/AmXi0fPcrlFpjyYy6nBT7icXS'
  .'cznSXiDO9yZoXS5RLlMUGPCQ7gclZh0uWsbhAu59Oe4C5n9oVyOXUec7nzAg/idmMudxIW'
  .'9mr1B8qDrlMPWsmWQDDO49KFNJjv4RvUgywY84yigAkP2qAexHDifOVCOtD38Cb1IBtoMA'
  .'oPukk9SAdu2YzCg25RD7KBzIUmBFCaxeeoBzGkoIhdyID6Hg6oByWgzIUmpbyk3aIexLCC'
  .'RXMhE+x7+Db1oCSYuZAceu5Bd6gH6UMvXUjWLzzo89SD9PqVC4nzuAd9gXoQg0EeZi7Uhk'
  .'iA9Ln0xeHnElMqcW5tNp2BE/220YhfEo2YCYryCG9FC+p7+K5oRhPKL4qCioZ8XzRkJlAs'
  .'oiVtsO/hL4umtMAWs2jMD0RjauCtJLNoznuiOS2w76E3YUmBZSdVRYNmAkUkWzQB9z38Fd'
  .'GkNtz30Dk4Faci6WuiUTOB4lKtmjzB9/B90ayJE/j0ihNiDVsXDatdHt6y+riIpt0WTauN'
  .'i2jb01CdzRs3FI2bCQryAGvdDpxWQL15dw6keTMBkuxa+zbhZKu2xztX9O8y+4pb3b/cRm'
  .'2PNTp7WWv3Ok+CYkuPaWq+J6bAheHUfI+9GGoihjpwiqrx+SOn0UWmVxlIj883/soVaTl6'
  .'VNf0PTkbPzOkpu/xV1NTRqUmn81yUr89hCaf/VtWnXpU1/Q96Q2fHVLT97asOvUoegwPU0'
  .'0xwZXHvMNU1wdSFWYk3rguLcyMG8q+p+zq3WGVfU+8Wcoqjr4GZ9g4y6KV9b3HtK8NNtaC'
  .'RL5zdVqifcTUp1da1n5paH3fk++2fnzE9CfuyivD+hPzcMufuK9HsBSrCWO/zOTWBpfjXw'
  .'Ncb6JlBNEOpBmwrwX+3bDK1FYGUqNfIvQ/lxpvxRE1XflCXOzO1oaZroyCv2rTVYvKwRSa'
  .'fKNXGWIwOS3bG8aDqQXRNwE8qilae8YrTHpjCGljl8hTONJKPYi+DeCsloq9i1xnuWwOkY'
  .'u5h+TJvNJKP4o+hEeS48KWFleHmcVa3XQtoc1i6wj6OoCvpAwHS+EaS+H68GMR5zDdSjmE'
  .'jsNC1A6jHbkSiAhwi+uZYJxFxfd3F05zkNU9ewfyu+p6JkCM3uwWlZmYmF8lwB1TmYnpdA'
  .'zyj2ImdQhwC+uZALIgnwCvQygg1Eq6BLj59UwwxhHUBowh8D3cI8AdMYbA92Ihbrd9Atys'
  .'EuI+qXiERz4kwAWKR3jbBzIbdpkfDf+braqFXc7rcGS71qvhp4AAF5b9/TOv1nq1gJHQkd'
  .'tphM3tdq0VLuLvOOyujRZCBI6zT1X6sYw/1hGbNISOwUI1hizh7wpIRUKW0BwscgSDeFX8'
  .'PZuGjT77tEAhb+Hvc4QeQ8clzQLj8fEPDBDl8VVF9NN5/ENb6DwFqNSW8Y/sbJfjkunHC/'
  .'jHNsUFNAcLFYVYXMA/EXkoksUFhrm6dmO1unlpY21xEf9UYmiQx2IMG+sy/pmBYTF0Ak5U'
  .'tfFdXMI/T6gtcVQlRnn4kwTKiweQg97Cv9AHkIG0UebV+fiXCZBP9bSczler+FcJ1HmK0n'
  .'JarlbxrxNZLc92YNG0hQIENXEDEdTQFhyvR+q3eHbHcKDf83WW2fcgSu7aUAk6D8InQpr+'
  .'iabh6MNas89lRwP+4WJ2GcQM+k5MZ3BSGBydYQVOp+2tdI5iCkcxncPYK+kcIykcI0mOxN'
  .'5H55hK4ZhK5zD2MjoHSuFAOscqPJK+M9FZciksueewmLsMneVQCsshnaUC8fP2CzrPZArP'
  .'5PN4rHW/zlNK4Smldpu+in9Zv2Z1hkvwcMrC/GUUQKd4B5bs1bZ+fj7l/HxKk9graJ1jLI'
  .'VjLFmGvSR+GUVBp/gWgK++YG2bwnVH5zqA+y9aMh/CT71obZuSzFUzmYFuyWgJfAPwFk1b'
  .'1KaoB7r6sHdptDSewKPPXdempFEx09j/vRtN+gYcoSsi+r2/24n6YhuMf8/nBGQx/jPeHC'
  .'xwhFhJ/4F7ND+NW/jsMTglxnor7F2OOp2w3jubz4+Unj179ix3MZsHs/+mDWhj1h73wna3'
  .'EbUXabndXoff5g7on+XfATgjaqp2w141lGB0eYD9gy2N//Xbe6yXNg6ALK4jONxSB1V09h'
  .'8vLL5Mv/wb7JGX0QA0yk//v4V/9Jv/gIOvvJxa+dwFCLWtYQ46lZs3Sxn6x8qloAT4H3dL'
  .'WXr9N9eusIZh/8DZ0fzj0lOwUlQ7FLp8unYo/8dc6aPNuRNwOm2W06Gsy3VUfe4TB87caT'
  .'9oR4/atyO9HnQq8fTWn3Jpj2+5ycd5/pxLfZ7nfThh7SP/khvcrYptY3nYiJ8HYRMP/zXH'
  .'dkIv+/Eotfj5m4LqCqUKTGZ0wn7K6W+5lMecTiWeC/l7LuXBkNnXYNFQMxe6ZytwKuFTaB'
  .'KOV24Ga1evbFZ5u2gB3jZG4G4pe/EunFTThOeD9r9cxo9ZWhOKiZWwcg669ag1zx8ofDHp'
  .'OvgnAP8NAAD//7nXCFQ';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    return (string)\gzuncompress(\base64_decode(self::RAW));
  }
}
