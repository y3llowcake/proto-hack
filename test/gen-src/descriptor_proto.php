<?hh // strict
namespace google\protobuf;

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: descriptor.proto

class FileDescriptorSet implements \Protobuf\Message {
  public vec<\google\protobuf\FileDescriptorProto> $file;

  public function __construct() {
    $this->file = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\FileDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->file []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->file as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('file', 'file', $this->file);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'file':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FileDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->file []= $obj;
          }
          break;
      }
    }
  }
}

class FileDescriptorProto implements \Protobuf\Message {
  public string $name;
  public string $package;
  public vec<string> $dependency;
  public vec<int> $public_dependency;
  public vec<int> $weak_dependency;
  public vec<\google\protobuf\DescriptorProto> $message_type;
  public vec<\google\protobuf\EnumDescriptorProto> $enum_type;
  public vec<\google\protobuf\ServiceDescriptorProto> $service;
  public vec<\google\protobuf\FieldDescriptorProto> $extension;
  public ?\google\protobuf\FileOptions $options;
  public ?\google\protobuf\SourceCodeInfo $source_code_info;
  public string $syntax;

  public function __construct() {
    $this->name = '';
    $this->package = '';
    $this->dependency = vec[];
    $this->public_dependency = vec[];
    $this->weak_dependency = vec[];
    $this->message_type = vec[];
    $this->enum_type = vec[];
    $this->service = vec[];
    $this->extension = vec[];
    $this->options = null;
    $this->source_code_info = null;
    $this->syntax = '';
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $this->package = $d->readString();
          break;
        case 3:
          $this->dependency []= $d->readString();
          break;
        case 4:
          $obj = new \google\protobuf\DescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->message_type []= $obj;
          break;
        case 5:
          $obj = new \google\protobuf\EnumDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->enum_type []= $obj;
          break;
        case 6:
          $obj = new \google\protobuf\ServiceDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->service []= $obj;
          break;
        case 7:
          $obj = new \google\protobuf\FieldDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->extension []= $obj;
          break;
        case 8:
          if ($this->options == null) $this->options = new \google\protobuf\FileOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 9:
          if ($this->source_code_info == null) $this->source_code_info = new \google\protobuf\SourceCodeInfo();
          $this->source_code_info->MergeFrom($d->readDecoder());
          break;
        case 10:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->public_dependency []= $packed->readVarint32Signed();
            }
          } else {
            $this->public_dependency []= $d->readVarint32Signed();
          }
          break;
        case 11:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->weak_dependency []= $packed->readVarint32Signed();
            }
          } else {
            $this->weak_dependency []= $d->readVarint32Signed();
          }
          break;
        case 12:
          $this->syntax = $d->readString();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->package !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->package);
    }
    foreach ($this->dependency as $elem) {
      $e->writeTag(3, 2);
      $e->writeString($elem);
    }
    foreach ($this->message_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    foreach ($this->enum_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 5);
    }
    foreach ($this->service as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 6);
    }
    foreach ($this->extension as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 7);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 8);
    }
    $msg = $this->source_code_info;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 9);
    }
    foreach ($this->public_dependency as $elem) {
      $e->writeTag(10, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->weak_dependency as $elem) {
      $e->writeTag(11, 0);
      $e->writeVarint($elem);
    }
    if ($this->syntax !== '') {
      $e->writeTag(12, 2);
      $e->writeString($this->syntax);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeString('package', 'package', $this->package, false);
    $e->writePrimitiveList('dependency', 'dependency', $this->dependency);
    $e->writeMessageList('message_type', 'messageType', $this->message_type);
    $e->writeMessageList('enum_type', 'enumType', $this->enum_type);
    $e->writeMessageList('service', 'service', $this->service);
    $e->writeMessageList('extension', 'extension', $this->extension);
    $e->writeMessage('options', 'options', $this->options, false);
    $e->writeMessage('source_code_info', 'sourceCodeInfo', $this->source_code_info, false);
    $e->writePrimitiveList('public_dependency', 'publicDependency', $this->public_dependency);
    $e->writePrimitiveList('weak_dependency', 'weakDependency', $this->weak_dependency);
    $e->writeString('syntax', 'syntax', $this->syntax, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'package':
          $this->package = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'dependency':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->dependency []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'message_type': case 'messageType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->message_type []= $obj;
          }
          break;
        case 'enum_type': case 'enumType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->enum_type []= $obj;
          }
          break;
        case 'service':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\ServiceDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->service []= $obj;
          }
          break;
        case 'extension':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->extension []= $obj;
          }
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\FileOptions();
          $this->options->MergeJsonFrom($v);
          break;
        case 'source_code_info': case 'sourceCodeInfo':
          if ($v === null) break;
          if ($this->source_code_info == null) $this->source_code_info = new \google\protobuf\SourceCodeInfo();
          $this->source_code_info->MergeJsonFrom($v);
          break;
        case 'public_dependency': case 'publicDependency':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->public_dependency []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'weak_dependency': case 'weakDependency':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->weak_dependency []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'syntax':
          $this->syntax = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
      }
    }
  }
}

class DescriptorProto_ExtensionRange implements \Protobuf\Message {
  public int $start;
  public int $end;
  public ?\google\protobuf\ExtensionRangeOptions $options;

  public function __construct() {
    $this->start = 0;
    $this->end = 0;
    $this->options = null;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->start = $d->readVarint32Signed();
          break;
        case 2:
          $this->end = $d->readVarint32Signed();
          break;
        case 3:
          if ($this->options == null) $this->options = new \google\protobuf\ExtensionRangeOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->start !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->start);
    }
    if ($this->end !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->end);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('start', 'start', $this->start, false);
    $e->writeInt32('end', 'end', $this->end, false);
    $e->writeMessage('options', 'options', $this->options, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'start':
          $this->start = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\ExtensionRangeOptions();
          $this->options->MergeJsonFrom($v);
          break;
      }
    }
  }
}

class DescriptorProto_ReservedRange implements \Protobuf\Message {
  public int $start;
  public int $end;

  public function __construct() {
    $this->start = 0;
    $this->end = 0;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->start = $d->readVarint32Signed();
          break;
        case 2:
          $this->end = $d->readVarint32Signed();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->start !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->start);
    }
    if ($this->end !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->end);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('start', 'start', $this->start, false);
    $e->writeInt32('end', 'end', $this->end, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'start':
          $this->start = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
      }
    }
  }
}

class DescriptorProto implements \Protobuf\Message {
  public string $name;
  public vec<\google\protobuf\FieldDescriptorProto> $field;
  public vec<\google\protobuf\FieldDescriptorProto> $extension;
  public vec<\google\protobuf\DescriptorProto> $nested_type;
  public vec<\google\protobuf\EnumDescriptorProto> $enum_type;
  public vec<\google\protobuf\DescriptorProto_ExtensionRange> $extension_range;
  public vec<\google\protobuf\OneofDescriptorProto> $oneof_decl;
  public ?\google\protobuf\MessageOptions $options;
  public vec<\google\protobuf\DescriptorProto_ReservedRange> $reserved_range;
  public vec<string> $reserved_name;

  public function __construct() {
    $this->name = '';
    $this->field = vec[];
    $this->extension = vec[];
    $this->nested_type = vec[];
    $this->enum_type = vec[];
    $this->extension_range = vec[];
    $this->oneof_decl = vec[];
    $this->options = null;
    $this->reserved_range = vec[];
    $this->reserved_name = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $obj = new \google\protobuf\FieldDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->field []= $obj;
          break;
        case 3:
          $obj = new \google\protobuf\DescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->nested_type []= $obj;
          break;
        case 4:
          $obj = new \google\protobuf\EnumDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->enum_type []= $obj;
          break;
        case 5:
          $obj = new \google\protobuf\DescriptorProto_ExtensionRange();
          $obj->MergeFrom($d->readDecoder());
          $this->extension_range []= $obj;
          break;
        case 6:
          $obj = new \google\protobuf\FieldDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->extension []= $obj;
          break;
        case 7:
          if ($this->options == null) $this->options = new \google\protobuf\MessageOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 8:
          $obj = new \google\protobuf\OneofDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->oneof_decl []= $obj;
          break;
        case 9:
          $obj = new \google\protobuf\DescriptorProto_ReservedRange();
          $obj->MergeFrom($d->readDecoder());
          $this->reserved_range []= $obj;
          break;
        case 10:
          $this->reserved_name []= $d->readString();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->field as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    foreach ($this->nested_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
    foreach ($this->enum_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    foreach ($this->extension_range as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 5);
    }
    foreach ($this->extension as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 6);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 7);
    }
    foreach ($this->oneof_decl as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 8);
    }
    foreach ($this->reserved_range as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 9);
    }
    foreach ($this->reserved_name as $elem) {
      $e->writeTag(10, 2);
      $e->writeString($elem);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeMessageList('field', 'field', $this->field);
    $e->writeMessageList('nested_type', 'nestedType', $this->nested_type);
    $e->writeMessageList('enum_type', 'enumType', $this->enum_type);
    $e->writeMessageList('extension_range', 'extensionRange', $this->extension_range);
    $e->writeMessageList('extension', 'extension', $this->extension);
    $e->writeMessage('options', 'options', $this->options, false);
    $e->writeMessageList('oneof_decl', 'oneofDecl', $this->oneof_decl);
    $e->writeMessageList('reserved_range', 'reservedRange', $this->reserved_range);
    $e->writePrimitiveList('reserved_name', 'reservedName', $this->reserved_name);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'field':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->field []= $obj;
          }
          break;
        case 'nested_type': case 'nestedType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->nested_type []= $obj;
          }
          break;
        case 'enum_type': case 'enumType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->enum_type []= $obj;
          }
          break;
        case 'extension_range': case 'extensionRange':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto_ExtensionRange();
            $obj->MergeJsonFrom($vv);
            $this->extension_range []= $obj;
          }
          break;
        case 'extension':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->extension []= $obj;
          }
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\MessageOptions();
          $this->options->MergeJsonFrom($v);
          break;
        case 'oneof_decl': case 'oneofDecl':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\OneofDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->oneof_decl []= $obj;
          }
          break;
        case 'reserved_range': case 'reservedRange':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto_ReservedRange();
            $obj->MergeJsonFrom($vv);
            $this->reserved_range []= $obj;
          }
          break;
        case 'reserved_name': case 'reservedName':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->reserved_name []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
      }
    }
  }
}

class ExtensionRangeOptions implements \Protobuf\Message {
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;

  public function __construct() {
    $this->uninterpreted_option = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
      }
    }
  }
}

newtype XXX_FieldDescriptorProto_Type_t as int = int;
abstract class FieldDescriptorProto_Type {
  const XXX_FieldDescriptorProto_Type_t TYPE_DOUBLE = 1;
  const XXX_FieldDescriptorProto_Type_t TYPE_FLOAT = 2;
  const XXX_FieldDescriptorProto_Type_t TYPE_INT64 = 3;
  const XXX_FieldDescriptorProto_Type_t TYPE_UINT64 = 4;
  const XXX_FieldDescriptorProto_Type_t TYPE_INT32 = 5;
  const XXX_FieldDescriptorProto_Type_t TYPE_FIXED64 = 6;
  const XXX_FieldDescriptorProto_Type_t TYPE_FIXED32 = 7;
  const XXX_FieldDescriptorProto_Type_t TYPE_BOOL = 8;
  const XXX_FieldDescriptorProto_Type_t TYPE_STRING = 9;
  const XXX_FieldDescriptorProto_Type_t TYPE_GROUP = 10;
  const XXX_FieldDescriptorProto_Type_t TYPE_MESSAGE = 11;
  const XXX_FieldDescriptorProto_Type_t TYPE_BYTES = 12;
  const XXX_FieldDescriptorProto_Type_t TYPE_UINT32 = 13;
  const XXX_FieldDescriptorProto_Type_t TYPE_ENUM = 14;
  const XXX_FieldDescriptorProto_Type_t TYPE_SFIXED32 = 15;
  const XXX_FieldDescriptorProto_Type_t TYPE_SFIXED64 = 16;
  const XXX_FieldDescriptorProto_Type_t TYPE_SINT32 = 17;
  const XXX_FieldDescriptorProto_Type_t TYPE_SINT64 = 18;
  private static dict<int, string> $XXX_itos = dict[
    1 => 'TYPE_DOUBLE',
    2 => 'TYPE_FLOAT',
    3 => 'TYPE_INT64',
    4 => 'TYPE_UINT64',
    5 => 'TYPE_INT32',
    6 => 'TYPE_FIXED64',
    7 => 'TYPE_FIXED32',
    8 => 'TYPE_BOOL',
    9 => 'TYPE_STRING',
    10 => 'TYPE_GROUP',
    11 => 'TYPE_MESSAGE',
    12 => 'TYPE_BYTES',
    13 => 'TYPE_UINT32',
    14 => 'TYPE_ENUM',
    15 => 'TYPE_SFIXED32',
    16 => 'TYPE_SFIXED64',
    17 => 'TYPE_SINT32',
    18 => 'TYPE_SINT64',
  ];
  public static function XXX_ItoS(): dict<int, string> {
    return self::$XXX_itos;
  }
  private static dict<string, int> $XXX_stoi = dict[
    'TYPE_DOUBLE' => 1,
    'TYPE_FLOAT' => 2,
    'TYPE_INT64' => 3,
    'TYPE_UINT64' => 4,
    'TYPE_INT32' => 5,
    'TYPE_FIXED64' => 6,
    'TYPE_FIXED32' => 7,
    'TYPE_BOOL' => 8,
    'TYPE_STRING' => 9,
    'TYPE_GROUP' => 10,
    'TYPE_MESSAGE' => 11,
    'TYPE_BYTES' => 12,
    'TYPE_UINT32' => 13,
    'TYPE_ENUM' => 14,
    'TYPE_SFIXED32' => 15,
    'TYPE_SFIXED64' => 16,
    'TYPE_SINT32' => 17,
    'TYPE_SINT64' => 18,
  ];
  public static function XXX_FromMixed(mixed $m): XXX_FieldDescriptorProto_Type_t {
    if ($m is string) return idx(self::$XXX_stoi, $m, is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function XXX_FromInt(int $i): XXX_FieldDescriptorProto_Type_t {
    return $i;
  }
}

newtype XXX_FieldDescriptorProto_Label_t as int = int;
abstract class FieldDescriptorProto_Label {
  const XXX_FieldDescriptorProto_Label_t LABEL_OPTIONAL = 1;
  const XXX_FieldDescriptorProto_Label_t LABEL_REQUIRED = 2;
  const XXX_FieldDescriptorProto_Label_t LABEL_REPEATED = 3;
  private static dict<int, string> $XXX_itos = dict[
    1 => 'LABEL_OPTIONAL',
    2 => 'LABEL_REQUIRED',
    3 => 'LABEL_REPEATED',
  ];
  public static function XXX_ItoS(): dict<int, string> {
    return self::$XXX_itos;
  }
  private static dict<string, int> $XXX_stoi = dict[
    'LABEL_OPTIONAL' => 1,
    'LABEL_REQUIRED' => 2,
    'LABEL_REPEATED' => 3,
  ];
  public static function XXX_FromMixed(mixed $m): XXX_FieldDescriptorProto_Label_t {
    if ($m is string) return idx(self::$XXX_stoi, $m, is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function XXX_FromInt(int $i): XXX_FieldDescriptorProto_Label_t {
    return $i;
  }
}

class FieldDescriptorProto implements \Protobuf\Message {
  public string $name;
  public int $number;
  public \google\protobuf\XXX_FieldDescriptorProto_Label_t $label;
  public \google\protobuf\XXX_FieldDescriptorProto_Type_t $type;
  public string $type_name;
  public string $extendee;
  public string $default_value;
  public int $oneof_index;
  public string $json_name;
  public ?\google\protobuf\FieldOptions $options;

  public function __construct() {
    $this->name = '';
    $this->number = 0;
    $this->label = \google\protobuf\FieldDescriptorProto_Label::XXX_FromInt(0);
    $this->type = \google\protobuf\FieldDescriptorProto_Type::XXX_FromInt(0);
    $this->type_name = '';
    $this->extendee = '';
    $this->default_value = '';
    $this->oneof_index = 0;
    $this->json_name = '';
    $this->options = null;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $this->extendee = $d->readString();
          break;
        case 3:
          $this->number = $d->readVarint32Signed();
          break;
        case 4:
          $this->label = \google\protobuf\FieldDescriptorProto_Label::XXX_FromInt($d->readVarint());
          break;
        case 5:
          $this->type = \google\protobuf\FieldDescriptorProto_Type::XXX_FromInt($d->readVarint());
          break;
        case 6:
          $this->type_name = $d->readString();
          break;
        case 7:
          $this->default_value = $d->readString();
          break;
        case 8:
          if ($this->options == null) $this->options = new \google\protobuf\FieldOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 9:
          $this->oneof_index = $d->readVarint32Signed();
          break;
        case 10:
          $this->json_name = $d->readString();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->extendee !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->extendee);
    }
    if ($this->number !== 0) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->number);
    }
    if ($this->label !== \google\protobuf\FieldDescriptorProto_Label::XXX_FromInt(0)) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->label);
    }
    if ($this->type !== \google\protobuf\FieldDescriptorProto_Type::XXX_FromInt(0)) {
      $e->writeTag(5, 0);
      $e->writeVarint($this->type);
    }
    if ($this->type_name !== '') {
      $e->writeTag(6, 2);
      $e->writeString($this->type_name);
    }
    if ($this->default_value !== '') {
      $e->writeTag(7, 2);
      $e->writeString($this->default_value);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 8);
    }
    if ($this->oneof_index !== 0) {
      $e->writeTag(9, 0);
      $e->writeVarint($this->oneof_index);
    }
    if ($this->json_name !== '') {
      $e->writeTag(10, 2);
      $e->writeString($this->json_name);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeString('extendee', 'extendee', $this->extendee, false);
    $e->writeInt32('number', 'number', $this->number, false);
    $e->writeEnum('label', 'label', \google\protobuf\FieldDescriptorProto_Label::XXX_ItoS(), $this->label, false);
    $e->writeEnum('type', 'type', \google\protobuf\FieldDescriptorProto_Type::XXX_ItoS(), $this->type, false);
    $e->writeString('type_name', 'typeName', $this->type_name, false);
    $e->writeString('default_value', 'defaultValue', $this->default_value, false);
    $e->writeMessage('options', 'options', $this->options, false);
    $e->writeInt32('oneof_index', 'oneofIndex', $this->oneof_index, false);
    $e->writeString('json_name', 'jsonName', $this->json_name, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'extendee':
          $this->extendee = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'number':
          $this->number = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'label':
          $this->label = \google\protobuf\FieldDescriptorProto_Label::XXX_FromMixed($v);
          break;
        case 'type':
          $this->type = \google\protobuf\FieldDescriptorProto_Type::XXX_FromMixed($v);
          break;
        case 'type_name': case 'typeName':
          $this->type_name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'default_value': case 'defaultValue':
          $this->default_value = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\FieldOptions();
          $this->options->MergeJsonFrom($v);
          break;
        case 'oneof_index': case 'oneofIndex':
          $this->oneof_index = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'json_name': case 'jsonName':
          $this->json_name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
      }
    }
  }
}

class OneofDescriptorProto implements \Protobuf\Message {
  public string $name;
  public ?\google\protobuf\OneofOptions $options;

  public function __construct() {
    $this->name = '';
    $this->options = null;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          if ($this->options == null) $this->options = new \google\protobuf\OneofOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeMessage('options', 'options', $this->options, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\OneofOptions();
          $this->options->MergeJsonFrom($v);
          break;
      }
    }
  }
}

class EnumDescriptorProto_EnumReservedRange implements \Protobuf\Message {
  public int $start;
  public int $end;

  public function __construct() {
    $this->start = 0;
    $this->end = 0;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->start = $d->readVarint32Signed();
          break;
        case 2:
          $this->end = $d->readVarint32Signed();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->start !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->start);
    }
    if ($this->end !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->end);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('start', 'start', $this->start, false);
    $e->writeInt32('end', 'end', $this->end, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'start':
          $this->start = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
      }
    }
  }
}

class EnumDescriptorProto implements \Protobuf\Message {
  public string $name;
  public vec<\google\protobuf\EnumValueDescriptorProto> $value;
  public ?\google\protobuf\EnumOptions $options;
  public vec<\google\protobuf\EnumDescriptorProto_EnumReservedRange> $reserved_range;
  public vec<string> $reserved_name;

  public function __construct() {
    $this->name = '';
    $this->value = vec[];
    $this->options = null;
    $this->reserved_range = vec[];
    $this->reserved_name = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $obj = new \google\protobuf\EnumValueDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->value []= $obj;
          break;
        case 3:
          if ($this->options == null) $this->options = new \google\protobuf\EnumOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 4:
          $obj = new \google\protobuf\EnumDescriptorProto_EnumReservedRange();
          $obj->MergeFrom($d->readDecoder());
          $this->reserved_range []= $obj;
          break;
        case 5:
          $this->reserved_name []= $d->readString();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->value as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
    foreach ($this->reserved_range as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    foreach ($this->reserved_name as $elem) {
      $e->writeTag(5, 2);
      $e->writeString($elem);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeMessageList('value', 'value', $this->value);
    $e->writeMessage('options', 'options', $this->options, false);
    $e->writeMessageList('reserved_range', 'reservedRange', $this->reserved_range);
    $e->writePrimitiveList('reserved_name', 'reservedName', $this->reserved_name);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumValueDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->value []= $obj;
          }
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\EnumOptions();
          $this->options->MergeJsonFrom($v);
          break;
        case 'reserved_range': case 'reservedRange':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumDescriptorProto_EnumReservedRange();
            $obj->MergeJsonFrom($vv);
            $this->reserved_range []= $obj;
          }
          break;
        case 'reserved_name': case 'reservedName':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->reserved_name []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
      }
    }
  }
}

class EnumValueDescriptorProto implements \Protobuf\Message {
  public string $name;
  public int $number;
  public ?\google\protobuf\EnumValueOptions $options;

  public function __construct() {
    $this->name = '';
    $this->number = 0;
    $this->options = null;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $this->number = $d->readVarint32Signed();
          break;
        case 3:
          if ($this->options == null) $this->options = new \google\protobuf\EnumValueOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->number !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->number);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeInt32('number', 'number', $this->number, false);
    $e->writeMessage('options', 'options', $this->options, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'number':
          $this->number = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\EnumValueOptions();
          $this->options->MergeJsonFrom($v);
          break;
      }
    }
  }
}

class ServiceDescriptorProto implements \Protobuf\Message {
  public string $name;
  public vec<\google\protobuf\MethodDescriptorProto> $method;
  public ?\google\protobuf\ServiceOptions $options;

  public function __construct() {
    $this->name = '';
    $this->method = vec[];
    $this->options = null;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $obj = new \google\protobuf\MethodDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->method []= $obj;
          break;
        case 3:
          if ($this->options == null) $this->options = new \google\protobuf\ServiceOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->method as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeMessageList('method', 'method', $this->method);
    $e->writeMessage('options', 'options', $this->options, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'method':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\MethodDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->method []= $obj;
          }
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\ServiceOptions();
          $this->options->MergeJsonFrom($v);
          break;
      }
    }
  }
}

class MethodDescriptorProto implements \Protobuf\Message {
  public string $name;
  public string $input_type;
  public string $output_type;
  public ?\google\protobuf\MethodOptions $options;
  public bool $client_streaming;
  public bool $server_streaming;

  public function __construct() {
    $this->name = '';
    $this->input_type = '';
    $this->output_type = '';
    $this->options = null;
    $this->client_streaming = false;
    $this->server_streaming = false;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $this->input_type = $d->readString();
          break;
        case 3:
          $this->output_type = $d->readString();
          break;
        case 4:
          if ($this->options == null) $this->options = new \google\protobuf\MethodOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 5:
          $this->client_streaming = $d->readBool();
          break;
        case 6:
          $this->server_streaming = $d->readBool();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->input_type !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->input_type);
    }
    if ($this->output_type !== '') {
      $e->writeTag(3, 2);
      $e->writeString($this->output_type);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    if ($this->client_streaming !== false) {
      $e->writeTag(5, 0);
      $e->writeBool($this->client_streaming);
    }
    if ($this->server_streaming !== false) {
      $e->writeTag(6, 0);
      $e->writeBool($this->server_streaming);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeString('input_type', 'inputType', $this->input_type, false);
    $e->writeString('output_type', 'outputType', $this->output_type, false);
    $e->writeMessage('options', 'options', $this->options, false);
    $e->writeBool('client_streaming', 'clientStreaming', $this->client_streaming, false);
    $e->writeBool('server_streaming', 'serverStreaming', $this->server_streaming, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'input_type': case 'inputType':
          $this->input_type = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'output_type': case 'outputType':
          $this->output_type = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\MethodOptions();
          $this->options->MergeJsonFrom($v);
          break;
        case 'client_streaming': case 'clientStreaming':
          $this->client_streaming = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'server_streaming': case 'serverStreaming':
          $this->server_streaming = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
      }
    }
  }
}

newtype XXX_FileOptions_OptimizeMode_t as int = int;
abstract class FileOptions_OptimizeMode {
  const XXX_FileOptions_OptimizeMode_t SPEED = 1;
  const XXX_FileOptions_OptimizeMode_t CODE_SIZE = 2;
  const XXX_FileOptions_OptimizeMode_t LITE_RUNTIME = 3;
  private static dict<int, string> $XXX_itos = dict[
    1 => 'SPEED',
    2 => 'CODE_SIZE',
    3 => 'LITE_RUNTIME',
  ];
  public static function XXX_ItoS(): dict<int, string> {
    return self::$XXX_itos;
  }
  private static dict<string, int> $XXX_stoi = dict[
    'SPEED' => 1,
    'CODE_SIZE' => 2,
    'LITE_RUNTIME' => 3,
  ];
  public static function XXX_FromMixed(mixed $m): XXX_FileOptions_OptimizeMode_t {
    if ($m is string) return idx(self::$XXX_stoi, $m, is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function XXX_FromInt(int $i): XXX_FileOptions_OptimizeMode_t {
    return $i;
  }
}

class FileOptions implements \Protobuf\Message {
  public string $java_package;
  public string $java_outer_classname;
  public bool $java_multiple_files;
  public bool $java_generate_equals_and_hash;
  public bool $java_string_check_utf8;
  public \google\protobuf\XXX_FileOptions_OptimizeMode_t $optimize_for;
  public string $go_package;
  public bool $cc_generic_services;
  public bool $java_generic_services;
  public bool $py_generic_services;
  public bool $php_generic_services;
  public bool $deprecated;
  public bool $cc_enable_arenas;
  public string $objc_class_prefix;
  public string $csharp_namespace;
  public string $swift_prefix;
  public string $php_class_prefix;
  public string $php_namespace;
  public string $php_metadata_namespace;
  public string $ruby_package;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;

  public function __construct() {
    $this->java_package = '';
    $this->java_outer_classname = '';
    $this->java_multiple_files = false;
    $this->java_generate_equals_and_hash = false;
    $this->java_string_check_utf8 = false;
    $this->optimize_for = \google\protobuf\FileOptions_OptimizeMode::XXX_FromInt(0);
    $this->go_package = '';
    $this->cc_generic_services = false;
    $this->java_generic_services = false;
    $this->py_generic_services = false;
    $this->php_generic_services = false;
    $this->deprecated = false;
    $this->cc_enable_arenas = false;
    $this->objc_class_prefix = '';
    $this->csharp_namespace = '';
    $this->swift_prefix = '';
    $this->php_class_prefix = '';
    $this->php_namespace = '';
    $this->php_metadata_namespace = '';
    $this->ruby_package = '';
    $this->uninterpreted_option = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->java_package = $d->readString();
          break;
        case 8:
          $this->java_outer_classname = $d->readString();
          break;
        case 9:
          $this->optimize_for = \google\protobuf\FileOptions_OptimizeMode::XXX_FromInt($d->readVarint());
          break;
        case 10:
          $this->java_multiple_files = $d->readBool();
          break;
        case 11:
          $this->go_package = $d->readString();
          break;
        case 16:
          $this->cc_generic_services = $d->readBool();
          break;
        case 17:
          $this->java_generic_services = $d->readBool();
          break;
        case 18:
          $this->py_generic_services = $d->readBool();
          break;
        case 20:
          $this->java_generate_equals_and_hash = $d->readBool();
          break;
        case 23:
          $this->deprecated = $d->readBool();
          break;
        case 27:
          $this->java_string_check_utf8 = $d->readBool();
          break;
        case 31:
          $this->cc_enable_arenas = $d->readBool();
          break;
        case 36:
          $this->objc_class_prefix = $d->readString();
          break;
        case 37:
          $this->csharp_namespace = $d->readString();
          break;
        case 39:
          $this->swift_prefix = $d->readString();
          break;
        case 40:
          $this->php_class_prefix = $d->readString();
          break;
        case 41:
          $this->php_namespace = $d->readString();
          break;
        case 42:
          $this->php_generic_services = $d->readBool();
          break;
        case 44:
          $this->php_metadata_namespace = $d->readString();
          break;
        case 45:
          $this->ruby_package = $d->readString();
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->java_package !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->java_package);
    }
    if ($this->java_outer_classname !== '') {
      $e->writeTag(8, 2);
      $e->writeString($this->java_outer_classname);
    }
    if ($this->optimize_for !== \google\protobuf\FileOptions_OptimizeMode::XXX_FromInt(0)) {
      $e->writeTag(9, 0);
      $e->writeVarint($this->optimize_for);
    }
    if ($this->java_multiple_files !== false) {
      $e->writeTag(10, 0);
      $e->writeBool($this->java_multiple_files);
    }
    if ($this->go_package !== '') {
      $e->writeTag(11, 2);
      $e->writeString($this->go_package);
    }
    if ($this->cc_generic_services !== false) {
      $e->writeTag(16, 0);
      $e->writeBool($this->cc_generic_services);
    }
    if ($this->java_generic_services !== false) {
      $e->writeTag(17, 0);
      $e->writeBool($this->java_generic_services);
    }
    if ($this->py_generic_services !== false) {
      $e->writeTag(18, 0);
      $e->writeBool($this->py_generic_services);
    }
    if ($this->java_generate_equals_and_hash !== false) {
      $e->writeTag(20, 0);
      $e->writeBool($this->java_generate_equals_and_hash);
    }
    if ($this->deprecated !== false) {
      $e->writeTag(23, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->java_string_check_utf8 !== false) {
      $e->writeTag(27, 0);
      $e->writeBool($this->java_string_check_utf8);
    }
    if ($this->cc_enable_arenas !== false) {
      $e->writeTag(31, 0);
      $e->writeBool($this->cc_enable_arenas);
    }
    if ($this->objc_class_prefix !== '') {
      $e->writeTag(36, 2);
      $e->writeString($this->objc_class_prefix);
    }
    if ($this->csharp_namespace !== '') {
      $e->writeTag(37, 2);
      $e->writeString($this->csharp_namespace);
    }
    if ($this->swift_prefix !== '') {
      $e->writeTag(39, 2);
      $e->writeString($this->swift_prefix);
    }
    if ($this->php_class_prefix !== '') {
      $e->writeTag(40, 2);
      $e->writeString($this->php_class_prefix);
    }
    if ($this->php_namespace !== '') {
      $e->writeTag(41, 2);
      $e->writeString($this->php_namespace);
    }
    if ($this->php_generic_services !== false) {
      $e->writeTag(42, 0);
      $e->writeBool($this->php_generic_services);
    }
    if ($this->php_metadata_namespace !== '') {
      $e->writeTag(44, 2);
      $e->writeString($this->php_metadata_namespace);
    }
    if ($this->ruby_package !== '') {
      $e->writeTag(45, 2);
      $e->writeString($this->ruby_package);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('java_package', 'javaPackage', $this->java_package, false);
    $e->writeString('java_outer_classname', 'javaOuterClassname', $this->java_outer_classname, false);
    $e->writeEnum('optimize_for', 'optimizeFor', \google\protobuf\FileOptions_OptimizeMode::XXX_ItoS(), $this->optimize_for, false);
    $e->writeBool('java_multiple_files', 'javaMultipleFiles', $this->java_multiple_files, false);
    $e->writeString('go_package', 'goPackage', $this->go_package, false);
    $e->writeBool('cc_generic_services', 'ccGenericServices', $this->cc_generic_services, false);
    $e->writeBool('java_generic_services', 'javaGenericServices', $this->java_generic_services, false);
    $e->writeBool('py_generic_services', 'pyGenericServices', $this->py_generic_services, false);
    $e->writeBool('java_generate_equals_and_hash', 'javaGenerateEqualsAndHash', $this->java_generate_equals_and_hash, false);
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeBool('java_string_check_utf8', 'javaStringCheckUtf8', $this->java_string_check_utf8, false);
    $e->writeBool('cc_enable_arenas', 'ccEnableArenas', $this->cc_enable_arenas, false);
    $e->writeString('objc_class_prefix', 'objcClassPrefix', $this->objc_class_prefix, false);
    $e->writeString('csharp_namespace', 'csharpNamespace', $this->csharp_namespace, false);
    $e->writeString('swift_prefix', 'swiftPrefix', $this->swift_prefix, false);
    $e->writeString('php_class_prefix', 'phpClassPrefix', $this->php_class_prefix, false);
    $e->writeString('php_namespace', 'phpNamespace', $this->php_namespace, false);
    $e->writeBool('php_generic_services', 'phpGenericServices', $this->php_generic_services, false);
    $e->writeString('php_metadata_namespace', 'phpMetadataNamespace', $this->php_metadata_namespace, false);
    $e->writeString('ruby_package', 'rubyPackage', $this->ruby_package, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'java_package': case 'javaPackage':
          $this->java_package = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'java_outer_classname': case 'javaOuterClassname':
          $this->java_outer_classname = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'optimize_for': case 'optimizeFor':
          $this->optimize_for = \google\protobuf\FileOptions_OptimizeMode::XXX_FromMixed($v);
          break;
        case 'java_multiple_files': case 'javaMultipleFiles':
          $this->java_multiple_files = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'go_package': case 'goPackage':
          $this->go_package = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'cc_generic_services': case 'ccGenericServices':
          $this->cc_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'java_generic_services': case 'javaGenericServices':
          $this->java_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'py_generic_services': case 'pyGenericServices':
          $this->py_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'java_generate_equals_and_hash': case 'javaGenerateEqualsAndHash':
          $this->java_generate_equals_and_hash = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'java_string_check_utf8': case 'javaStringCheckUtf8':
          $this->java_string_check_utf8 = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'cc_enable_arenas': case 'ccEnableArenas':
          $this->cc_enable_arenas = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'objc_class_prefix': case 'objcClassPrefix':
          $this->objc_class_prefix = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'csharp_namespace': case 'csharpNamespace':
          $this->csharp_namespace = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'swift_prefix': case 'swiftPrefix':
          $this->swift_prefix = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'php_class_prefix': case 'phpClassPrefix':
          $this->php_class_prefix = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'php_namespace': case 'phpNamespace':
          $this->php_namespace = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'php_generic_services': case 'phpGenericServices':
          $this->php_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'php_metadata_namespace': case 'phpMetadataNamespace':
          $this->php_metadata_namespace = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'ruby_package': case 'rubyPackage':
          $this->ruby_package = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
      }
    }
  }
}

class MessageOptions implements \Protobuf\Message {
  public bool $message_set_wire_format;
  public bool $no_standard_descriptor_accessor;
  public bool $deprecated;
  public bool $map_entry;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;

  public function __construct() {
    $this->message_set_wire_format = false;
    $this->no_standard_descriptor_accessor = false;
    $this->deprecated = false;
    $this->map_entry = false;
    $this->uninterpreted_option = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->message_set_wire_format = $d->readBool();
          break;
        case 2:
          $this->no_standard_descriptor_accessor = $d->readBool();
          break;
        case 3:
          $this->deprecated = $d->readBool();
          break;
        case 7:
          $this->map_entry = $d->readBool();
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->message_set_wire_format !== false) {
      $e->writeTag(1, 0);
      $e->writeBool($this->message_set_wire_format);
    }
    if ($this->no_standard_descriptor_accessor !== false) {
      $e->writeTag(2, 0);
      $e->writeBool($this->no_standard_descriptor_accessor);
    }
    if ($this->deprecated !== false) {
      $e->writeTag(3, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->map_entry !== false) {
      $e->writeTag(7, 0);
      $e->writeBool($this->map_entry);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('message_set_wire_format', 'messageSetWireFormat', $this->message_set_wire_format, false);
    $e->writeBool('no_standard_descriptor_accessor', 'noStandardDescriptorAccessor', $this->no_standard_descriptor_accessor, false);
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeBool('map_entry', 'mapEntry', $this->map_entry, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'message_set_wire_format': case 'messageSetWireFormat':
          $this->message_set_wire_format = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'no_standard_descriptor_accessor': case 'noStandardDescriptorAccessor':
          $this->no_standard_descriptor_accessor = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'map_entry': case 'mapEntry':
          $this->map_entry = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
      }
    }
  }
}

newtype XXX_FieldOptions_CType_t as int = int;
abstract class FieldOptions_CType {
  const XXX_FieldOptions_CType_t STRING = 0;
  const XXX_FieldOptions_CType_t CORD = 1;
  const XXX_FieldOptions_CType_t STRING_PIECE = 2;
  private static dict<int, string> $XXX_itos = dict[
    0 => 'STRING',
    1 => 'CORD',
    2 => 'STRING_PIECE',
  ];
  public static function XXX_ItoS(): dict<int, string> {
    return self::$XXX_itos;
  }
  private static dict<string, int> $XXX_stoi = dict[
    'STRING' => 0,
    'CORD' => 1,
    'STRING_PIECE' => 2,
  ];
  public static function XXX_FromMixed(mixed $m): XXX_FieldOptions_CType_t {
    if ($m is string) return idx(self::$XXX_stoi, $m, is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function XXX_FromInt(int $i): XXX_FieldOptions_CType_t {
    return $i;
  }
}

newtype XXX_FieldOptions_JSType_t as int = int;
abstract class FieldOptions_JSType {
  const XXX_FieldOptions_JSType_t JS_NORMAL = 0;
  const XXX_FieldOptions_JSType_t JS_STRING = 1;
  const XXX_FieldOptions_JSType_t JS_NUMBER = 2;
  private static dict<int, string> $XXX_itos = dict[
    0 => 'JS_NORMAL',
    1 => 'JS_STRING',
    2 => 'JS_NUMBER',
  ];
  public static function XXX_ItoS(): dict<int, string> {
    return self::$XXX_itos;
  }
  private static dict<string, int> $XXX_stoi = dict[
    'JS_NORMAL' => 0,
    'JS_STRING' => 1,
    'JS_NUMBER' => 2,
  ];
  public static function XXX_FromMixed(mixed $m): XXX_FieldOptions_JSType_t {
    if ($m is string) return idx(self::$XXX_stoi, $m, is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function XXX_FromInt(int $i): XXX_FieldOptions_JSType_t {
    return $i;
  }
}

class FieldOptions implements \Protobuf\Message {
  public \google\protobuf\XXX_FieldOptions_CType_t $ctype;
  public bool $packed;
  public \google\protobuf\XXX_FieldOptions_JSType_t $jstype;
  public bool $lazy;
  public bool $deprecated;
  public bool $weak;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;

  public function __construct() {
    $this->ctype = \google\protobuf\FieldOptions_CType::XXX_FromInt(0);
    $this->packed = false;
    $this->jstype = \google\protobuf\FieldOptions_JSType::XXX_FromInt(0);
    $this->lazy = false;
    $this->deprecated = false;
    $this->weak = false;
    $this->uninterpreted_option = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->ctype = \google\protobuf\FieldOptions_CType::XXX_FromInt($d->readVarint());
          break;
        case 2:
          $this->packed = $d->readBool();
          break;
        case 3:
          $this->deprecated = $d->readBool();
          break;
        case 5:
          $this->lazy = $d->readBool();
          break;
        case 6:
          $this->jstype = \google\protobuf\FieldOptions_JSType::XXX_FromInt($d->readVarint());
          break;
        case 10:
          $this->weak = $d->readBool();
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->ctype !== \google\protobuf\FieldOptions_CType::XXX_FromInt(0)) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->ctype);
    }
    if ($this->packed !== false) {
      $e->writeTag(2, 0);
      $e->writeBool($this->packed);
    }
    if ($this->deprecated !== false) {
      $e->writeTag(3, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->lazy !== false) {
      $e->writeTag(5, 0);
      $e->writeBool($this->lazy);
    }
    if ($this->jstype !== \google\protobuf\FieldOptions_JSType::XXX_FromInt(0)) {
      $e->writeTag(6, 0);
      $e->writeVarint($this->jstype);
    }
    if ($this->weak !== false) {
      $e->writeTag(10, 0);
      $e->writeBool($this->weak);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeEnum('ctype', 'ctype', \google\protobuf\FieldOptions_CType::XXX_ItoS(), $this->ctype, false);
    $e->writeBool('packed', 'packed', $this->packed, false);
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeBool('lazy', 'lazy', $this->lazy, false);
    $e->writeEnum('jstype', 'jstype', \google\protobuf\FieldOptions_JSType::XXX_ItoS(), $this->jstype, false);
    $e->writeBool('weak', 'weak', $this->weak, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'ctype':
          $this->ctype = \google\protobuf\FieldOptions_CType::XXX_FromMixed($v);
          break;
        case 'packed':
          $this->packed = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'lazy':
          $this->lazy = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'jstype':
          $this->jstype = \google\protobuf\FieldOptions_JSType::XXX_FromMixed($v);
          break;
        case 'weak':
          $this->weak = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
      }
    }
  }
}

class OneofOptions implements \Protobuf\Message {
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;

  public function __construct() {
    $this->uninterpreted_option = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
      }
    }
  }
}

class EnumOptions implements \Protobuf\Message {
  public bool $allow_alias;
  public bool $deprecated;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;

  public function __construct() {
    $this->allow_alias = false;
    $this->deprecated = false;
    $this->uninterpreted_option = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 2:
          $this->allow_alias = $d->readBool();
          break;
        case 3:
          $this->deprecated = $d->readBool();
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->allow_alias !== false) {
      $e->writeTag(2, 0);
      $e->writeBool($this->allow_alias);
    }
    if ($this->deprecated !== false) {
      $e->writeTag(3, 0);
      $e->writeBool($this->deprecated);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('allow_alias', 'allowAlias', $this->allow_alias, false);
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'allow_alias': case 'allowAlias':
          $this->allow_alias = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
      }
    }
  }
}

class EnumValueOptions implements \Protobuf\Message {
  public bool $deprecated;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;

  public function __construct() {
    $this->deprecated = false;
    $this->uninterpreted_option = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->deprecated = $d->readBool();
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->deprecated !== false) {
      $e->writeTag(1, 0);
      $e->writeBool($this->deprecated);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
      }
    }
  }
}

class ServiceOptions implements \Protobuf\Message {
  public bool $deprecated;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;

  public function __construct() {
    $this->deprecated = false;
    $this->uninterpreted_option = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 33:
          $this->deprecated = $d->readBool();
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->deprecated !== false) {
      $e->writeTag(33, 0);
      $e->writeBool($this->deprecated);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
      }
    }
  }
}

newtype XXX_MethodOptions_IdempotencyLevel_t as int = int;
abstract class MethodOptions_IdempotencyLevel {
  const XXX_MethodOptions_IdempotencyLevel_t IDEMPOTENCY_UNKNOWN = 0;
  const XXX_MethodOptions_IdempotencyLevel_t NO_SIDE_EFFECTS = 1;
  const XXX_MethodOptions_IdempotencyLevel_t IDEMPOTENT = 2;
  private static dict<int, string> $XXX_itos = dict[
    0 => 'IDEMPOTENCY_UNKNOWN',
    1 => 'NO_SIDE_EFFECTS',
    2 => 'IDEMPOTENT',
  ];
  public static function XXX_ItoS(): dict<int, string> {
    return self::$XXX_itos;
  }
  private static dict<string, int> $XXX_stoi = dict[
    'IDEMPOTENCY_UNKNOWN' => 0,
    'NO_SIDE_EFFECTS' => 1,
    'IDEMPOTENT' => 2,
  ];
  public static function XXX_FromMixed(mixed $m): XXX_MethodOptions_IdempotencyLevel_t {
    if ($m is string) return idx(self::$XXX_stoi, $m, is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function XXX_FromInt(int $i): XXX_MethodOptions_IdempotencyLevel_t {
    return $i;
  }
}

class MethodOptions implements \Protobuf\Message {
  public bool $deprecated;
  public \google\protobuf\XXX_MethodOptions_IdempotencyLevel_t $idempotency_level;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;

  public function __construct() {
    $this->deprecated = false;
    $this->idempotency_level = \google\protobuf\MethodOptions_IdempotencyLevel::XXX_FromInt(0);
    $this->uninterpreted_option = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 33:
          $this->deprecated = $d->readBool();
          break;
        case 34:
          $this->idempotency_level = \google\protobuf\MethodOptions_IdempotencyLevel::XXX_FromInt($d->readVarint());
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->deprecated !== false) {
      $e->writeTag(33, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->idempotency_level !== \google\protobuf\MethodOptions_IdempotencyLevel::XXX_FromInt(0)) {
      $e->writeTag(34, 0);
      $e->writeVarint($this->idempotency_level);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeEnum('idempotency_level', 'idempotencyLevel', \google\protobuf\MethodOptions_IdempotencyLevel::XXX_ItoS(), $this->idempotency_level, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'idempotency_level': case 'idempotencyLevel':
          $this->idempotency_level = \google\protobuf\MethodOptions_IdempotencyLevel::XXX_FromMixed($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
      }
    }
  }
}

class UninterpretedOption_NamePart implements \Protobuf\Message {
  public string $name_part;
  public bool $is_extension;

  public function __construct() {
    $this->name_part = '';
    $this->is_extension = false;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name_part = $d->readString();
          break;
        case 2:
          $this->is_extension = $d->readBool();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name_part !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name_part);
    }
    if ($this->is_extension !== false) {
      $e->writeTag(2, 0);
      $e->writeBool($this->is_extension);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name_part', 'namePart', $this->name_part, false);
    $e->writeBool('is_extension', 'isExtension', $this->is_extension, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name_part': case 'namePart':
          $this->name_part = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'is_extension': case 'isExtension':
          $this->is_extension = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
      }
    }
  }
}

class UninterpretedOption implements \Protobuf\Message {
  public vec<\google\protobuf\UninterpretedOption_NamePart> $name;
  public string $identifier_value;
  public int $positive_int_value;
  public int $negative_int_value;
  public float $double_value;
  public string $string_value;
  public string $aggregate_value;

  public function __construct() {
    $this->name = vec[];
    $this->identifier_value = '';
    $this->positive_int_value = 0;
    $this->negative_int_value = 0;
    $this->double_value = 0.0;
    $this->string_value = '';
    $this->aggregate_value = '';
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 2:
          $obj = new \google\protobuf\UninterpretedOption_NamePart();
          $obj->MergeFrom($d->readDecoder());
          $this->name []= $obj;
          break;
        case 3:
          $this->identifier_value = $d->readString();
          break;
        case 4:
          $this->positive_int_value = $d->readVarint();
          break;
        case 5:
          $this->negative_int_value = $d->readVarint();
          break;
        case 6:
          $this->double_value = $d->readDouble();
          break;
        case 7:
          $this->string_value = $d->readString();
          break;
        case 8:
          $this->aggregate_value = $d->readString();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->name as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    if ($this->identifier_value !== '') {
      $e->writeTag(3, 2);
      $e->writeString($this->identifier_value);
    }
    if ($this->positive_int_value !== 0) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->positive_int_value);
    }
    if ($this->negative_int_value !== 0) {
      $e->writeTag(5, 0);
      $e->writeVarint($this->negative_int_value);
    }
    if ($this->double_value !== 0.0) {
      $e->writeTag(6, 1);
      $e->writeDouble($this->double_value);
    }
    if ($this->string_value !== '') {
      $e->writeTag(7, 2);
      $e->writeString($this->string_value);
    }
    if ($this->aggregate_value !== '') {
      $e->writeTag(8, 2);
      $e->writeString($this->aggregate_value);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('name', 'name', $this->name);
    $e->writeString('identifier_value', 'identifierValue', $this->identifier_value, false);
    $e->writeInt64Unsigned('positive_int_value', 'positiveIntValue', $this->positive_int_value, false);
    $e->writeInt64Signed('negative_int_value', 'negativeIntValue', $this->negative_int_value, false);
    $e->writeFloat('double_value', 'doubleValue', $this->double_value, false);
    $e->writeBytes('string_value', 'stringValue', $this->string_value, false);
    $e->writeString('aggregate_value', 'aggregateValue', $this->aggregate_value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption_NamePart();
            $obj->MergeJsonFrom($vv);
            $this->name []= $obj;
          }
          break;
        case 'identifier_value': case 'identifierValue':
          $this->identifier_value = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'positive_int_value': case 'positiveIntValue':
          $this->positive_int_value = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'negative_int_value': case 'negativeIntValue':
          $this->negative_int_value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'double_value': case 'doubleValue':
          $this->double_value = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        case 'string_value': case 'stringValue':
          $this->string_value = \Protobuf\Internal\JsonDecoder::readBytes($v);
          break;
        case 'aggregate_value': case 'aggregateValue':
          $this->aggregate_value = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
      }
    }
  }
}

class SourceCodeInfo_Location implements \Protobuf\Message {
  public vec<int> $path;
  public vec<int> $span;
  public string $leading_comments;
  public string $trailing_comments;
  public vec<string> $leading_detached_comments;

  public function __construct() {
    $this->path = vec[];
    $this->span = vec[];
    $this->leading_comments = '';
    $this->trailing_comments = '';
    $this->leading_detached_comments = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->path []= $packed->readVarint32Signed();
            }
          } else {
            $this->path []= $d->readVarint32Signed();
          }
          break;
        case 2:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->span []= $packed->readVarint32Signed();
            }
          } else {
            $this->span []= $d->readVarint32Signed();
          }
          break;
        case 3:
          $this->leading_comments = $d->readString();
          break;
        case 4:
          $this->trailing_comments = $d->readString();
          break;
        case 6:
          $this->leading_detached_comments []= $d->readString();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->path as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 1);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->span as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 2);
    if ($this->leading_comments !== '') {
      $e->writeTag(3, 2);
      $e->writeString($this->leading_comments);
    }
    if ($this->trailing_comments !== '') {
      $e->writeTag(4, 2);
      $e->writeString($this->trailing_comments);
    }
    foreach ($this->leading_detached_comments as $elem) {
      $e->writeTag(6, 2);
      $e->writeString($elem);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writePrimitiveList('path', 'path', $this->path);
    $e->writePrimitiveList('span', 'span', $this->span);
    $e->writeString('leading_comments', 'leadingComments', $this->leading_comments, false);
    $e->writeString('trailing_comments', 'trailingComments', $this->trailing_comments, false);
    $e->writePrimitiveList('leading_detached_comments', 'leadingDetachedComments', $this->leading_detached_comments);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'path':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->path []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'span':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->span []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'leading_comments': case 'leadingComments':
          $this->leading_comments = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'trailing_comments': case 'trailingComments':
          $this->trailing_comments = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'leading_detached_comments': case 'leadingDetachedComments':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->leading_detached_comments []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
      }
    }
  }
}

class SourceCodeInfo implements \Protobuf\Message {
  public vec<\google\protobuf\SourceCodeInfo_Location> $location;

  public function __construct() {
    $this->location = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\SourceCodeInfo_Location();
          $obj->MergeFrom($d->readDecoder());
          $this->location []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->location as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('location', 'location', $this->location);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'location':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\SourceCodeInfo_Location();
            $obj->MergeJsonFrom($vv);
            $this->location []= $obj;
          }
          break;
      }
    }
  }
}

class GeneratedCodeInfo_Annotation implements \Protobuf\Message {
  public vec<int> $path;
  public string $source_file;
  public int $begin;
  public int $end;

  public function __construct() {
    $this->path = vec[];
    $this->source_file = '';
    $this->begin = 0;
    $this->end = 0;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->path []= $packed->readVarint32Signed();
            }
          } else {
            $this->path []= $d->readVarint32Signed();
          }
          break;
        case 2:
          $this->source_file = $d->readString();
          break;
        case 3:
          $this->begin = $d->readVarint32Signed();
          break;
        case 4:
          $this->end = $d->readVarint32Signed();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->path as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 1);
    if ($this->source_file !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->source_file);
    }
    if ($this->begin !== 0) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->begin);
    }
    if ($this->end !== 0) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->end);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writePrimitiveList('path', 'path', $this->path);
    $e->writeString('source_file', 'sourceFile', $this->source_file, false);
    $e->writeInt32('begin', 'begin', $this->begin, false);
    $e->writeInt32('end', 'end', $this->end, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'path':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->path []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'source_file': case 'sourceFile':
          $this->source_file = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'begin':
          $this->begin = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
      }
    }
  }
}

class GeneratedCodeInfo implements \Protobuf\Message {
  public vec<\google\protobuf\GeneratedCodeInfo_Annotation> $annotation;

  public function __construct() {
    $this->annotation = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\GeneratedCodeInfo_Annotation();
          $obj->MergeFrom($d->readDecoder());
          $this->annotation []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->annotation as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('annotation', 'annotation', $this->annotation);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'annotation':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\GeneratedCodeInfo_Annotation();
            $obj->MergeJsonFrom($vv);
            $this->annotation []= $obj;
          }
          break;
      }
    }
  }
}


class XXX_FileDescriptor_descriptor__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'descriptor.proto';
  const string RAW =
  'eNrEWd2O28YVDvW30pFWOzu7senNj9fKj9dOrA0c23HWRVqtRG/k7koqpW1+gIKYJUcSbY'
  .'pkSMr2Br0w0KteFehVURS96E2APkCB3vUJCuQNirZA+wi9LGaGpEhJG28CxLmS5jvfOXPm'
  .'zJmZM0NABvV1z3QDx6u7nhM4eG3kOCOLitbJdFg7gvX7pkVbMbFPA3wXckPTorK0nd0p33'
  .'yzPqdUT2v0GKxyjdq/c7CxRIox5GwyYRalnZLK/2MZVlyiPyIjKmc4HDXx6wAGdaltUFs/'
  .'lbPb2Z2SmkDwO7DuTk8sU9cSNNjO7uRVJAStGfkqrD2h5FGSWubUKoMTxCZUJtT3yYhqwa'
  .'lL5Rwf/fbC6OdHXg61BqcuxQ0oUXs6ERbyZ8RPsaeTeStFphaaWPGp99jUqVzgBq4uGOgL'
  .'+byNSA83oUSfBtT2TceWV7iRt5bMIrWMeRMzPXwHVhw3MB3bl4vb0k755qtLE6ErOGpExm'
  .'1AvjP1dKrpjkE10x46cokbuLw4EE5sOgZt20NHrfqpNr4ABf/UDshTucIzJGzV/lqAtfOk'
  .'2D3ID9ko5cy3iYHQSQex8B2D2ICyTf2AGiIjsufMKRBKiymV+04p9SmsxS5pHrFHUW7uPs'
  .'+TuhLpqUxNrdJUG7cAHJs6Q82guiUXz4hSl1EWouQIVLfwh7NUWzkjU47EIlvItmOoepTl'
  .'PTXCkZW4E/XnjkwN1cTAVr1kE78BMaDxtAK+C1UisEMmdOtLqKbDgzch7wfEC3gW5lXRwA'
  .'iy1Db4LpdX2V/8k9mAs3zAby/OaMry/Li3PoDV1ADO23Xtl/DyUtP4U9ic2qYdUM/1KMtY'
  .'0ZX8n5Uzcu44yRZW1I3pIni9VPzvCnr27NmzTO13BdhctmaWLt8LULCnkxPq8SDl1bCFG5'
  .'C3yAm15Ny2tFO9+c65VmX9kKmoQhN/BLlwi2YWrp/PAltLKtfDr0CJ/YrcKHCfiwxgeYG3'
  .'oMiXiUGjoy1us8Qy6JBMrUB7TKwp5QlfUish+HOG4ctQFqvKtA36lO+eeVUstDZDWPcPfc'
  .'eOUpN3wQDe/QfzG/dry4c3n1O1v2Qgx/eLNSgPPuspWqt7vH+oIAlXAThw/7DbGKBM3G53'
  .'BnduoWyscCyAXJLw/k2UxwgqwkD7U6V15xYqpJH3b6IVvAoljux3u4eoGNvsD9R25wCVYp'
  .'sHave4hyC2cKT0+40DBZVjxv5nA6WPKim33r+JVuMulM7xEaridVgVXUROrM1Bd24hNHNE'
  .'WFlPAXduIVxrQp5nF8ZQPWzsK4datzdodzuNQyTNMFX52XFbVVook8R6SmOgtFC2psPmsn'
  .'1y6cpITHHmjCnmtham+F8Z2FhyVizt5MeQFykqTs9rSw8dnrALJyjXS1YQ2TMqCGZiYU//'
  .'xcKeLo69O+c59jj27fb2/JK9/R6sLxg69x77Kwnks4LznJ0uk9rp7s1H8MrZk7Aw119JcG'
  .'F5pbjUh4+gMKHB2ImqpbeXnMFMPD/ZoVbyEM+eVe4JbxY8/XUGXl5qfKmjrwGYtjsNREUk'
  .'NtgSR/jmxTbPaRDLs1wOAuKEuzNHc9zR188Y6UJivgdIt0xqB5ofeJRMTHvET5DiXn5ILJ'
  .'+qa0Lcj6RMgyeQl9AopDSEONao/bYE5URdja9A5SF5TLToriQiUWZYL7wvvQebnOJMA+pp'
  .'ukV8nwetyKmYybpM1Iwk+DZscI3J1ApM16Iau735/CSJPVtnjKOQwDzycQte42ojalOPBF'
  .'SjX0yJ5WvENrQx8cfyJjOwn5El9RIjHoQ8hdMatvEx8cd4Dy5wK37gmfZI08dUf6RNg+Fd'
  .'+ZVk/9zDPuc0GeU4GN7FfaiwyZiYX1Jt6Hj8aKwu2ZoSEax3Q4Ujx6B7+X5PUVpqObJy3/'
  .'FYQo2cOMBlkVAjJwrvbdjQdTFmU9fCO5Yvo1SwdP1AEMIc9/GH8PIsWEnF9YVRzqvehg33'
  .'dFERp3p0T+fVPoBNd+wu6l1P6mF37M4rvsUv3B7VSUAN+WKSnhDgXUC6rlGbnFhUIx61iS'
  .'9fTpKruq5waYML8XVYd04e6iIlNdejQ/Op/CaP7xoT8ITscRhfA6T7Y+K5fE/2XaJT+S1B'
  .'FXgngtmS8J+YwyCyeFUsCY6F1nYAsVCkOt7htKo7dpP9vgGrjDnr9JooyNxxosdbcIGRJj'
  .'QgBglIgv0uZ7O4H4XClJ/e9OQ0zqwbwk+GRbn1vRXdtT2oJBMfl0CkPpJYFdTstlj98rmC'
  .'MqyOOmwPFE097gzaRwrKJgr2B7ni2+hq7esMVNM3MPwjuBg9l/g00J6YHl+REyJOxzgnNk'
  .'NWnwafmB5bbxMS4EO4bDuaHxDbIJ6hzR6qNKLr1PcdcRLGVl61nX5Inh0RjZA6l7/Zs/L3'
  .'FShNiKtRO/BOed1dVIsT4iqs/UKuPw9yxSIqPcgVSwhq/8xCJVmHs2uNzo8siW9qb3xj1V'
  .'5vsrNsryCqY1VosjqCJRsV1UhRDVv4AAoPfW67wG2/+c22H/S58dKDvtbpqkeNQzVUx5cg'
  .'Z5EvT9OnHofOOwmXIPeEkkfps4ZD3+Ni2IU8jxcGCCOGXsJFyDW7KlsQCCoC1XptpamgTO'
  .'02FEQQ2GKJw4BeCpuhDSmSHh/tKyrKpKc6h/I1HyrJQvzFXLL/JkE5UViziohYlvNEI5ZJ'
  .'/DA1gEMNhpx36l7QEsmjQu2PEqD5ynbOTemHdLP2Bwmq6XJ2zr0rP6h7/8jAaqqIPa93X8'
  .'C6adCJ6wTU1k81iz6mllzjm8buN5fJ9fZM75Cp7W20W8pRrztQOs3PtOPOTzvdTzoqMudo'
  .'3+Oy7wGadwpfhGVuoZfwBqx1ulq/3VI05f59pTnoi4ePmD1ILfDa77OwscQT3AivLOIWde'
  .'M83tdZzdAjXhDecK4Bi5IdmEOTeuE7kbjHrM1w8VT0LmDX8c3AfEw1044eldi9JqeiSNK2'
  .'g5ht0xGZY7PNPKuiSBKzr0DFcKas2BM8dnZIallgMSUs42evWRW1LDBBuQprZDTymPHIkL'
  .'iYVGOYE7ceQDGKAzuqWSQ0V9y2MzsltWhHwitQMX1t9jif2c7sFNWy6ccPm7WvMlBNf1zA'
  .'LShajk54aokvWzvP+R5RPwz5aqy59XcJihGML0DOJcGYm8vvZ5Ck8jbDfZfYPAVCnLXZvF'
  .'qUGPzW40wm1A78aF5DvBnC+B1YDzxiWilujnNRJIjJe3ApsmvQgOhjasyUCvx142JIaIXy'
  .'SLf2tQTr0T3NiIN1BEBs2wmS4VpM5QW9eiNWUhMGtiYAM8mZYbsM5fDLEf/8KG72ICB2oc'
  .'ObkD+hI9MO34NFI3p/ycXvL/u/kWBDdybz/u6juecF/2Pp849GZjCentR1Z7I7cixij3Yj'
  .'vvij3xhR+8bI2Z0Vqfdmf/8nSX/KZA96+3/ObB2I7npReFQ6tKjOhvz/AAAA///xeV/N';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    return (string)\gzuncompress(\base64_decode(self::RAW));
  }
}
